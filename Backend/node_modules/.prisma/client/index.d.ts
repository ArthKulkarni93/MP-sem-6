
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UniversityTable
 * 
 */
export type UniversityTable = $Result.DefaultSelection<Prisma.$UniversityTablePayload>
/**
 * Model BranchTable
 * 
 */
export type BranchTable = $Result.DefaultSelection<Prisma.$BranchTablePayload>
/**
 * Model YearTable
 * 
 */
export type YearTable = $Result.DefaultSelection<Prisma.$YearTablePayload>
/**
 * Model StudentTable
 * 
 */
export type StudentTable = $Result.DefaultSelection<Prisma.$StudentTablePayload>
/**
 * Model TeacherTable
 * 
 */
export type TeacherTable = $Result.DefaultSelection<Prisma.$TeacherTablePayload>
/**
 * Model TestTable
 * 
 */
export type TestTable = $Result.DefaultSelection<Prisma.$TestTablePayload>
/**
 * Model QuestionsTable
 * 
 */
export type QuestionsTable = $Result.DefaultSelection<Prisma.$QuestionsTablePayload>
/**
 * Model ResultTable
 * 
 */
export type ResultTable = $Result.DefaultSelection<Prisma.$ResultTablePayload>
/**
 * Model StudentResponseTable
 * 
 */
export type StudentResponseTable = $Result.DefaultSelection<Prisma.$StudentResponseTablePayload>
/**
 * Model NotesTable
 * 
 */
export type NotesTable = $Result.DefaultSelection<Prisma.$NotesTablePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UniversityTables
 * const universityTables = await prisma.universityTable.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UniversityTables
   * const universityTables = await prisma.universityTable.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.universityTable`: Exposes CRUD operations for the **UniversityTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UniversityTables
    * const universityTables = await prisma.universityTable.findMany()
    * ```
    */
  get universityTable(): Prisma.UniversityTableDelegate<ExtArgs>;

  /**
   * `prisma.branchTable`: Exposes CRUD operations for the **BranchTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BranchTables
    * const branchTables = await prisma.branchTable.findMany()
    * ```
    */
  get branchTable(): Prisma.BranchTableDelegate<ExtArgs>;

  /**
   * `prisma.yearTable`: Exposes CRUD operations for the **YearTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YearTables
    * const yearTables = await prisma.yearTable.findMany()
    * ```
    */
  get yearTable(): Prisma.YearTableDelegate<ExtArgs>;

  /**
   * `prisma.studentTable`: Exposes CRUD operations for the **StudentTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentTables
    * const studentTables = await prisma.studentTable.findMany()
    * ```
    */
  get studentTable(): Prisma.StudentTableDelegate<ExtArgs>;

  /**
   * `prisma.teacherTable`: Exposes CRUD operations for the **TeacherTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherTables
    * const teacherTables = await prisma.teacherTable.findMany()
    * ```
    */
  get teacherTable(): Prisma.TeacherTableDelegate<ExtArgs>;

  /**
   * `prisma.testTable`: Exposes CRUD operations for the **TestTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestTables
    * const testTables = await prisma.testTable.findMany()
    * ```
    */
  get testTable(): Prisma.TestTableDelegate<ExtArgs>;

  /**
   * `prisma.questionsTable`: Exposes CRUD operations for the **QuestionsTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsTables
    * const questionsTables = await prisma.questionsTable.findMany()
    * ```
    */
  get questionsTable(): Prisma.QuestionsTableDelegate<ExtArgs>;

  /**
   * `prisma.resultTable`: Exposes CRUD operations for the **ResultTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResultTables
    * const resultTables = await prisma.resultTable.findMany()
    * ```
    */
  get resultTable(): Prisma.ResultTableDelegate<ExtArgs>;

  /**
   * `prisma.studentResponseTable`: Exposes CRUD operations for the **StudentResponseTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentResponseTables
    * const studentResponseTables = await prisma.studentResponseTable.findMany()
    * ```
    */
  get studentResponseTable(): Prisma.StudentResponseTableDelegate<ExtArgs>;

  /**
   * `prisma.notesTable`: Exposes CRUD operations for the **NotesTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotesTables
    * const notesTables = await prisma.notesTable.findMany()
    * ```
    */
  get notesTable(): Prisma.NotesTableDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.7.0
   * Query Engine version: 79fb5193cf0a8fdbef536e4b4a159cad677ab1b9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UniversityTable: 'UniversityTable',
    BranchTable: 'BranchTable',
    YearTable: 'YearTable',
    StudentTable: 'StudentTable',
    TeacherTable: 'TeacherTable',
    TestTable: 'TestTable',
    QuestionsTable: 'QuestionsTable',
    ResultTable: 'ResultTable',
    StudentResponseTable: 'StudentResponseTable',
    NotesTable: 'NotesTable'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'universityTable' | 'branchTable' | 'yearTable' | 'studentTable' | 'teacherTable' | 'testTable' | 'questionsTable' | 'resultTable' | 'studentResponseTable' | 'notesTable'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      UniversityTable: {
        payload: Prisma.$UniversityTablePayload<ExtArgs>
        fields: Prisma.UniversityTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UniversityTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UniversityTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          findFirst: {
            args: Prisma.UniversityTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UniversityTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          findMany: {
            args: Prisma.UniversityTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>[]
          }
          create: {
            args: Prisma.UniversityTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          createMany: {
            args: Prisma.UniversityTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UniversityTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          update: {
            args: Prisma.UniversityTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          deleteMany: {
            args: Prisma.UniversityTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UniversityTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UniversityTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          aggregate: {
            args: Prisma.UniversityTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUniversityTable>
          }
          groupBy: {
            args: Prisma.UniversityTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UniversityTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.UniversityTableCountArgs<ExtArgs>,
            result: $Utils.Optional<UniversityTableCountAggregateOutputType> | number
          }
        }
      }
      BranchTable: {
        payload: Prisma.$BranchTablePayload<ExtArgs>
        fields: Prisma.BranchTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          findFirst: {
            args: Prisma.BranchTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          findMany: {
            args: Prisma.BranchTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>[]
          }
          create: {
            args: Prisma.BranchTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          createMany: {
            args: Prisma.BranchTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BranchTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          update: {
            args: Prisma.BranchTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          deleteMany: {
            args: Prisma.BranchTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BranchTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BranchTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          aggregate: {
            args: Prisma.BranchTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBranchTable>
          }
          groupBy: {
            args: Prisma.BranchTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BranchTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchTableCountArgs<ExtArgs>,
            result: $Utils.Optional<BranchTableCountAggregateOutputType> | number
          }
        }
      }
      YearTable: {
        payload: Prisma.$YearTablePayload<ExtArgs>
        fields: Prisma.YearTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YearTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YearTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          findFirst: {
            args: Prisma.YearTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YearTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          findMany: {
            args: Prisma.YearTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>[]
          }
          create: {
            args: Prisma.YearTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          createMany: {
            args: Prisma.YearTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.YearTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          update: {
            args: Prisma.YearTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          deleteMany: {
            args: Prisma.YearTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.YearTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.YearTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          aggregate: {
            args: Prisma.YearTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateYearTable>
          }
          groupBy: {
            args: Prisma.YearTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<YearTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.YearTableCountArgs<ExtArgs>,
            result: $Utils.Optional<YearTableCountAggregateOutputType> | number
          }
        }
      }
      StudentTable: {
        payload: Prisma.$StudentTablePayload<ExtArgs>
        fields: Prisma.StudentTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          findFirst: {
            args: Prisma.StudentTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          findMany: {
            args: Prisma.StudentTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>[]
          }
          create: {
            args: Prisma.StudentTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          createMany: {
            args: Prisma.StudentTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          update: {
            args: Prisma.StudentTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          deleteMany: {
            args: Prisma.StudentTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          aggregate: {
            args: Prisma.StudentTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentTable>
          }
          groupBy: {
            args: Prisma.StudentTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentTableCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentTableCountAggregateOutputType> | number
          }
        }
      }
      TeacherTable: {
        payload: Prisma.$TeacherTablePayload<ExtArgs>
        fields: Prisma.TeacherTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          findFirst: {
            args: Prisma.TeacherTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          findMany: {
            args: Prisma.TeacherTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>[]
          }
          create: {
            args: Prisma.TeacherTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          createMany: {
            args: Prisma.TeacherTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TeacherTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          update: {
            args: Prisma.TeacherTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          deleteMany: {
            args: Prisma.TeacherTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TeacherTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          aggregate: {
            args: Prisma.TeacherTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeacherTable>
          }
          groupBy: {
            args: Prisma.TeacherTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeacherTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherTableCountArgs<ExtArgs>,
            result: $Utils.Optional<TeacherTableCountAggregateOutputType> | number
          }
        }
      }
      TestTable: {
        payload: Prisma.$TestTablePayload<ExtArgs>
        fields: Prisma.TestTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          findFirst: {
            args: Prisma.TestTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          findMany: {
            args: Prisma.TestTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>[]
          }
          create: {
            args: Prisma.TestTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          createMany: {
            args: Prisma.TestTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TestTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          update: {
            args: Prisma.TestTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          deleteMany: {
            args: Prisma.TestTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TestTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TestTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          aggregate: {
            args: Prisma.TestTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTestTable>
          }
          groupBy: {
            args: Prisma.TestTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TestTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestTableCountArgs<ExtArgs>,
            result: $Utils.Optional<TestTableCountAggregateOutputType> | number
          }
        }
      }
      QuestionsTable: {
        payload: Prisma.$QuestionsTablePayload<ExtArgs>
        fields: Prisma.QuestionsTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionsTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionsTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          findFirst: {
            args: Prisma.QuestionsTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionsTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          findMany: {
            args: Prisma.QuestionsTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>[]
          }
          create: {
            args: Prisma.QuestionsTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          createMany: {
            args: Prisma.QuestionsTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.QuestionsTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          update: {
            args: Prisma.QuestionsTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          deleteMany: {
            args: Prisma.QuestionsTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionsTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.QuestionsTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          aggregate: {
            args: Prisma.QuestionsTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQuestionsTable>
          }
          groupBy: {
            args: Prisma.QuestionsTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QuestionsTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionsTableCountArgs<ExtArgs>,
            result: $Utils.Optional<QuestionsTableCountAggregateOutputType> | number
          }
        }
      }
      ResultTable: {
        payload: Prisma.$ResultTablePayload<ExtArgs>
        fields: Prisma.ResultTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResultTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResultTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          findFirst: {
            args: Prisma.ResultTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResultTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          findMany: {
            args: Prisma.ResultTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>[]
          }
          create: {
            args: Prisma.ResultTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          createMany: {
            args: Prisma.ResultTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResultTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          update: {
            args: Prisma.ResultTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          deleteMany: {
            args: Prisma.ResultTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResultTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResultTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          aggregate: {
            args: Prisma.ResultTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResultTable>
          }
          groupBy: {
            args: Prisma.ResultTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResultTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResultTableCountArgs<ExtArgs>,
            result: $Utils.Optional<ResultTableCountAggregateOutputType> | number
          }
        }
      }
      StudentResponseTable: {
        payload: Prisma.$StudentResponseTablePayload<ExtArgs>
        fields: Prisma.StudentResponseTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentResponseTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentResponseTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentResponseTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentResponseTablePayload>
          }
          findFirst: {
            args: Prisma.StudentResponseTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentResponseTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentResponseTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentResponseTablePayload>
          }
          findMany: {
            args: Prisma.StudentResponseTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentResponseTablePayload>[]
          }
          create: {
            args: Prisma.StudentResponseTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentResponseTablePayload>
          }
          createMany: {
            args: Prisma.StudentResponseTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentResponseTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentResponseTablePayload>
          }
          update: {
            args: Prisma.StudentResponseTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentResponseTablePayload>
          }
          deleteMany: {
            args: Prisma.StudentResponseTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentResponseTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentResponseTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentResponseTablePayload>
          }
          aggregate: {
            args: Prisma.StudentResponseTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentResponseTable>
          }
          groupBy: {
            args: Prisma.StudentResponseTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentResponseTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentResponseTableCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentResponseTableCountAggregateOutputType> | number
          }
        }
      }
      NotesTable: {
        payload: Prisma.$NotesTablePayload<ExtArgs>
        fields: Prisma.NotesTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotesTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotesTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotesTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotesTablePayload>
          }
          findFirst: {
            args: Prisma.NotesTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotesTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotesTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotesTablePayload>
          }
          findMany: {
            args: Prisma.NotesTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotesTablePayload>[]
          }
          create: {
            args: Prisma.NotesTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotesTablePayload>
          }
          createMany: {
            args: Prisma.NotesTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotesTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotesTablePayload>
          }
          update: {
            args: Prisma.NotesTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotesTablePayload>
          }
          deleteMany: {
            args: Prisma.NotesTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotesTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotesTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotesTablePayload>
          }
          aggregate: {
            args: Prisma.NotesTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotesTable>
          }
          groupBy: {
            args: Prisma.NotesTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotesTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotesTableCountArgs<ExtArgs>,
            result: $Utils.Optional<NotesTableCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UniversityTableCountOutputType
   */

  export type UniversityTableCountOutputType = {
    branches: number
    students: number
    teachers: number
    years: number
    notes: number
  }

  export type UniversityTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | UniversityTableCountOutputTypeCountBranchesArgs
    students?: boolean | UniversityTableCountOutputTypeCountStudentsArgs
    teachers?: boolean | UniversityTableCountOutputTypeCountTeachersArgs
    years?: boolean | UniversityTableCountOutputTypeCountYearsArgs
    notes?: boolean | UniversityTableCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes

  /**
   * UniversityTableCountOutputType without action
   */
  export type UniversityTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTableCountOutputType
     */
    select?: UniversityTableCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UniversityTableCountOutputType without action
   */
  export type UniversityTableCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchTableWhereInput
  }


  /**
   * UniversityTableCountOutputType without action
   */
  export type UniversityTableCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTableWhereInput
  }


  /**
   * UniversityTableCountOutputType without action
   */
  export type UniversityTableCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherTableWhereInput
  }


  /**
   * UniversityTableCountOutputType without action
   */
  export type UniversityTableCountOutputTypeCountYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearTableWhereInput
  }


  /**
   * UniversityTableCountOutputType without action
   */
  export type UniversityTableCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesTableWhereInput
  }



  /**
   * Count Type BranchTableCountOutputType
   */

  export type BranchTableCountOutputType = {
    students: number
    teachers: number
    tests: number
    years: number
    notes: number
  }

  export type BranchTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | BranchTableCountOutputTypeCountStudentsArgs
    teachers?: boolean | BranchTableCountOutputTypeCountTeachersArgs
    tests?: boolean | BranchTableCountOutputTypeCountTestsArgs
    years?: boolean | BranchTableCountOutputTypeCountYearsArgs
    notes?: boolean | BranchTableCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes

  /**
   * BranchTableCountOutputType without action
   */
  export type BranchTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTableCountOutputType
     */
    select?: BranchTableCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BranchTableCountOutputType without action
   */
  export type BranchTableCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTableWhereInput
  }


  /**
   * BranchTableCountOutputType without action
   */
  export type BranchTableCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherTableWhereInput
  }


  /**
   * BranchTableCountOutputType without action
   */
  export type BranchTableCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTableWhereInput
  }


  /**
   * BranchTableCountOutputType without action
   */
  export type BranchTableCountOutputTypeCountYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearTableWhereInput
  }


  /**
   * BranchTableCountOutputType without action
   */
  export type BranchTableCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesTableWhereInput
  }



  /**
   * Count Type YearTableCountOutputType
   */

  export type YearTableCountOutputType = {
    students: number
    tests: number
    notes: number
  }

  export type YearTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | YearTableCountOutputTypeCountStudentsArgs
    tests?: boolean | YearTableCountOutputTypeCountTestsArgs
    notes?: boolean | YearTableCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes

  /**
   * YearTableCountOutputType without action
   */
  export type YearTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTableCountOutputType
     */
    select?: YearTableCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * YearTableCountOutputType without action
   */
  export type YearTableCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTableWhereInput
  }


  /**
   * YearTableCountOutputType without action
   */
  export type YearTableCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTableWhereInput
  }


  /**
   * YearTableCountOutputType without action
   */
  export type YearTableCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesTableWhereInput
  }



  /**
   * Count Type StudentTableCountOutputType
   */

  export type StudentTableCountOutputType = {
    results: number
    responses: number
  }

  export type StudentTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | StudentTableCountOutputTypeCountResultsArgs
    responses?: boolean | StudentTableCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes

  /**
   * StudentTableCountOutputType without action
   */
  export type StudentTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTableCountOutputType
     */
    select?: StudentTableCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StudentTableCountOutputType without action
   */
  export type StudentTableCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultTableWhereInput
  }


  /**
   * StudentTableCountOutputType without action
   */
  export type StudentTableCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentResponseTableWhereInput
  }



  /**
   * Count Type TeacherTableCountOutputType
   */

  export type TeacherTableCountOutputType = {
    tests: number
    notes: number
  }

  export type TeacherTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tests?: boolean | TeacherTableCountOutputTypeCountTestsArgs
    notes?: boolean | TeacherTableCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes

  /**
   * TeacherTableCountOutputType without action
   */
  export type TeacherTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTableCountOutputType
     */
    select?: TeacherTableCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TeacherTableCountOutputType without action
   */
  export type TeacherTableCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTableWhereInput
  }


  /**
   * TeacherTableCountOutputType without action
   */
  export type TeacherTableCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesTableWhereInput
  }



  /**
   * Count Type TestTableCountOutputType
   */

  export type TestTableCountOutputType = {
    questions: number
    results: number
    responses: number
  }

  export type TestTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | TestTableCountOutputTypeCountQuestionsArgs
    results?: boolean | TestTableCountOutputTypeCountResultsArgs
    responses?: boolean | TestTableCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes

  /**
   * TestTableCountOutputType without action
   */
  export type TestTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTableCountOutputType
     */
    select?: TestTableCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TestTableCountOutputType without action
   */
  export type TestTableCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsTableWhereInput
  }


  /**
   * TestTableCountOutputType without action
   */
  export type TestTableCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultTableWhereInput
  }


  /**
   * TestTableCountOutputType without action
   */
  export type TestTableCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentResponseTableWhereInput
  }



  /**
   * Count Type QuestionsTableCountOutputType
   */

  export type QuestionsTableCountOutputType = {
    responses: number
  }

  export type QuestionsTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | QuestionsTableCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes

  /**
   * QuestionsTableCountOutputType without action
   */
  export type QuestionsTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTableCountOutputType
     */
    select?: QuestionsTableCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * QuestionsTableCountOutputType without action
   */
  export type QuestionsTableCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentResponseTableWhereInput
  }



  /**
   * Models
   */

  /**
   * Model UniversityTable
   */

  export type AggregateUniversityTable = {
    _count: UniversityTableCountAggregateOutputType | null
    _avg: UniversityTableAvgAggregateOutputType | null
    _sum: UniversityTableSumAggregateOutputType | null
    _min: UniversityTableMinAggregateOutputType | null
    _max: UniversityTableMaxAggregateOutputType | null
  }

  export type UniversityTableAvgAggregateOutputType = {
    id: number | null
  }

  export type UniversityTableSumAggregateOutputType = {
    id: number | null
  }

  export type UniversityTableMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
  }

  export type UniversityTableMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
  }

  export type UniversityTableCountAggregateOutputType = {
    id: number
    name: number
    address: number
    _all: number
  }


  export type UniversityTableAvgAggregateInputType = {
    id?: true
  }

  export type UniversityTableSumAggregateInputType = {
    id?: true
  }

  export type UniversityTableMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
  }

  export type UniversityTableMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
  }

  export type UniversityTableCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    _all?: true
  }

  export type UniversityTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UniversityTable to aggregate.
     */
    where?: UniversityTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityTables to fetch.
     */
    orderBy?: UniversityTableOrderByWithRelationInput | UniversityTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UniversityTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UniversityTables
    **/
    _count?: true | UniversityTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UniversityTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UniversityTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UniversityTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UniversityTableMaxAggregateInputType
  }

  export type GetUniversityTableAggregateType<T extends UniversityTableAggregateArgs> = {
        [P in keyof T & keyof AggregateUniversityTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniversityTable[P]>
      : GetScalarType<T[P], AggregateUniversityTable[P]>
  }




  export type UniversityTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UniversityTableWhereInput
    orderBy?: UniversityTableOrderByWithAggregationInput | UniversityTableOrderByWithAggregationInput[]
    by: UniversityTableScalarFieldEnum[] | UniversityTableScalarFieldEnum
    having?: UniversityTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UniversityTableCountAggregateInputType | true
    _avg?: UniversityTableAvgAggregateInputType
    _sum?: UniversityTableSumAggregateInputType
    _min?: UniversityTableMinAggregateInputType
    _max?: UniversityTableMaxAggregateInputType
  }

  export type UniversityTableGroupByOutputType = {
    id: number
    name: string
    address: string
    _count: UniversityTableCountAggregateOutputType | null
    _avg: UniversityTableAvgAggregateOutputType | null
    _sum: UniversityTableSumAggregateOutputType | null
    _min: UniversityTableMinAggregateOutputType | null
    _max: UniversityTableMaxAggregateOutputType | null
  }

  type GetUniversityTableGroupByPayload<T extends UniversityTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UniversityTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UniversityTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UniversityTableGroupByOutputType[P]>
            : GetScalarType<T[P], UniversityTableGroupByOutputType[P]>
        }
      >
    >


  export type UniversityTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    branches?: boolean | UniversityTable$branchesArgs<ExtArgs>
    students?: boolean | UniversityTable$studentsArgs<ExtArgs>
    teachers?: boolean | UniversityTable$teachersArgs<ExtArgs>
    years?: boolean | UniversityTable$yearsArgs<ExtArgs>
    notes?: boolean | UniversityTable$notesArgs<ExtArgs>
    _count?: boolean | UniversityTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["universityTable"]>

  export type UniversityTableSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
  }

  export type UniversityTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | UniversityTable$branchesArgs<ExtArgs>
    students?: boolean | UniversityTable$studentsArgs<ExtArgs>
    teachers?: boolean | UniversityTable$teachersArgs<ExtArgs>
    years?: boolean | UniversityTable$yearsArgs<ExtArgs>
    notes?: boolean | UniversityTable$notesArgs<ExtArgs>
    _count?: boolean | UniversityTableCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UniversityTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UniversityTable"
    objects: {
      branches: Prisma.$BranchTablePayload<ExtArgs>[]
      students: Prisma.$StudentTablePayload<ExtArgs>[]
      teachers: Prisma.$TeacherTablePayload<ExtArgs>[]
      years: Prisma.$YearTablePayload<ExtArgs>[]
      notes: Prisma.$NotesTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string
    }, ExtArgs["result"]["universityTable"]>
    composites: {}
  }


  type UniversityTableGetPayload<S extends boolean | null | undefined | UniversityTableDefaultArgs> = $Result.GetResult<Prisma.$UniversityTablePayload, S>

  type UniversityTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UniversityTableFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UniversityTableCountAggregateInputType | true
    }

  export interface UniversityTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UniversityTable'], meta: { name: 'UniversityTable' } }
    /**
     * Find zero or one UniversityTable that matches the filter.
     * @param {UniversityTableFindUniqueArgs} args - Arguments to find a UniversityTable
     * @example
     * // Get one UniversityTable
     * const universityTable = await prisma.universityTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UniversityTableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UniversityTableFindUniqueArgs<ExtArgs>>
    ): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UniversityTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UniversityTableFindUniqueOrThrowArgs} args - Arguments to find a UniversityTable
     * @example
     * // Get one UniversityTable
     * const universityTable = await prisma.universityTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UniversityTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UniversityTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UniversityTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableFindFirstArgs} args - Arguments to find a UniversityTable
     * @example
     * // Get one UniversityTable
     * const universityTable = await prisma.universityTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UniversityTableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UniversityTableFindFirstArgs<ExtArgs>>
    ): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UniversityTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableFindFirstOrThrowArgs} args - Arguments to find a UniversityTable
     * @example
     * // Get one UniversityTable
     * const universityTable = await prisma.universityTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UniversityTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UniversityTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UniversityTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UniversityTables
     * const universityTables = await prisma.universityTable.findMany()
     * 
     * // Get first 10 UniversityTables
     * const universityTables = await prisma.universityTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const universityTableWithIdOnly = await prisma.universityTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UniversityTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UniversityTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UniversityTable.
     * @param {UniversityTableCreateArgs} args - Arguments to create a UniversityTable.
     * @example
     * // Create one UniversityTable
     * const UniversityTable = await prisma.universityTable.create({
     *   data: {
     *     // ... data to create a UniversityTable
     *   }
     * })
     * 
    **/
    create<T extends UniversityTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UniversityTableCreateArgs<ExtArgs>>
    ): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UniversityTables.
     *     @param {UniversityTableCreateManyArgs} args - Arguments to create many UniversityTables.
     *     @example
     *     // Create many UniversityTables
     *     const universityTable = await prisma.universityTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UniversityTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UniversityTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UniversityTable.
     * @param {UniversityTableDeleteArgs} args - Arguments to delete one UniversityTable.
     * @example
     * // Delete one UniversityTable
     * const UniversityTable = await prisma.universityTable.delete({
     *   where: {
     *     // ... filter to delete one UniversityTable
     *   }
     * })
     * 
    **/
    delete<T extends UniversityTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UniversityTableDeleteArgs<ExtArgs>>
    ): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UniversityTable.
     * @param {UniversityTableUpdateArgs} args - Arguments to update one UniversityTable.
     * @example
     * // Update one UniversityTable
     * const universityTable = await prisma.universityTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UniversityTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UniversityTableUpdateArgs<ExtArgs>>
    ): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UniversityTables.
     * @param {UniversityTableDeleteManyArgs} args - Arguments to filter UniversityTables to delete.
     * @example
     * // Delete a few UniversityTables
     * const { count } = await prisma.universityTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UniversityTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UniversityTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UniversityTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UniversityTables
     * const universityTable = await prisma.universityTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UniversityTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UniversityTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UniversityTable.
     * @param {UniversityTableUpsertArgs} args - Arguments to update or create a UniversityTable.
     * @example
     * // Update or create a UniversityTable
     * const universityTable = await prisma.universityTable.upsert({
     *   create: {
     *     // ... data to create a UniversityTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UniversityTable we want to update
     *   }
     * })
    **/
    upsert<T extends UniversityTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UniversityTableUpsertArgs<ExtArgs>>
    ): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UniversityTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableCountArgs} args - Arguments to filter UniversityTables to count.
     * @example
     * // Count the number of UniversityTables
     * const count = await prisma.universityTable.count({
     *   where: {
     *     // ... the filter for the UniversityTables we want to count
     *   }
     * })
    **/
    count<T extends UniversityTableCountArgs>(
      args?: Subset<T, UniversityTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UniversityTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UniversityTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UniversityTableAggregateArgs>(args: Subset<T, UniversityTableAggregateArgs>): Prisma.PrismaPromise<GetUniversityTableAggregateType<T>>

    /**
     * Group by UniversityTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UniversityTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UniversityTableGroupByArgs['orderBy'] }
        : { orderBy?: UniversityTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UniversityTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniversityTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UniversityTable model
   */
  readonly fields: UniversityTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UniversityTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UniversityTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    branches<T extends UniversityTable$branchesArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTable$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    students<T extends UniversityTable$studentsArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTable$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    teachers<T extends UniversityTable$teachersArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTable$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    years<T extends UniversityTable$yearsArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTable$yearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends UniversityTable$notesArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTable$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UniversityTable model
   */ 
  interface UniversityTableFieldRefs {
    readonly id: FieldRef<"UniversityTable", 'Int'>
    readonly name: FieldRef<"UniversityTable", 'String'>
    readonly address: FieldRef<"UniversityTable", 'String'>
  }
    

  // Custom InputTypes

  /**
   * UniversityTable findUnique
   */
  export type UniversityTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter, which UniversityTable to fetch.
     */
    where: UniversityTableWhereUniqueInput
  }


  /**
   * UniversityTable findUniqueOrThrow
   */
  export type UniversityTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter, which UniversityTable to fetch.
     */
    where: UniversityTableWhereUniqueInput
  }


  /**
   * UniversityTable findFirst
   */
  export type UniversityTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter, which UniversityTable to fetch.
     */
    where?: UniversityTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityTables to fetch.
     */
    orderBy?: UniversityTableOrderByWithRelationInput | UniversityTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniversityTables.
     */
    cursor?: UniversityTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniversityTables.
     */
    distinct?: UniversityTableScalarFieldEnum | UniversityTableScalarFieldEnum[]
  }


  /**
   * UniversityTable findFirstOrThrow
   */
  export type UniversityTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter, which UniversityTable to fetch.
     */
    where?: UniversityTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityTables to fetch.
     */
    orderBy?: UniversityTableOrderByWithRelationInput | UniversityTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniversityTables.
     */
    cursor?: UniversityTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniversityTables.
     */
    distinct?: UniversityTableScalarFieldEnum | UniversityTableScalarFieldEnum[]
  }


  /**
   * UniversityTable findMany
   */
  export type UniversityTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter, which UniversityTables to fetch.
     */
    where?: UniversityTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityTables to fetch.
     */
    orderBy?: UniversityTableOrderByWithRelationInput | UniversityTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UniversityTables.
     */
    cursor?: UniversityTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityTables.
     */
    skip?: number
    distinct?: UniversityTableScalarFieldEnum | UniversityTableScalarFieldEnum[]
  }


  /**
   * UniversityTable create
   */
  export type UniversityTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * The data needed to create a UniversityTable.
     */
    data: XOR<UniversityTableCreateInput, UniversityTableUncheckedCreateInput>
  }


  /**
   * UniversityTable createMany
   */
  export type UniversityTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UniversityTables.
     */
    data: UniversityTableCreateManyInput | UniversityTableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UniversityTable update
   */
  export type UniversityTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * The data needed to update a UniversityTable.
     */
    data: XOR<UniversityTableUpdateInput, UniversityTableUncheckedUpdateInput>
    /**
     * Choose, which UniversityTable to update.
     */
    where: UniversityTableWhereUniqueInput
  }


  /**
   * UniversityTable updateMany
   */
  export type UniversityTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UniversityTables.
     */
    data: XOR<UniversityTableUpdateManyMutationInput, UniversityTableUncheckedUpdateManyInput>
    /**
     * Filter which UniversityTables to update
     */
    where?: UniversityTableWhereInput
  }


  /**
   * UniversityTable upsert
   */
  export type UniversityTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * The filter to search for the UniversityTable to update in case it exists.
     */
    where: UniversityTableWhereUniqueInput
    /**
     * In case the UniversityTable found by the `where` argument doesn't exist, create a new UniversityTable with this data.
     */
    create: XOR<UniversityTableCreateInput, UniversityTableUncheckedCreateInput>
    /**
     * In case the UniversityTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UniversityTableUpdateInput, UniversityTableUncheckedUpdateInput>
  }


  /**
   * UniversityTable delete
   */
  export type UniversityTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter which UniversityTable to delete.
     */
    where: UniversityTableWhereUniqueInput
  }


  /**
   * UniversityTable deleteMany
   */
  export type UniversityTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UniversityTables to delete
     */
    where?: UniversityTableWhereInput
  }


  /**
   * UniversityTable.branches
   */
  export type UniversityTable$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchTableInclude<ExtArgs> | null
    where?: BranchTableWhereInput
    orderBy?: BranchTableOrderByWithRelationInput | BranchTableOrderByWithRelationInput[]
    cursor?: BranchTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchTableScalarFieldEnum | BranchTableScalarFieldEnum[]
  }


  /**
   * UniversityTable.students
   */
  export type UniversityTable$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    where?: StudentTableWhereInput
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    cursor?: StudentTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }


  /**
   * UniversityTable.teachers
   */
  export type UniversityTable$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
    where?: TeacherTableWhereInput
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    cursor?: TeacherTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherTableScalarFieldEnum | TeacherTableScalarFieldEnum[]
  }


  /**
   * UniversityTable.years
   */
  export type UniversityTable$yearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
    where?: YearTableWhereInput
    orderBy?: YearTableOrderByWithRelationInput | YearTableOrderByWithRelationInput[]
    cursor?: YearTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearTableScalarFieldEnum | YearTableScalarFieldEnum[]
  }


  /**
   * UniversityTable.notes
   */
  export type UniversityTable$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    where?: NotesTableWhereInput
    orderBy?: NotesTableOrderByWithRelationInput | NotesTableOrderByWithRelationInput[]
    cursor?: NotesTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesTableScalarFieldEnum | NotesTableScalarFieldEnum[]
  }


  /**
   * UniversityTable without action
   */
  export type UniversityTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityTableInclude<ExtArgs> | null
  }



  /**
   * Model BranchTable
   */

  export type AggregateBranchTable = {
    _count: BranchTableCountAggregateOutputType | null
    _avg: BranchTableAvgAggregateOutputType | null
    _sum: BranchTableSumAggregateOutputType | null
    _min: BranchTableMinAggregateOutputType | null
    _max: BranchTableMaxAggregateOutputType | null
  }

  export type BranchTableAvgAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type BranchTableSumAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type BranchTableMinAggregateOutputType = {
    id: number | null
    Branchcode: string | null
    Branchname: string | null
    universityId: number | null
  }

  export type BranchTableMaxAggregateOutputType = {
    id: number | null
    Branchcode: string | null
    Branchname: string | null
    universityId: number | null
  }

  export type BranchTableCountAggregateOutputType = {
    id: number
    Branchcode: number
    Branchname: number
    universityId: number
    _all: number
  }


  export type BranchTableAvgAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type BranchTableSumAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type BranchTableMinAggregateInputType = {
    id?: true
    Branchcode?: true
    Branchname?: true
    universityId?: true
  }

  export type BranchTableMaxAggregateInputType = {
    id?: true
    Branchcode?: true
    Branchname?: true
    universityId?: true
  }

  export type BranchTableCountAggregateInputType = {
    id?: true
    Branchcode?: true
    Branchname?: true
    universityId?: true
    _all?: true
  }

  export type BranchTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchTable to aggregate.
     */
    where?: BranchTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchTables to fetch.
     */
    orderBy?: BranchTableOrderByWithRelationInput | BranchTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BranchTables
    **/
    _count?: true | BranchTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchTableMaxAggregateInputType
  }

  export type GetBranchTableAggregateType<T extends BranchTableAggregateArgs> = {
        [P in keyof T & keyof AggregateBranchTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranchTable[P]>
      : GetScalarType<T[P], AggregateBranchTable[P]>
  }




  export type BranchTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchTableWhereInput
    orderBy?: BranchTableOrderByWithAggregationInput | BranchTableOrderByWithAggregationInput[]
    by: BranchTableScalarFieldEnum[] | BranchTableScalarFieldEnum
    having?: BranchTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchTableCountAggregateInputType | true
    _avg?: BranchTableAvgAggregateInputType
    _sum?: BranchTableSumAggregateInputType
    _min?: BranchTableMinAggregateInputType
    _max?: BranchTableMaxAggregateInputType
  }

  export type BranchTableGroupByOutputType = {
    id: number
    Branchcode: string
    Branchname: string
    universityId: number
    _count: BranchTableCountAggregateOutputType | null
    _avg: BranchTableAvgAggregateOutputType | null
    _sum: BranchTableSumAggregateOutputType | null
    _min: BranchTableMinAggregateOutputType | null
    _max: BranchTableMaxAggregateOutputType | null
  }

  type GetBranchTableGroupByPayload<T extends BranchTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchTableGroupByOutputType[P]>
            : GetScalarType<T[P], BranchTableGroupByOutputType[P]>
        }
      >
    >


  export type BranchTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Branchcode?: boolean
    Branchname?: boolean
    universityId?: boolean
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    students?: boolean | BranchTable$studentsArgs<ExtArgs>
    teachers?: boolean | BranchTable$teachersArgs<ExtArgs>
    tests?: boolean | BranchTable$testsArgs<ExtArgs>
    years?: boolean | BranchTable$yearsArgs<ExtArgs>
    notes?: boolean | BranchTable$notesArgs<ExtArgs>
    _count?: boolean | BranchTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchTable"]>

  export type BranchTableSelectScalar = {
    id?: boolean
    Branchcode?: boolean
    Branchname?: boolean
    universityId?: boolean
  }

  export type BranchTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    students?: boolean | BranchTable$studentsArgs<ExtArgs>
    teachers?: boolean | BranchTable$teachersArgs<ExtArgs>
    tests?: boolean | BranchTable$testsArgs<ExtArgs>
    years?: boolean | BranchTable$yearsArgs<ExtArgs>
    notes?: boolean | BranchTable$notesArgs<ExtArgs>
    _count?: boolean | BranchTableCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BranchTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BranchTable"
    objects: {
      university: Prisma.$UniversityTablePayload<ExtArgs>
      students: Prisma.$StudentTablePayload<ExtArgs>[]
      teachers: Prisma.$TeacherTablePayload<ExtArgs>[]
      tests: Prisma.$TestTablePayload<ExtArgs>[]
      years: Prisma.$YearTablePayload<ExtArgs>[]
      notes: Prisma.$NotesTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      Branchcode: string
      Branchname: string
      universityId: number
    }, ExtArgs["result"]["branchTable"]>
    composites: {}
  }


  type BranchTableGetPayload<S extends boolean | null | undefined | BranchTableDefaultArgs> = $Result.GetResult<Prisma.$BranchTablePayload, S>

  type BranchTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchTableFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BranchTableCountAggregateInputType | true
    }

  export interface BranchTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BranchTable'], meta: { name: 'BranchTable' } }
    /**
     * Find zero or one BranchTable that matches the filter.
     * @param {BranchTableFindUniqueArgs} args - Arguments to find a BranchTable
     * @example
     * // Get one BranchTable
     * const branchTable = await prisma.branchTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BranchTableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BranchTableFindUniqueArgs<ExtArgs>>
    ): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BranchTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BranchTableFindUniqueOrThrowArgs} args - Arguments to find a BranchTable
     * @example
     * // Get one BranchTable
     * const branchTable = await prisma.branchTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BranchTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BranchTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableFindFirstArgs} args - Arguments to find a BranchTable
     * @example
     * // Get one BranchTable
     * const branchTable = await prisma.branchTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BranchTableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchTableFindFirstArgs<ExtArgs>>
    ): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BranchTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableFindFirstOrThrowArgs} args - Arguments to find a BranchTable
     * @example
     * // Get one BranchTable
     * const branchTable = await prisma.branchTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BranchTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BranchTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BranchTables
     * const branchTables = await prisma.branchTable.findMany()
     * 
     * // Get first 10 BranchTables
     * const branchTables = await prisma.branchTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchTableWithIdOnly = await prisma.branchTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BranchTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BranchTable.
     * @param {BranchTableCreateArgs} args - Arguments to create a BranchTable.
     * @example
     * // Create one BranchTable
     * const BranchTable = await prisma.branchTable.create({
     *   data: {
     *     // ... data to create a BranchTable
     *   }
     * })
     * 
    **/
    create<T extends BranchTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BranchTableCreateArgs<ExtArgs>>
    ): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BranchTables.
     *     @param {BranchTableCreateManyArgs} args - Arguments to create many BranchTables.
     *     @example
     *     // Create many BranchTables
     *     const branchTable = await prisma.branchTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BranchTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BranchTable.
     * @param {BranchTableDeleteArgs} args - Arguments to delete one BranchTable.
     * @example
     * // Delete one BranchTable
     * const BranchTable = await prisma.branchTable.delete({
     *   where: {
     *     // ... filter to delete one BranchTable
     *   }
     * })
     * 
    **/
    delete<T extends BranchTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BranchTableDeleteArgs<ExtArgs>>
    ): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BranchTable.
     * @param {BranchTableUpdateArgs} args - Arguments to update one BranchTable.
     * @example
     * // Update one BranchTable
     * const branchTable = await prisma.branchTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BranchTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BranchTableUpdateArgs<ExtArgs>>
    ): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BranchTables.
     * @param {BranchTableDeleteManyArgs} args - Arguments to filter BranchTables to delete.
     * @example
     * // Delete a few BranchTables
     * const { count } = await prisma.branchTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BranchTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BranchTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BranchTables
     * const branchTable = await prisma.branchTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BranchTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BranchTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BranchTable.
     * @param {BranchTableUpsertArgs} args - Arguments to update or create a BranchTable.
     * @example
     * // Update or create a BranchTable
     * const branchTable = await prisma.branchTable.upsert({
     *   create: {
     *     // ... data to create a BranchTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BranchTable we want to update
     *   }
     * })
    **/
    upsert<T extends BranchTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BranchTableUpsertArgs<ExtArgs>>
    ): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BranchTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableCountArgs} args - Arguments to filter BranchTables to count.
     * @example
     * // Count the number of BranchTables
     * const count = await prisma.branchTable.count({
     *   where: {
     *     // ... the filter for the BranchTables we want to count
     *   }
     * })
    **/
    count<T extends BranchTableCountArgs>(
      args?: Subset<T, BranchTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BranchTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchTableAggregateArgs>(args: Subset<T, BranchTableAggregateArgs>): Prisma.PrismaPromise<GetBranchTableAggregateType<T>>

    /**
     * Group by BranchTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchTableGroupByArgs['orderBy'] }
        : { orderBy?: BranchTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BranchTable model
   */
  readonly fields: BranchTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BranchTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    university<T extends UniversityTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTableDefaultArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    students<T extends BranchTable$studentsArgs<ExtArgs> = {}>(args?: Subset<T, BranchTable$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    teachers<T extends BranchTable$teachersArgs<ExtArgs> = {}>(args?: Subset<T, BranchTable$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    tests<T extends BranchTable$testsArgs<ExtArgs> = {}>(args?: Subset<T, BranchTable$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    years<T extends BranchTable$yearsArgs<ExtArgs> = {}>(args?: Subset<T, BranchTable$yearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends BranchTable$notesArgs<ExtArgs> = {}>(args?: Subset<T, BranchTable$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BranchTable model
   */ 
  interface BranchTableFieldRefs {
    readonly id: FieldRef<"BranchTable", 'Int'>
    readonly Branchcode: FieldRef<"BranchTable", 'String'>
    readonly Branchname: FieldRef<"BranchTable", 'String'>
    readonly universityId: FieldRef<"BranchTable", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * BranchTable findUnique
   */
  export type BranchTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter, which BranchTable to fetch.
     */
    where: BranchTableWhereUniqueInput
  }


  /**
   * BranchTable findUniqueOrThrow
   */
  export type BranchTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter, which BranchTable to fetch.
     */
    where: BranchTableWhereUniqueInput
  }


  /**
   * BranchTable findFirst
   */
  export type BranchTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter, which BranchTable to fetch.
     */
    where?: BranchTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchTables to fetch.
     */
    orderBy?: BranchTableOrderByWithRelationInput | BranchTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchTables.
     */
    cursor?: BranchTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchTables.
     */
    distinct?: BranchTableScalarFieldEnum | BranchTableScalarFieldEnum[]
  }


  /**
   * BranchTable findFirstOrThrow
   */
  export type BranchTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter, which BranchTable to fetch.
     */
    where?: BranchTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchTables to fetch.
     */
    orderBy?: BranchTableOrderByWithRelationInput | BranchTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchTables.
     */
    cursor?: BranchTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchTables.
     */
    distinct?: BranchTableScalarFieldEnum | BranchTableScalarFieldEnum[]
  }


  /**
   * BranchTable findMany
   */
  export type BranchTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter, which BranchTables to fetch.
     */
    where?: BranchTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchTables to fetch.
     */
    orderBy?: BranchTableOrderByWithRelationInput | BranchTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BranchTables.
     */
    cursor?: BranchTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchTables.
     */
    skip?: number
    distinct?: BranchTableScalarFieldEnum | BranchTableScalarFieldEnum[]
  }


  /**
   * BranchTable create
   */
  export type BranchTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * The data needed to create a BranchTable.
     */
    data: XOR<BranchTableCreateInput, BranchTableUncheckedCreateInput>
  }


  /**
   * BranchTable createMany
   */
  export type BranchTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BranchTables.
     */
    data: BranchTableCreateManyInput | BranchTableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BranchTable update
   */
  export type BranchTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * The data needed to update a BranchTable.
     */
    data: XOR<BranchTableUpdateInput, BranchTableUncheckedUpdateInput>
    /**
     * Choose, which BranchTable to update.
     */
    where: BranchTableWhereUniqueInput
  }


  /**
   * BranchTable updateMany
   */
  export type BranchTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BranchTables.
     */
    data: XOR<BranchTableUpdateManyMutationInput, BranchTableUncheckedUpdateManyInput>
    /**
     * Filter which BranchTables to update
     */
    where?: BranchTableWhereInput
  }


  /**
   * BranchTable upsert
   */
  export type BranchTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * The filter to search for the BranchTable to update in case it exists.
     */
    where: BranchTableWhereUniqueInput
    /**
     * In case the BranchTable found by the `where` argument doesn't exist, create a new BranchTable with this data.
     */
    create: XOR<BranchTableCreateInput, BranchTableUncheckedCreateInput>
    /**
     * In case the BranchTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchTableUpdateInput, BranchTableUncheckedUpdateInput>
  }


  /**
   * BranchTable delete
   */
  export type BranchTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter which BranchTable to delete.
     */
    where: BranchTableWhereUniqueInput
  }


  /**
   * BranchTable deleteMany
   */
  export type BranchTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchTables to delete
     */
    where?: BranchTableWhereInput
  }


  /**
   * BranchTable.students
   */
  export type BranchTable$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    where?: StudentTableWhereInput
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    cursor?: StudentTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }


  /**
   * BranchTable.teachers
   */
  export type BranchTable$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
    where?: TeacherTableWhereInput
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    cursor?: TeacherTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherTableScalarFieldEnum | TeacherTableScalarFieldEnum[]
  }


  /**
   * BranchTable.tests
   */
  export type BranchTable$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    where?: TestTableWhereInput
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    cursor?: TestTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }


  /**
   * BranchTable.years
   */
  export type BranchTable$yearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
    where?: YearTableWhereInput
    orderBy?: YearTableOrderByWithRelationInput | YearTableOrderByWithRelationInput[]
    cursor?: YearTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearTableScalarFieldEnum | YearTableScalarFieldEnum[]
  }


  /**
   * BranchTable.notes
   */
  export type BranchTable$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    where?: NotesTableWhereInput
    orderBy?: NotesTableOrderByWithRelationInput | NotesTableOrderByWithRelationInput[]
    cursor?: NotesTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesTableScalarFieldEnum | NotesTableScalarFieldEnum[]
  }


  /**
   * BranchTable without action
   */
  export type BranchTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchTableInclude<ExtArgs> | null
  }



  /**
   * Model YearTable
   */

  export type AggregateYearTable = {
    _count: YearTableCountAggregateOutputType | null
    _avg: YearTableAvgAggregateOutputType | null
    _sum: YearTableSumAggregateOutputType | null
    _min: YearTableMinAggregateOutputType | null
    _max: YearTableMaxAggregateOutputType | null
  }

  export type YearTableAvgAggregateOutputType = {
    id: number | null
    year: number | null
    universityId: number | null
    branchId: number | null
  }

  export type YearTableSumAggregateOutputType = {
    id: number | null
    year: number | null
    universityId: number | null
    branchId: number | null
  }

  export type YearTableMinAggregateOutputType = {
    id: number | null
    name: string | null
    year: number | null
    universityId: number | null
    branchId: number | null
  }

  export type YearTableMaxAggregateOutputType = {
    id: number | null
    name: string | null
    year: number | null
    universityId: number | null
    branchId: number | null
  }

  export type YearTableCountAggregateOutputType = {
    id: number
    name: number
    year: number
    universityId: number
    branchId: number
    _all: number
  }


  export type YearTableAvgAggregateInputType = {
    id?: true
    year?: true
    universityId?: true
    branchId?: true
  }

  export type YearTableSumAggregateInputType = {
    id?: true
    year?: true
    universityId?: true
    branchId?: true
  }

  export type YearTableMinAggregateInputType = {
    id?: true
    name?: true
    year?: true
    universityId?: true
    branchId?: true
  }

  export type YearTableMaxAggregateInputType = {
    id?: true
    name?: true
    year?: true
    universityId?: true
    branchId?: true
  }

  export type YearTableCountAggregateInputType = {
    id?: true
    name?: true
    year?: true
    universityId?: true
    branchId?: true
    _all?: true
  }

  export type YearTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearTable to aggregate.
     */
    where?: YearTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearTables to fetch.
     */
    orderBy?: YearTableOrderByWithRelationInput | YearTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YearTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YearTables
    **/
    _count?: true | YearTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YearTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YearTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YearTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YearTableMaxAggregateInputType
  }

  export type GetYearTableAggregateType<T extends YearTableAggregateArgs> = {
        [P in keyof T & keyof AggregateYearTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYearTable[P]>
      : GetScalarType<T[P], AggregateYearTable[P]>
  }




  export type YearTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearTableWhereInput
    orderBy?: YearTableOrderByWithAggregationInput | YearTableOrderByWithAggregationInput[]
    by: YearTableScalarFieldEnum[] | YearTableScalarFieldEnum
    having?: YearTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YearTableCountAggregateInputType | true
    _avg?: YearTableAvgAggregateInputType
    _sum?: YearTableSumAggregateInputType
    _min?: YearTableMinAggregateInputType
    _max?: YearTableMaxAggregateInputType
  }

  export type YearTableGroupByOutputType = {
    id: number
    name: string
    year: number
    universityId: number
    branchId: number
    _count: YearTableCountAggregateOutputType | null
    _avg: YearTableAvgAggregateOutputType | null
    _sum: YearTableSumAggregateOutputType | null
    _min: YearTableMinAggregateOutputType | null
    _max: YearTableMaxAggregateOutputType | null
  }

  type GetYearTableGroupByPayload<T extends YearTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YearTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YearTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YearTableGroupByOutputType[P]>
            : GetScalarType<T[P], YearTableGroupByOutputType[P]>
        }
      >
    >


  export type YearTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    year?: boolean
    universityId?: boolean
    branchId?: boolean
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    students?: boolean | YearTable$studentsArgs<ExtArgs>
    tests?: boolean | YearTable$testsArgs<ExtArgs>
    notes?: boolean | YearTable$notesArgs<ExtArgs>
    _count?: boolean | YearTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearTable"]>

  export type YearTableSelectScalar = {
    id?: boolean
    name?: boolean
    year?: boolean
    universityId?: boolean
    branchId?: boolean
  }

  export type YearTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    students?: boolean | YearTable$studentsArgs<ExtArgs>
    tests?: boolean | YearTable$testsArgs<ExtArgs>
    notes?: boolean | YearTable$notesArgs<ExtArgs>
    _count?: boolean | YearTableCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $YearTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YearTable"
    objects: {
      university: Prisma.$UniversityTablePayload<ExtArgs>
      branch: Prisma.$BranchTablePayload<ExtArgs>
      students: Prisma.$StudentTablePayload<ExtArgs>[]
      tests: Prisma.$TestTablePayload<ExtArgs>[]
      notes: Prisma.$NotesTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      year: number
      universityId: number
      branchId: number
    }, ExtArgs["result"]["yearTable"]>
    composites: {}
  }


  type YearTableGetPayload<S extends boolean | null | undefined | YearTableDefaultArgs> = $Result.GetResult<Prisma.$YearTablePayload, S>

  type YearTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<YearTableFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: YearTableCountAggregateInputType | true
    }

  export interface YearTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YearTable'], meta: { name: 'YearTable' } }
    /**
     * Find zero or one YearTable that matches the filter.
     * @param {YearTableFindUniqueArgs} args - Arguments to find a YearTable
     * @example
     * // Get one YearTable
     * const yearTable = await prisma.yearTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YearTableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, YearTableFindUniqueArgs<ExtArgs>>
    ): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one YearTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YearTableFindUniqueOrThrowArgs} args - Arguments to find a YearTable
     * @example
     * // Get one YearTable
     * const yearTable = await prisma.yearTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YearTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, YearTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first YearTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableFindFirstArgs} args - Arguments to find a YearTable
     * @example
     * // Get one YearTable
     * const yearTable = await prisma.yearTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YearTableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, YearTableFindFirstArgs<ExtArgs>>
    ): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first YearTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableFindFirstOrThrowArgs} args - Arguments to find a YearTable
     * @example
     * // Get one YearTable
     * const yearTable = await prisma.yearTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YearTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, YearTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more YearTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YearTables
     * const yearTables = await prisma.yearTable.findMany()
     * 
     * // Get first 10 YearTables
     * const yearTables = await prisma.yearTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yearTableWithIdOnly = await prisma.yearTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YearTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, YearTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a YearTable.
     * @param {YearTableCreateArgs} args - Arguments to create a YearTable.
     * @example
     * // Create one YearTable
     * const YearTable = await prisma.yearTable.create({
     *   data: {
     *     // ... data to create a YearTable
     *   }
     * })
     * 
    **/
    create<T extends YearTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, YearTableCreateArgs<ExtArgs>>
    ): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many YearTables.
     *     @param {YearTableCreateManyArgs} args - Arguments to create many YearTables.
     *     @example
     *     // Create many YearTables
     *     const yearTable = await prisma.yearTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YearTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, YearTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YearTable.
     * @param {YearTableDeleteArgs} args - Arguments to delete one YearTable.
     * @example
     * // Delete one YearTable
     * const YearTable = await prisma.yearTable.delete({
     *   where: {
     *     // ... filter to delete one YearTable
     *   }
     * })
     * 
    **/
    delete<T extends YearTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, YearTableDeleteArgs<ExtArgs>>
    ): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one YearTable.
     * @param {YearTableUpdateArgs} args - Arguments to update one YearTable.
     * @example
     * // Update one YearTable
     * const yearTable = await prisma.yearTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YearTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, YearTableUpdateArgs<ExtArgs>>
    ): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more YearTables.
     * @param {YearTableDeleteManyArgs} args - Arguments to filter YearTables to delete.
     * @example
     * // Delete a few YearTables
     * const { count } = await prisma.yearTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YearTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, YearTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YearTables
     * const yearTable = await prisma.yearTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YearTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, YearTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YearTable.
     * @param {YearTableUpsertArgs} args - Arguments to update or create a YearTable.
     * @example
     * // Update or create a YearTable
     * const yearTable = await prisma.yearTable.upsert({
     *   create: {
     *     // ... data to create a YearTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YearTable we want to update
     *   }
     * })
    **/
    upsert<T extends YearTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, YearTableUpsertArgs<ExtArgs>>
    ): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of YearTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableCountArgs} args - Arguments to filter YearTables to count.
     * @example
     * // Count the number of YearTables
     * const count = await prisma.yearTable.count({
     *   where: {
     *     // ... the filter for the YearTables we want to count
     *   }
     * })
    **/
    count<T extends YearTableCountArgs>(
      args?: Subset<T, YearTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YearTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YearTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YearTableAggregateArgs>(args: Subset<T, YearTableAggregateArgs>): Prisma.PrismaPromise<GetYearTableAggregateType<T>>

    /**
     * Group by YearTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YearTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearTableGroupByArgs['orderBy'] }
        : { orderBy?: YearTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YearTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYearTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YearTable model
   */
  readonly fields: YearTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YearTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YearTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    university<T extends UniversityTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTableDefaultArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    branch<T extends BranchTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchTableDefaultArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    students<T extends YearTable$studentsArgs<ExtArgs> = {}>(args?: Subset<T, YearTable$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    tests<T extends YearTable$testsArgs<ExtArgs> = {}>(args?: Subset<T, YearTable$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends YearTable$notesArgs<ExtArgs> = {}>(args?: Subset<T, YearTable$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the YearTable model
   */ 
  interface YearTableFieldRefs {
    readonly id: FieldRef<"YearTable", 'Int'>
    readonly name: FieldRef<"YearTable", 'String'>
    readonly year: FieldRef<"YearTable", 'Int'>
    readonly universityId: FieldRef<"YearTable", 'Int'>
    readonly branchId: FieldRef<"YearTable", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * YearTable findUnique
   */
  export type YearTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter, which YearTable to fetch.
     */
    where: YearTableWhereUniqueInput
  }


  /**
   * YearTable findUniqueOrThrow
   */
  export type YearTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter, which YearTable to fetch.
     */
    where: YearTableWhereUniqueInput
  }


  /**
   * YearTable findFirst
   */
  export type YearTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter, which YearTable to fetch.
     */
    where?: YearTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearTables to fetch.
     */
    orderBy?: YearTableOrderByWithRelationInput | YearTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearTables.
     */
    cursor?: YearTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearTables.
     */
    distinct?: YearTableScalarFieldEnum | YearTableScalarFieldEnum[]
  }


  /**
   * YearTable findFirstOrThrow
   */
  export type YearTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter, which YearTable to fetch.
     */
    where?: YearTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearTables to fetch.
     */
    orderBy?: YearTableOrderByWithRelationInput | YearTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearTables.
     */
    cursor?: YearTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearTables.
     */
    distinct?: YearTableScalarFieldEnum | YearTableScalarFieldEnum[]
  }


  /**
   * YearTable findMany
   */
  export type YearTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter, which YearTables to fetch.
     */
    where?: YearTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearTables to fetch.
     */
    orderBy?: YearTableOrderByWithRelationInput | YearTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YearTables.
     */
    cursor?: YearTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearTables.
     */
    skip?: number
    distinct?: YearTableScalarFieldEnum | YearTableScalarFieldEnum[]
  }


  /**
   * YearTable create
   */
  export type YearTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * The data needed to create a YearTable.
     */
    data: XOR<YearTableCreateInput, YearTableUncheckedCreateInput>
  }


  /**
   * YearTable createMany
   */
  export type YearTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YearTables.
     */
    data: YearTableCreateManyInput | YearTableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * YearTable update
   */
  export type YearTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * The data needed to update a YearTable.
     */
    data: XOR<YearTableUpdateInput, YearTableUncheckedUpdateInput>
    /**
     * Choose, which YearTable to update.
     */
    where: YearTableWhereUniqueInput
  }


  /**
   * YearTable updateMany
   */
  export type YearTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YearTables.
     */
    data: XOR<YearTableUpdateManyMutationInput, YearTableUncheckedUpdateManyInput>
    /**
     * Filter which YearTables to update
     */
    where?: YearTableWhereInput
  }


  /**
   * YearTable upsert
   */
  export type YearTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * The filter to search for the YearTable to update in case it exists.
     */
    where: YearTableWhereUniqueInput
    /**
     * In case the YearTable found by the `where` argument doesn't exist, create a new YearTable with this data.
     */
    create: XOR<YearTableCreateInput, YearTableUncheckedCreateInput>
    /**
     * In case the YearTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YearTableUpdateInput, YearTableUncheckedUpdateInput>
  }


  /**
   * YearTable delete
   */
  export type YearTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter which YearTable to delete.
     */
    where: YearTableWhereUniqueInput
  }


  /**
   * YearTable deleteMany
   */
  export type YearTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearTables to delete
     */
    where?: YearTableWhereInput
  }


  /**
   * YearTable.students
   */
  export type YearTable$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    where?: StudentTableWhereInput
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    cursor?: StudentTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }


  /**
   * YearTable.tests
   */
  export type YearTable$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    where?: TestTableWhereInput
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    cursor?: TestTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }


  /**
   * YearTable.notes
   */
  export type YearTable$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    where?: NotesTableWhereInput
    orderBy?: NotesTableOrderByWithRelationInput | NotesTableOrderByWithRelationInput[]
    cursor?: NotesTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesTableScalarFieldEnum | NotesTableScalarFieldEnum[]
  }


  /**
   * YearTable without action
   */
  export type YearTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YearTableInclude<ExtArgs> | null
  }



  /**
   * Model StudentTable
   */

  export type AggregateStudentTable = {
    _count: StudentTableCountAggregateOutputType | null
    _avg: StudentTableAvgAggregateOutputType | null
    _sum: StudentTableSumAggregateOutputType | null
    _min: StudentTableMinAggregateOutputType | null
    _max: StudentTableMaxAggregateOutputType | null
  }

  export type StudentTableAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    universityId: number | null
    yearId: number | null
  }

  export type StudentTableSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    universityId: number | null
    yearId: number | null
  }

  export type StudentTableMinAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    PRN: string | null
    branchId: number | null
    universityId: number | null
    yearId: number | null
  }

  export type StudentTableMaxAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    PRN: string | null
    branchId: number | null
    universityId: number | null
    yearId: number | null
  }

  export type StudentTableCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    email: number
    password: number
    PRN: number
    branchId: number
    universityId: number
    yearId: number
    _all: number
  }


  export type StudentTableAvgAggregateInputType = {
    id?: true
    branchId?: true
    universityId?: true
    yearId?: true
  }

  export type StudentTableSumAggregateInputType = {
    id?: true
    branchId?: true
    universityId?: true
    yearId?: true
  }

  export type StudentTableMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    PRN?: true
    branchId?: true
    universityId?: true
    yearId?: true
  }

  export type StudentTableMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    PRN?: true
    branchId?: true
    universityId?: true
    yearId?: true
  }

  export type StudentTableCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    PRN?: true
    branchId?: true
    universityId?: true
    yearId?: true
    _all?: true
  }

  export type StudentTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTable to aggregate.
     */
    where?: StudentTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTables to fetch.
     */
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentTables
    **/
    _count?: true | StudentTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentTableMaxAggregateInputType
  }

  export type GetStudentTableAggregateType<T extends StudentTableAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentTable[P]>
      : GetScalarType<T[P], AggregateStudentTable[P]>
  }




  export type StudentTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTableWhereInput
    orderBy?: StudentTableOrderByWithAggregationInput | StudentTableOrderByWithAggregationInput[]
    by: StudentTableScalarFieldEnum[] | StudentTableScalarFieldEnum
    having?: StudentTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentTableCountAggregateInputType | true
    _avg?: StudentTableAvgAggregateInputType
    _sum?: StudentTableSumAggregateInputType
    _min?: StudentTableMinAggregateInputType
    _max?: StudentTableMaxAggregateInputType
  }

  export type StudentTableGroupByOutputType = {
    id: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
    yearId: number
    _count: StudentTableCountAggregateOutputType | null
    _avg: StudentTableAvgAggregateOutputType | null
    _sum: StudentTableSumAggregateOutputType | null
    _min: StudentTableMinAggregateOutputType | null
    _max: StudentTableMaxAggregateOutputType | null
  }

  type GetStudentTableGroupByPayload<T extends StudentTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentTableGroupByOutputType[P]>
            : GetScalarType<T[P], StudentTableGroupByOutputType[P]>
        }
      >
    >


  export type StudentTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    PRN?: boolean
    branchId?: boolean
    universityId?: boolean
    yearId?: boolean
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
    results?: boolean | StudentTable$resultsArgs<ExtArgs>
    responses?: boolean | StudentTable$responsesArgs<ExtArgs>
    _count?: boolean | StudentTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTable"]>

  export type StudentTableSelectScalar = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    PRN?: boolean
    branchId?: boolean
    universityId?: boolean
    yearId?: boolean
  }

  export type StudentTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
    results?: boolean | StudentTable$resultsArgs<ExtArgs>
    responses?: boolean | StudentTable$responsesArgs<ExtArgs>
    _count?: boolean | StudentTableCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StudentTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentTable"
    objects: {
      branch: Prisma.$BranchTablePayload<ExtArgs>
      university: Prisma.$UniversityTablePayload<ExtArgs>
      year: Prisma.$YearTablePayload<ExtArgs>
      results: Prisma.$ResultTablePayload<ExtArgs>[]
      responses: Prisma.$StudentResponseTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstname: string
      lastname: string
      email: string
      password: string
      PRN: string
      branchId: number
      universityId: number
      yearId: number
    }, ExtArgs["result"]["studentTable"]>
    composites: {}
  }


  type StudentTableGetPayload<S extends boolean | null | undefined | StudentTableDefaultArgs> = $Result.GetResult<Prisma.$StudentTablePayload, S>

  type StudentTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentTableFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StudentTableCountAggregateInputType | true
    }

  export interface StudentTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentTable'], meta: { name: 'StudentTable' } }
    /**
     * Find zero or one StudentTable that matches the filter.
     * @param {StudentTableFindUniqueArgs} args - Arguments to find a StudentTable
     * @example
     * // Get one StudentTable
     * const studentTable = await prisma.studentTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentTableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentTableFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentTableFindUniqueOrThrowArgs} args - Arguments to find a StudentTable
     * @example
     * // Get one StudentTable
     * const studentTable = await prisma.studentTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableFindFirstArgs} args - Arguments to find a StudentTable
     * @example
     * // Get one StudentTable
     * const studentTable = await prisma.studentTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentTableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentTableFindFirstArgs<ExtArgs>>
    ): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableFindFirstOrThrowArgs} args - Arguments to find a StudentTable
     * @example
     * // Get one StudentTable
     * const studentTable = await prisma.studentTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentTables
     * const studentTables = await prisma.studentTable.findMany()
     * 
     * // Get first 10 StudentTables
     * const studentTables = await prisma.studentTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentTableWithIdOnly = await prisma.studentTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentTable.
     * @param {StudentTableCreateArgs} args - Arguments to create a StudentTable.
     * @example
     * // Create one StudentTable
     * const StudentTable = await prisma.studentTable.create({
     *   data: {
     *     // ... data to create a StudentTable
     *   }
     * })
     * 
    **/
    create<T extends StudentTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentTableCreateArgs<ExtArgs>>
    ): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentTables.
     *     @param {StudentTableCreateManyArgs} args - Arguments to create many StudentTables.
     *     @example
     *     // Create many StudentTables
     *     const studentTable = await prisma.studentTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentTable.
     * @param {StudentTableDeleteArgs} args - Arguments to delete one StudentTable.
     * @example
     * // Delete one StudentTable
     * const StudentTable = await prisma.studentTable.delete({
     *   where: {
     *     // ... filter to delete one StudentTable
     *   }
     * })
     * 
    **/
    delete<T extends StudentTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentTableDeleteArgs<ExtArgs>>
    ): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentTable.
     * @param {StudentTableUpdateArgs} args - Arguments to update one StudentTable.
     * @example
     * // Update one StudentTable
     * const studentTable = await prisma.studentTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentTableUpdateArgs<ExtArgs>>
    ): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentTables.
     * @param {StudentTableDeleteManyArgs} args - Arguments to filter StudentTables to delete.
     * @example
     * // Delete a few StudentTables
     * const { count } = await prisma.studentTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentTables
     * const studentTable = await prisma.studentTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentTable.
     * @param {StudentTableUpsertArgs} args - Arguments to update or create a StudentTable.
     * @example
     * // Update or create a StudentTable
     * const studentTable = await prisma.studentTable.upsert({
     *   create: {
     *     // ... data to create a StudentTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentTable we want to update
     *   }
     * })
    **/
    upsert<T extends StudentTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentTableUpsertArgs<ExtArgs>>
    ): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableCountArgs} args - Arguments to filter StudentTables to count.
     * @example
     * // Count the number of StudentTables
     * const count = await prisma.studentTable.count({
     *   where: {
     *     // ... the filter for the StudentTables we want to count
     *   }
     * })
    **/
    count<T extends StudentTableCountArgs>(
      args?: Subset<T, StudentTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentTableAggregateArgs>(args: Subset<T, StudentTableAggregateArgs>): Prisma.PrismaPromise<GetStudentTableAggregateType<T>>

    /**
     * Group by StudentTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentTableGroupByArgs['orderBy'] }
        : { orderBy?: StudentTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentTable model
   */
  readonly fields: StudentTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    branch<T extends BranchTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchTableDefaultArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    university<T extends UniversityTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTableDefaultArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    year<T extends YearTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearTableDefaultArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    results<T extends StudentTable$resultsArgs<ExtArgs> = {}>(args?: Subset<T, StudentTable$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    responses<T extends StudentTable$responsesArgs<ExtArgs> = {}>(args?: Subset<T, StudentTable$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentTable model
   */ 
  interface StudentTableFieldRefs {
    readonly id: FieldRef<"StudentTable", 'Int'>
    readonly firstname: FieldRef<"StudentTable", 'String'>
    readonly lastname: FieldRef<"StudentTable", 'String'>
    readonly email: FieldRef<"StudentTable", 'String'>
    readonly password: FieldRef<"StudentTable", 'String'>
    readonly PRN: FieldRef<"StudentTable", 'String'>
    readonly branchId: FieldRef<"StudentTable", 'Int'>
    readonly universityId: FieldRef<"StudentTable", 'Int'>
    readonly yearId: FieldRef<"StudentTable", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * StudentTable findUnique
   */
  export type StudentTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentTable to fetch.
     */
    where: StudentTableWhereUniqueInput
  }


  /**
   * StudentTable findUniqueOrThrow
   */
  export type StudentTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentTable to fetch.
     */
    where: StudentTableWhereUniqueInput
  }


  /**
   * StudentTable findFirst
   */
  export type StudentTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentTable to fetch.
     */
    where?: StudentTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTables to fetch.
     */
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTables.
     */
    cursor?: StudentTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTables.
     */
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }


  /**
   * StudentTable findFirstOrThrow
   */
  export type StudentTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentTable to fetch.
     */
    where?: StudentTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTables to fetch.
     */
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTables.
     */
    cursor?: StudentTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTables.
     */
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }


  /**
   * StudentTable findMany
   */
  export type StudentTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentTables to fetch.
     */
    where?: StudentTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTables to fetch.
     */
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentTables.
     */
    cursor?: StudentTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTables.
     */
    skip?: number
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }


  /**
   * StudentTable create
   */
  export type StudentTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentTable.
     */
    data: XOR<StudentTableCreateInput, StudentTableUncheckedCreateInput>
  }


  /**
   * StudentTable createMany
   */
  export type StudentTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentTables.
     */
    data: StudentTableCreateManyInput | StudentTableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentTable update
   */
  export type StudentTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentTable.
     */
    data: XOR<StudentTableUpdateInput, StudentTableUncheckedUpdateInput>
    /**
     * Choose, which StudentTable to update.
     */
    where: StudentTableWhereUniqueInput
  }


  /**
   * StudentTable updateMany
   */
  export type StudentTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentTables.
     */
    data: XOR<StudentTableUpdateManyMutationInput, StudentTableUncheckedUpdateManyInput>
    /**
     * Filter which StudentTables to update
     */
    where?: StudentTableWhereInput
  }


  /**
   * StudentTable upsert
   */
  export type StudentTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentTable to update in case it exists.
     */
    where: StudentTableWhereUniqueInput
    /**
     * In case the StudentTable found by the `where` argument doesn't exist, create a new StudentTable with this data.
     */
    create: XOR<StudentTableCreateInput, StudentTableUncheckedCreateInput>
    /**
     * In case the StudentTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentTableUpdateInput, StudentTableUncheckedUpdateInput>
  }


  /**
   * StudentTable delete
   */
  export type StudentTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter which StudentTable to delete.
     */
    where: StudentTableWhereUniqueInput
  }


  /**
   * StudentTable deleteMany
   */
  export type StudentTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTables to delete
     */
    where?: StudentTableWhereInput
  }


  /**
   * StudentTable.results
   */
  export type StudentTable$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
    where?: ResultTableWhereInput
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    cursor?: ResultTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultTableScalarFieldEnum | ResultTableScalarFieldEnum[]
  }


  /**
   * StudentTable.responses
   */
  export type StudentTable$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    where?: StudentResponseTableWhereInput
    orderBy?: StudentResponseTableOrderByWithRelationInput | StudentResponseTableOrderByWithRelationInput[]
    cursor?: StudentResponseTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentResponseTableScalarFieldEnum | StudentResponseTableScalarFieldEnum[]
  }


  /**
   * StudentTable without action
   */
  export type StudentTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentTableInclude<ExtArgs> | null
  }



  /**
   * Model TeacherTable
   */

  export type AggregateTeacherTable = {
    _count: TeacherTableCountAggregateOutputType | null
    _avg: TeacherTableAvgAggregateOutputType | null
    _sum: TeacherTableSumAggregateOutputType | null
    _min: TeacherTableMinAggregateOutputType | null
    _max: TeacherTableMaxAggregateOutputType | null
  }

  export type TeacherTableAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    universityId: number | null
  }

  export type TeacherTableSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    universityId: number | null
  }

  export type TeacherTableMinAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    branchId: number | null
    universityId: number | null
  }

  export type TeacherTableMaxAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    branchId: number | null
    universityId: number | null
  }

  export type TeacherTableCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    email: number
    password: number
    branchId: number
    universityId: number
    _all: number
  }


  export type TeacherTableAvgAggregateInputType = {
    id?: true
    branchId?: true
    universityId?: true
  }

  export type TeacherTableSumAggregateInputType = {
    id?: true
    branchId?: true
    universityId?: true
  }

  export type TeacherTableMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    branchId?: true
    universityId?: true
  }

  export type TeacherTableMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    branchId?: true
    universityId?: true
  }

  export type TeacherTableCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    branchId?: true
    universityId?: true
    _all?: true
  }

  export type TeacherTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherTable to aggregate.
     */
    where?: TeacherTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherTables to fetch.
     */
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherTables
    **/
    _count?: true | TeacherTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherTableMaxAggregateInputType
  }

  export type GetTeacherTableAggregateType<T extends TeacherTableAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherTable[P]>
      : GetScalarType<T[P], AggregateTeacherTable[P]>
  }




  export type TeacherTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherTableWhereInput
    orderBy?: TeacherTableOrderByWithAggregationInput | TeacherTableOrderByWithAggregationInput[]
    by: TeacherTableScalarFieldEnum[] | TeacherTableScalarFieldEnum
    having?: TeacherTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherTableCountAggregateInputType | true
    _avg?: TeacherTableAvgAggregateInputType
    _sum?: TeacherTableSumAggregateInputType
    _min?: TeacherTableMinAggregateInputType
    _max?: TeacherTableMaxAggregateInputType
  }

  export type TeacherTableGroupByOutputType = {
    id: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
    universityId: number
    _count: TeacherTableCountAggregateOutputType | null
    _avg: TeacherTableAvgAggregateOutputType | null
    _sum: TeacherTableSumAggregateOutputType | null
    _min: TeacherTableMinAggregateOutputType | null
    _max: TeacherTableMaxAggregateOutputType | null
  }

  type GetTeacherTableGroupByPayload<T extends TeacherTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherTableGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherTableGroupByOutputType[P]>
        }
      >
    >


  export type TeacherTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    branchId?: boolean
    universityId?: boolean
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    tests?: boolean | TeacherTable$testsArgs<ExtArgs>
    notes?: boolean | TeacherTable$notesArgs<ExtArgs>
    _count?: boolean | TeacherTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherTable"]>

  export type TeacherTableSelectScalar = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    branchId?: boolean
    universityId?: boolean
  }

  export type TeacherTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    tests?: boolean | TeacherTable$testsArgs<ExtArgs>
    notes?: boolean | TeacherTable$notesArgs<ExtArgs>
    _count?: boolean | TeacherTableCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TeacherTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherTable"
    objects: {
      branch: Prisma.$BranchTablePayload<ExtArgs>
      university: Prisma.$UniversityTablePayload<ExtArgs>
      tests: Prisma.$TestTablePayload<ExtArgs>[]
      notes: Prisma.$NotesTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstname: string
      lastname: string
      email: string
      password: string
      branchId: number
      universityId: number
    }, ExtArgs["result"]["teacherTable"]>
    composites: {}
  }


  type TeacherTableGetPayload<S extends boolean | null | undefined | TeacherTableDefaultArgs> = $Result.GetResult<Prisma.$TeacherTablePayload, S>

  type TeacherTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherTableFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TeacherTableCountAggregateInputType | true
    }

  export interface TeacherTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherTable'], meta: { name: 'TeacherTable' } }
    /**
     * Find zero or one TeacherTable that matches the filter.
     * @param {TeacherTableFindUniqueArgs} args - Arguments to find a TeacherTable
     * @example
     * // Get one TeacherTable
     * const teacherTable = await prisma.teacherTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherTableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherTableFindUniqueArgs<ExtArgs>>
    ): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TeacherTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherTableFindUniqueOrThrowArgs} args - Arguments to find a TeacherTable
     * @example
     * // Get one TeacherTable
     * const teacherTable = await prisma.teacherTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TeacherTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableFindFirstArgs} args - Arguments to find a TeacherTable
     * @example
     * // Get one TeacherTable
     * const teacherTable = await prisma.teacherTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherTableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherTableFindFirstArgs<ExtArgs>>
    ): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TeacherTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableFindFirstOrThrowArgs} args - Arguments to find a TeacherTable
     * @example
     * // Get one TeacherTable
     * const teacherTable = await prisma.teacherTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TeacherTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherTables
     * const teacherTables = await prisma.teacherTable.findMany()
     * 
     * // Get first 10 TeacherTables
     * const teacherTables = await prisma.teacherTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherTableWithIdOnly = await prisma.teacherTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeacherTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TeacherTable.
     * @param {TeacherTableCreateArgs} args - Arguments to create a TeacherTable.
     * @example
     * // Create one TeacherTable
     * const TeacherTable = await prisma.teacherTable.create({
     *   data: {
     *     // ... data to create a TeacherTable
     *   }
     * })
     * 
    **/
    create<T extends TeacherTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherTableCreateArgs<ExtArgs>>
    ): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TeacherTables.
     *     @param {TeacherTableCreateManyArgs} args - Arguments to create many TeacherTables.
     *     @example
     *     // Create many TeacherTables
     *     const teacherTable = await prisma.teacherTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeacherTable.
     * @param {TeacherTableDeleteArgs} args - Arguments to delete one TeacherTable.
     * @example
     * // Delete one TeacherTable
     * const TeacherTable = await prisma.teacherTable.delete({
     *   where: {
     *     // ... filter to delete one TeacherTable
     *   }
     * })
     * 
    **/
    delete<T extends TeacherTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherTableDeleteArgs<ExtArgs>>
    ): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TeacherTable.
     * @param {TeacherTableUpdateArgs} args - Arguments to update one TeacherTable.
     * @example
     * // Update one TeacherTable
     * const teacherTable = await prisma.teacherTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherTableUpdateArgs<ExtArgs>>
    ): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TeacherTables.
     * @param {TeacherTableDeleteManyArgs} args - Arguments to filter TeacherTables to delete.
     * @example
     * // Delete a few TeacherTables
     * const { count } = await prisma.teacherTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherTables
     * const teacherTable = await prisma.teacherTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherTable.
     * @param {TeacherTableUpsertArgs} args - Arguments to update or create a TeacherTable.
     * @example
     * // Update or create a TeacherTable
     * const teacherTable = await prisma.teacherTable.upsert({
     *   create: {
     *     // ... data to create a TeacherTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherTable we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherTableUpsertArgs<ExtArgs>>
    ): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TeacherTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableCountArgs} args - Arguments to filter TeacherTables to count.
     * @example
     * // Count the number of TeacherTables
     * const count = await prisma.teacherTable.count({
     *   where: {
     *     // ... the filter for the TeacherTables we want to count
     *   }
     * })
    **/
    count<T extends TeacherTableCountArgs>(
      args?: Subset<T, TeacherTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherTableAggregateArgs>(args: Subset<T, TeacherTableAggregateArgs>): Prisma.PrismaPromise<GetTeacherTableAggregateType<T>>

    /**
     * Group by TeacherTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherTableGroupByArgs['orderBy'] }
        : { orderBy?: TeacherTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherTable model
   */
  readonly fields: TeacherTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    branch<T extends BranchTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchTableDefaultArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    university<T extends UniversityTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTableDefaultArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tests<T extends TeacherTable$testsArgs<ExtArgs> = {}>(args?: Subset<T, TeacherTable$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends TeacherTable$notesArgs<ExtArgs> = {}>(args?: Subset<T, TeacherTable$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TeacherTable model
   */ 
  interface TeacherTableFieldRefs {
    readonly id: FieldRef<"TeacherTable", 'Int'>
    readonly firstname: FieldRef<"TeacherTable", 'String'>
    readonly lastname: FieldRef<"TeacherTable", 'String'>
    readonly email: FieldRef<"TeacherTable", 'String'>
    readonly password: FieldRef<"TeacherTable", 'String'>
    readonly branchId: FieldRef<"TeacherTable", 'Int'>
    readonly universityId: FieldRef<"TeacherTable", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * TeacherTable findUnique
   */
  export type TeacherTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter, which TeacherTable to fetch.
     */
    where: TeacherTableWhereUniqueInput
  }


  /**
   * TeacherTable findUniqueOrThrow
   */
  export type TeacherTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter, which TeacherTable to fetch.
     */
    where: TeacherTableWhereUniqueInput
  }


  /**
   * TeacherTable findFirst
   */
  export type TeacherTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter, which TeacherTable to fetch.
     */
    where?: TeacherTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherTables to fetch.
     */
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherTables.
     */
    cursor?: TeacherTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherTables.
     */
    distinct?: TeacherTableScalarFieldEnum | TeacherTableScalarFieldEnum[]
  }


  /**
   * TeacherTable findFirstOrThrow
   */
  export type TeacherTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter, which TeacherTable to fetch.
     */
    where?: TeacherTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherTables to fetch.
     */
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherTables.
     */
    cursor?: TeacherTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherTables.
     */
    distinct?: TeacherTableScalarFieldEnum | TeacherTableScalarFieldEnum[]
  }


  /**
   * TeacherTable findMany
   */
  export type TeacherTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter, which TeacherTables to fetch.
     */
    where?: TeacherTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherTables to fetch.
     */
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherTables.
     */
    cursor?: TeacherTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherTables.
     */
    skip?: number
    distinct?: TeacherTableScalarFieldEnum | TeacherTableScalarFieldEnum[]
  }


  /**
   * TeacherTable create
   */
  export type TeacherTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherTable.
     */
    data: XOR<TeacherTableCreateInput, TeacherTableUncheckedCreateInput>
  }


  /**
   * TeacherTable createMany
   */
  export type TeacherTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherTables.
     */
    data: TeacherTableCreateManyInput | TeacherTableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TeacherTable update
   */
  export type TeacherTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherTable.
     */
    data: XOR<TeacherTableUpdateInput, TeacherTableUncheckedUpdateInput>
    /**
     * Choose, which TeacherTable to update.
     */
    where: TeacherTableWhereUniqueInput
  }


  /**
   * TeacherTable updateMany
   */
  export type TeacherTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherTables.
     */
    data: XOR<TeacherTableUpdateManyMutationInput, TeacherTableUncheckedUpdateManyInput>
    /**
     * Filter which TeacherTables to update
     */
    where?: TeacherTableWhereInput
  }


  /**
   * TeacherTable upsert
   */
  export type TeacherTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherTable to update in case it exists.
     */
    where: TeacherTableWhereUniqueInput
    /**
     * In case the TeacherTable found by the `where` argument doesn't exist, create a new TeacherTable with this data.
     */
    create: XOR<TeacherTableCreateInput, TeacherTableUncheckedCreateInput>
    /**
     * In case the TeacherTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherTableUpdateInput, TeacherTableUncheckedUpdateInput>
  }


  /**
   * TeacherTable delete
   */
  export type TeacherTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter which TeacherTable to delete.
     */
    where: TeacherTableWhereUniqueInput
  }


  /**
   * TeacherTable deleteMany
   */
  export type TeacherTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherTables to delete
     */
    where?: TeacherTableWhereInput
  }


  /**
   * TeacherTable.tests
   */
  export type TeacherTable$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    where?: TestTableWhereInput
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    cursor?: TestTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }


  /**
   * TeacherTable.notes
   */
  export type TeacherTable$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    where?: NotesTableWhereInput
    orderBy?: NotesTableOrderByWithRelationInput | NotesTableOrderByWithRelationInput[]
    cursor?: NotesTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesTableScalarFieldEnum | NotesTableScalarFieldEnum[]
  }


  /**
   * TeacherTable without action
   */
  export type TeacherTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherTableInclude<ExtArgs> | null
  }



  /**
   * Model TestTable
   */

  export type AggregateTestTable = {
    _count: TestTableCountAggregateOutputType | null
    _avg: TestTableAvgAggregateOutputType | null
    _sum: TestTableSumAggregateOutputType | null
    _min: TestTableMinAggregateOutputType | null
    _max: TestTableMaxAggregateOutputType | null
  }

  export type TestTableAvgAggregateOutputType = {
    id: number | null
    teacherID: number | null
    branchId: number | null
    yearId: number | null
    totalmarks: number | null
    duration: number | null
  }

  export type TestTableSumAggregateOutputType = {
    id: number | null
    teacherID: number | null
    branchId: number | null
    yearId: number | null
    totalmarks: number | null
    duration: number | null
  }

  export type TestTableMinAggregateOutputType = {
    id: number | null
    title: string | null
    teacherID: number | null
    branchId: number | null
    subject: string | null
    yearId: number | null
    totalmarks: number | null
    duration: number | null
    scheduledDate: Date | null
  }

  export type TestTableMaxAggregateOutputType = {
    id: number | null
    title: string | null
    teacherID: number | null
    branchId: number | null
    subject: string | null
    yearId: number | null
    totalmarks: number | null
    duration: number | null
    scheduledDate: Date | null
  }

  export type TestTableCountAggregateOutputType = {
    id: number
    title: number
    teacherID: number
    branchId: number
    subject: number
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: number
    _all: number
  }


  export type TestTableAvgAggregateInputType = {
    id?: true
    teacherID?: true
    branchId?: true
    yearId?: true
    totalmarks?: true
    duration?: true
  }

  export type TestTableSumAggregateInputType = {
    id?: true
    teacherID?: true
    branchId?: true
    yearId?: true
    totalmarks?: true
    duration?: true
  }

  export type TestTableMinAggregateInputType = {
    id?: true
    title?: true
    teacherID?: true
    branchId?: true
    subject?: true
    yearId?: true
    totalmarks?: true
    duration?: true
    scheduledDate?: true
  }

  export type TestTableMaxAggregateInputType = {
    id?: true
    title?: true
    teacherID?: true
    branchId?: true
    subject?: true
    yearId?: true
    totalmarks?: true
    duration?: true
    scheduledDate?: true
  }

  export type TestTableCountAggregateInputType = {
    id?: true
    title?: true
    teacherID?: true
    branchId?: true
    subject?: true
    yearId?: true
    totalmarks?: true
    duration?: true
    scheduledDate?: true
    _all?: true
  }

  export type TestTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestTable to aggregate.
     */
    where?: TestTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTables to fetch.
     */
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestTables
    **/
    _count?: true | TestTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestTableMaxAggregateInputType
  }

  export type GetTestTableAggregateType<T extends TestTableAggregateArgs> = {
        [P in keyof T & keyof AggregateTestTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestTable[P]>
      : GetScalarType<T[P], AggregateTestTable[P]>
  }




  export type TestTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTableWhereInput
    orderBy?: TestTableOrderByWithAggregationInput | TestTableOrderByWithAggregationInput[]
    by: TestTableScalarFieldEnum[] | TestTableScalarFieldEnum
    having?: TestTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestTableCountAggregateInputType | true
    _avg?: TestTableAvgAggregateInputType
    _sum?: TestTableSumAggregateInputType
    _min?: TestTableMinAggregateInputType
    _max?: TestTableMaxAggregateInputType
  }

  export type TestTableGroupByOutputType = {
    id: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date
    _count: TestTableCountAggregateOutputType | null
    _avg: TestTableAvgAggregateOutputType | null
    _sum: TestTableSumAggregateOutputType | null
    _min: TestTableMinAggregateOutputType | null
    _max: TestTableMaxAggregateOutputType | null
  }

  type GetTestTableGroupByPayload<T extends TestTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestTableGroupByOutputType[P]>
            : GetScalarType<T[P], TestTableGroupByOutputType[P]>
        }
      >
    >


  export type TestTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    teacherID?: boolean
    branchId?: boolean
    subject?: boolean
    yearId?: boolean
    totalmarks?: boolean
    duration?: boolean
    scheduledDate?: boolean
    teacher?: boolean | TeacherTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
    questions?: boolean | TestTable$questionsArgs<ExtArgs>
    results?: boolean | TestTable$resultsArgs<ExtArgs>
    responses?: boolean | TestTable$responsesArgs<ExtArgs>
    _count?: boolean | TestTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testTable"]>

  export type TestTableSelectScalar = {
    id?: boolean
    title?: boolean
    teacherID?: boolean
    branchId?: boolean
    subject?: boolean
    yearId?: boolean
    totalmarks?: boolean
    duration?: boolean
    scheduledDate?: boolean
  }

  export type TestTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
    questions?: boolean | TestTable$questionsArgs<ExtArgs>
    results?: boolean | TestTable$resultsArgs<ExtArgs>
    responses?: boolean | TestTable$responsesArgs<ExtArgs>
    _count?: boolean | TestTableCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TestTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestTable"
    objects: {
      teacher: Prisma.$TeacherTablePayload<ExtArgs>
      branch: Prisma.$BranchTablePayload<ExtArgs>
      year: Prisma.$YearTablePayload<ExtArgs>
      questions: Prisma.$QuestionsTablePayload<ExtArgs>[]
      results: Prisma.$ResultTablePayload<ExtArgs>[]
      responses: Prisma.$StudentResponseTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      teacherID: number
      branchId: number
      subject: string
      yearId: number
      totalmarks: number
      duration: number
      scheduledDate: Date
    }, ExtArgs["result"]["testTable"]>
    composites: {}
  }


  type TestTableGetPayload<S extends boolean | null | undefined | TestTableDefaultArgs> = $Result.GetResult<Prisma.$TestTablePayload, S>

  type TestTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestTableFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TestTableCountAggregateInputType | true
    }

  export interface TestTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestTable'], meta: { name: 'TestTable' } }
    /**
     * Find zero or one TestTable that matches the filter.
     * @param {TestTableFindUniqueArgs} args - Arguments to find a TestTable
     * @example
     * // Get one TestTable
     * const testTable = await prisma.testTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TestTableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TestTableFindUniqueArgs<ExtArgs>>
    ): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TestTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TestTableFindUniqueOrThrowArgs} args - Arguments to find a TestTable
     * @example
     * // Get one TestTable
     * const testTable = await prisma.testTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TestTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TestTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TestTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableFindFirstArgs} args - Arguments to find a TestTable
     * @example
     * // Get one TestTable
     * const testTable = await prisma.testTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TestTableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TestTableFindFirstArgs<ExtArgs>>
    ): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TestTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableFindFirstOrThrowArgs} args - Arguments to find a TestTable
     * @example
     * // Get one TestTable
     * const testTable = await prisma.testTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TestTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TestTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TestTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestTables
     * const testTables = await prisma.testTable.findMany()
     * 
     * // Get first 10 TestTables
     * const testTables = await prisma.testTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testTableWithIdOnly = await prisma.testTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TestTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TestTable.
     * @param {TestTableCreateArgs} args - Arguments to create a TestTable.
     * @example
     * // Create one TestTable
     * const TestTable = await prisma.testTable.create({
     *   data: {
     *     // ... data to create a TestTable
     *   }
     * })
     * 
    **/
    create<T extends TestTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TestTableCreateArgs<ExtArgs>>
    ): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TestTables.
     *     @param {TestTableCreateManyArgs} args - Arguments to create many TestTables.
     *     @example
     *     // Create many TestTables
     *     const testTable = await prisma.testTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TestTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TestTable.
     * @param {TestTableDeleteArgs} args - Arguments to delete one TestTable.
     * @example
     * // Delete one TestTable
     * const TestTable = await prisma.testTable.delete({
     *   where: {
     *     // ... filter to delete one TestTable
     *   }
     * })
     * 
    **/
    delete<T extends TestTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TestTableDeleteArgs<ExtArgs>>
    ): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TestTable.
     * @param {TestTableUpdateArgs} args - Arguments to update one TestTable.
     * @example
     * // Update one TestTable
     * const testTable = await prisma.testTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TestTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TestTableUpdateArgs<ExtArgs>>
    ): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TestTables.
     * @param {TestTableDeleteManyArgs} args - Arguments to filter TestTables to delete.
     * @example
     * // Delete a few TestTables
     * const { count } = await prisma.testTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TestTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestTables
     * const testTable = await prisma.testTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TestTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TestTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestTable.
     * @param {TestTableUpsertArgs} args - Arguments to update or create a TestTable.
     * @example
     * // Update or create a TestTable
     * const testTable = await prisma.testTable.upsert({
     *   create: {
     *     // ... data to create a TestTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestTable we want to update
     *   }
     * })
    **/
    upsert<T extends TestTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TestTableUpsertArgs<ExtArgs>>
    ): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TestTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableCountArgs} args - Arguments to filter TestTables to count.
     * @example
     * // Count the number of TestTables
     * const count = await prisma.testTable.count({
     *   where: {
     *     // ... the filter for the TestTables we want to count
     *   }
     * })
    **/
    count<T extends TestTableCountArgs>(
      args?: Subset<T, TestTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestTableAggregateArgs>(args: Subset<T, TestTableAggregateArgs>): Prisma.PrismaPromise<GetTestTableAggregateType<T>>

    /**
     * Group by TestTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestTableGroupByArgs['orderBy'] }
        : { orderBy?: TestTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestTable model
   */
  readonly fields: TestTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    teacher<T extends TeacherTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherTableDefaultArgs<ExtArgs>>): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    branch<T extends BranchTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchTableDefaultArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    year<T extends YearTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearTableDefaultArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    questions<T extends TestTable$questionsArgs<ExtArgs> = {}>(args?: Subset<T, TestTable$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    results<T extends TestTable$resultsArgs<ExtArgs> = {}>(args?: Subset<T, TestTable$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    responses<T extends TestTable$responsesArgs<ExtArgs> = {}>(args?: Subset<T, TestTable$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TestTable model
   */ 
  interface TestTableFieldRefs {
    readonly id: FieldRef<"TestTable", 'Int'>
    readonly title: FieldRef<"TestTable", 'String'>
    readonly teacherID: FieldRef<"TestTable", 'Int'>
    readonly branchId: FieldRef<"TestTable", 'Int'>
    readonly subject: FieldRef<"TestTable", 'String'>
    readonly yearId: FieldRef<"TestTable", 'Int'>
    readonly totalmarks: FieldRef<"TestTable", 'Int'>
    readonly duration: FieldRef<"TestTable", 'Int'>
    readonly scheduledDate: FieldRef<"TestTable", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TestTable findUnique
   */
  export type TestTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter, which TestTable to fetch.
     */
    where: TestTableWhereUniqueInput
  }


  /**
   * TestTable findUniqueOrThrow
   */
  export type TestTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter, which TestTable to fetch.
     */
    where: TestTableWhereUniqueInput
  }


  /**
   * TestTable findFirst
   */
  export type TestTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter, which TestTable to fetch.
     */
    where?: TestTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTables to fetch.
     */
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestTables.
     */
    cursor?: TestTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestTables.
     */
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }


  /**
   * TestTable findFirstOrThrow
   */
  export type TestTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter, which TestTable to fetch.
     */
    where?: TestTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTables to fetch.
     */
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestTables.
     */
    cursor?: TestTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestTables.
     */
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }


  /**
   * TestTable findMany
   */
  export type TestTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter, which TestTables to fetch.
     */
    where?: TestTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTables to fetch.
     */
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestTables.
     */
    cursor?: TestTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTables.
     */
    skip?: number
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }


  /**
   * TestTable create
   */
  export type TestTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * The data needed to create a TestTable.
     */
    data: XOR<TestTableCreateInput, TestTableUncheckedCreateInput>
  }


  /**
   * TestTable createMany
   */
  export type TestTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestTables.
     */
    data: TestTableCreateManyInput | TestTableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TestTable update
   */
  export type TestTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * The data needed to update a TestTable.
     */
    data: XOR<TestTableUpdateInput, TestTableUncheckedUpdateInput>
    /**
     * Choose, which TestTable to update.
     */
    where: TestTableWhereUniqueInput
  }


  /**
   * TestTable updateMany
   */
  export type TestTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestTables.
     */
    data: XOR<TestTableUpdateManyMutationInput, TestTableUncheckedUpdateManyInput>
    /**
     * Filter which TestTables to update
     */
    where?: TestTableWhereInput
  }


  /**
   * TestTable upsert
   */
  export type TestTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * The filter to search for the TestTable to update in case it exists.
     */
    where: TestTableWhereUniqueInput
    /**
     * In case the TestTable found by the `where` argument doesn't exist, create a new TestTable with this data.
     */
    create: XOR<TestTableCreateInput, TestTableUncheckedCreateInput>
    /**
     * In case the TestTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestTableUpdateInput, TestTableUncheckedUpdateInput>
  }


  /**
   * TestTable delete
   */
  export type TestTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter which TestTable to delete.
     */
    where: TestTableWhereUniqueInput
  }


  /**
   * TestTable deleteMany
   */
  export type TestTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestTables to delete
     */
    where?: TestTableWhereInput
  }


  /**
   * TestTable.questions
   */
  export type TestTable$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    where?: QuestionsTableWhereInput
    orderBy?: QuestionsTableOrderByWithRelationInput | QuestionsTableOrderByWithRelationInput[]
    cursor?: QuestionsTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsTableScalarFieldEnum | QuestionsTableScalarFieldEnum[]
  }


  /**
   * TestTable.results
   */
  export type TestTable$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
    where?: ResultTableWhereInput
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    cursor?: ResultTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultTableScalarFieldEnum | ResultTableScalarFieldEnum[]
  }


  /**
   * TestTable.responses
   */
  export type TestTable$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    where?: StudentResponseTableWhereInput
    orderBy?: StudentResponseTableOrderByWithRelationInput | StudentResponseTableOrderByWithRelationInput[]
    cursor?: StudentResponseTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentResponseTableScalarFieldEnum | StudentResponseTableScalarFieldEnum[]
  }


  /**
   * TestTable without action
   */
  export type TestTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestTableInclude<ExtArgs> | null
  }



  /**
   * Model QuestionsTable
   */

  export type AggregateQuestionsTable = {
    _count: QuestionsTableCountAggregateOutputType | null
    _avg: QuestionsTableAvgAggregateOutputType | null
    _sum: QuestionsTableSumAggregateOutputType | null
    _min: QuestionsTableMinAggregateOutputType | null
    _max: QuestionsTableMaxAggregateOutputType | null
  }

  export type QuestionsTableAvgAggregateOutputType = {
    id: number | null
    maxMark: number | null
    testId: number | null
  }

  export type QuestionsTableSumAggregateOutputType = {
    id: number | null
    maxMark: number | null
    testId: number | null
  }

  export type QuestionsTableMinAggregateOutputType = {
    id: number | null
    queText: string | null
    optionA: string | null
    optionB: string | null
    optionC: string | null
    optionD: string | null
    correctOption: string | null
    maxMark: number | null
    testId: number | null
  }

  export type QuestionsTableMaxAggregateOutputType = {
    id: number | null
    queText: string | null
    optionA: string | null
    optionB: string | null
    optionC: string | null
    optionD: string | null
    correctOption: string | null
    maxMark: number | null
    testId: number | null
  }

  export type QuestionsTableCountAggregateOutputType = {
    id: number
    queText: number
    optionA: number
    optionB: number
    optionC: number
    optionD: number
    correctOption: number
    maxMark: number
    testId: number
    _all: number
  }


  export type QuestionsTableAvgAggregateInputType = {
    id?: true
    maxMark?: true
    testId?: true
  }

  export type QuestionsTableSumAggregateInputType = {
    id?: true
    maxMark?: true
    testId?: true
  }

  export type QuestionsTableMinAggregateInputType = {
    id?: true
    queText?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    maxMark?: true
    testId?: true
  }

  export type QuestionsTableMaxAggregateInputType = {
    id?: true
    queText?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    maxMark?: true
    testId?: true
  }

  export type QuestionsTableCountAggregateInputType = {
    id?: true
    queText?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    maxMark?: true
    testId?: true
    _all?: true
  }

  export type QuestionsTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionsTable to aggregate.
     */
    where?: QuestionsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsTables to fetch.
     */
    orderBy?: QuestionsTableOrderByWithRelationInput | QuestionsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsTables
    **/
    _count?: true | QuestionsTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsTableMaxAggregateInputType
  }

  export type GetQuestionsTableAggregateType<T extends QuestionsTableAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsTable[P]>
      : GetScalarType<T[P], AggregateQuestionsTable[P]>
  }




  export type QuestionsTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsTableWhereInput
    orderBy?: QuestionsTableOrderByWithAggregationInput | QuestionsTableOrderByWithAggregationInput[]
    by: QuestionsTableScalarFieldEnum[] | QuestionsTableScalarFieldEnum
    having?: QuestionsTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsTableCountAggregateInputType | true
    _avg?: QuestionsTableAvgAggregateInputType
    _sum?: QuestionsTableSumAggregateInputType
    _min?: QuestionsTableMinAggregateInputType
    _max?: QuestionsTableMaxAggregateInputType
  }

  export type QuestionsTableGroupByOutputType = {
    id: number
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    testId: number
    _count: QuestionsTableCountAggregateOutputType | null
    _avg: QuestionsTableAvgAggregateOutputType | null
    _sum: QuestionsTableSumAggregateOutputType | null
    _min: QuestionsTableMinAggregateOutputType | null
    _max: QuestionsTableMaxAggregateOutputType | null
  }

  type GetQuestionsTableGroupByPayload<T extends QuestionsTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsTableGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsTableGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queText?: boolean
    optionA?: boolean
    optionB?: boolean
    optionC?: boolean
    optionD?: boolean
    correctOption?: boolean
    maxMark?: boolean
    testId?: boolean
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    responses?: boolean | QuestionsTable$responsesArgs<ExtArgs>
    _count?: boolean | QuestionsTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionsTable"]>

  export type QuestionsTableSelectScalar = {
    id?: boolean
    queText?: boolean
    optionA?: boolean
    optionB?: boolean
    optionC?: boolean
    optionD?: boolean
    correctOption?: boolean
    maxMark?: boolean
    testId?: boolean
  }

  export type QuestionsTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    responses?: boolean | QuestionsTable$responsesArgs<ExtArgs>
    _count?: boolean | QuestionsTableCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $QuestionsTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionsTable"
    objects: {
      test: Prisma.$TestTablePayload<ExtArgs>
      responses: Prisma.$StudentResponseTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      queText: string
      optionA: string
      optionB: string
      optionC: string
      optionD: string
      correctOption: string
      maxMark: number
      testId: number
    }, ExtArgs["result"]["questionsTable"]>
    composites: {}
  }


  type QuestionsTableGetPayload<S extends boolean | null | undefined | QuestionsTableDefaultArgs> = $Result.GetResult<Prisma.$QuestionsTablePayload, S>

  type QuestionsTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionsTableFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: QuestionsTableCountAggregateInputType | true
    }

  export interface QuestionsTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionsTable'], meta: { name: 'QuestionsTable' } }
    /**
     * Find zero or one QuestionsTable that matches the filter.
     * @param {QuestionsTableFindUniqueArgs} args - Arguments to find a QuestionsTable
     * @example
     * // Get one QuestionsTable
     * const questionsTable = await prisma.questionsTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionsTableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, QuestionsTableFindUniqueArgs<ExtArgs>>
    ): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one QuestionsTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuestionsTableFindUniqueOrThrowArgs} args - Arguments to find a QuestionsTable
     * @example
     * // Get one QuestionsTable
     * const questionsTable = await prisma.questionsTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionsTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestionsTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first QuestionsTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableFindFirstArgs} args - Arguments to find a QuestionsTable
     * @example
     * // Get one QuestionsTable
     * const questionsTable = await prisma.questionsTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionsTableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestionsTableFindFirstArgs<ExtArgs>>
    ): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first QuestionsTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableFindFirstOrThrowArgs} args - Arguments to find a QuestionsTable
     * @example
     * // Get one QuestionsTable
     * const questionsTable = await prisma.questionsTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionsTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestionsTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more QuestionsTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsTables
     * const questionsTables = await prisma.questionsTable.findMany()
     * 
     * // Get first 10 QuestionsTables
     * const questionsTables = await prisma.questionsTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsTableWithIdOnly = await prisma.questionsTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionsTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestionsTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a QuestionsTable.
     * @param {QuestionsTableCreateArgs} args - Arguments to create a QuestionsTable.
     * @example
     * // Create one QuestionsTable
     * const QuestionsTable = await prisma.questionsTable.create({
     *   data: {
     *     // ... data to create a QuestionsTable
     *   }
     * })
     * 
    **/
    create<T extends QuestionsTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, QuestionsTableCreateArgs<ExtArgs>>
    ): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many QuestionsTables.
     *     @param {QuestionsTableCreateManyArgs} args - Arguments to create many QuestionsTables.
     *     @example
     *     // Create many QuestionsTables
     *     const questionsTable = await prisma.questionsTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionsTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestionsTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsTable.
     * @param {QuestionsTableDeleteArgs} args - Arguments to delete one QuestionsTable.
     * @example
     * // Delete one QuestionsTable
     * const QuestionsTable = await prisma.questionsTable.delete({
     *   where: {
     *     // ... filter to delete one QuestionsTable
     *   }
     * })
     * 
    **/
    delete<T extends QuestionsTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, QuestionsTableDeleteArgs<ExtArgs>>
    ): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one QuestionsTable.
     * @param {QuestionsTableUpdateArgs} args - Arguments to update one QuestionsTable.
     * @example
     * // Update one QuestionsTable
     * const questionsTable = await prisma.questionsTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionsTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, QuestionsTableUpdateArgs<ExtArgs>>
    ): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more QuestionsTables.
     * @param {QuestionsTableDeleteManyArgs} args - Arguments to filter QuestionsTables to delete.
     * @example
     * // Delete a few QuestionsTables
     * const { count } = await prisma.questionsTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionsTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestionsTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsTables
     * const questionsTable = await prisma.questionsTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionsTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, QuestionsTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsTable.
     * @param {QuestionsTableUpsertArgs} args - Arguments to update or create a QuestionsTable.
     * @example
     * // Update or create a QuestionsTable
     * const questionsTable = await prisma.questionsTable.upsert({
     *   create: {
     *     // ... data to create a QuestionsTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsTable we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionsTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, QuestionsTableUpsertArgs<ExtArgs>>
    ): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of QuestionsTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableCountArgs} args - Arguments to filter QuestionsTables to count.
     * @example
     * // Count the number of QuestionsTables
     * const count = await prisma.questionsTable.count({
     *   where: {
     *     // ... the filter for the QuestionsTables we want to count
     *   }
     * })
    **/
    count<T extends QuestionsTableCountArgs>(
      args?: Subset<T, QuestionsTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsTableAggregateArgs>(args: Subset<T, QuestionsTableAggregateArgs>): Prisma.PrismaPromise<GetQuestionsTableAggregateType<T>>

    /**
     * Group by QuestionsTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsTableGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionsTable model
   */
  readonly fields: QuestionsTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionsTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    test<T extends TestTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestTableDefaultArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    responses<T extends QuestionsTable$responsesArgs<ExtArgs> = {}>(args?: Subset<T, QuestionsTable$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the QuestionsTable model
   */ 
  interface QuestionsTableFieldRefs {
    readonly id: FieldRef<"QuestionsTable", 'Int'>
    readonly queText: FieldRef<"QuestionsTable", 'String'>
    readonly optionA: FieldRef<"QuestionsTable", 'String'>
    readonly optionB: FieldRef<"QuestionsTable", 'String'>
    readonly optionC: FieldRef<"QuestionsTable", 'String'>
    readonly optionD: FieldRef<"QuestionsTable", 'String'>
    readonly correctOption: FieldRef<"QuestionsTable", 'String'>
    readonly maxMark: FieldRef<"QuestionsTable", 'Int'>
    readonly testId: FieldRef<"QuestionsTable", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * QuestionsTable findUnique
   */
  export type QuestionsTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsTable to fetch.
     */
    where: QuestionsTableWhereUniqueInput
  }


  /**
   * QuestionsTable findUniqueOrThrow
   */
  export type QuestionsTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsTable to fetch.
     */
    where: QuestionsTableWhereUniqueInput
  }


  /**
   * QuestionsTable findFirst
   */
  export type QuestionsTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsTable to fetch.
     */
    where?: QuestionsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsTables to fetch.
     */
    orderBy?: QuestionsTableOrderByWithRelationInput | QuestionsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsTables.
     */
    cursor?: QuestionsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsTables.
     */
    distinct?: QuestionsTableScalarFieldEnum | QuestionsTableScalarFieldEnum[]
  }


  /**
   * QuestionsTable findFirstOrThrow
   */
  export type QuestionsTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsTable to fetch.
     */
    where?: QuestionsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsTables to fetch.
     */
    orderBy?: QuestionsTableOrderByWithRelationInput | QuestionsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsTables.
     */
    cursor?: QuestionsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsTables.
     */
    distinct?: QuestionsTableScalarFieldEnum | QuestionsTableScalarFieldEnum[]
  }


  /**
   * QuestionsTable findMany
   */
  export type QuestionsTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsTables to fetch.
     */
    where?: QuestionsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsTables to fetch.
     */
    orderBy?: QuestionsTableOrderByWithRelationInput | QuestionsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsTables.
     */
    cursor?: QuestionsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsTables.
     */
    skip?: number
    distinct?: QuestionsTableScalarFieldEnum | QuestionsTableScalarFieldEnum[]
  }


  /**
   * QuestionsTable create
   */
  export type QuestionsTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionsTable.
     */
    data: XOR<QuestionsTableCreateInput, QuestionsTableUncheckedCreateInput>
  }


  /**
   * QuestionsTable createMany
   */
  export type QuestionsTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionsTables.
     */
    data: QuestionsTableCreateManyInput | QuestionsTableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * QuestionsTable update
   */
  export type QuestionsTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionsTable.
     */
    data: XOR<QuestionsTableUpdateInput, QuestionsTableUncheckedUpdateInput>
    /**
     * Choose, which QuestionsTable to update.
     */
    where: QuestionsTableWhereUniqueInput
  }


  /**
   * QuestionsTable updateMany
   */
  export type QuestionsTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionsTables.
     */
    data: XOR<QuestionsTableUpdateManyMutationInput, QuestionsTableUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsTables to update
     */
    where?: QuestionsTableWhereInput
  }


  /**
   * QuestionsTable upsert
   */
  export type QuestionsTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionsTable to update in case it exists.
     */
    where: QuestionsTableWhereUniqueInput
    /**
     * In case the QuestionsTable found by the `where` argument doesn't exist, create a new QuestionsTable with this data.
     */
    create: XOR<QuestionsTableCreateInput, QuestionsTableUncheckedCreateInput>
    /**
     * In case the QuestionsTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionsTableUpdateInput, QuestionsTableUncheckedUpdateInput>
  }


  /**
   * QuestionsTable delete
   */
  export type QuestionsTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter which QuestionsTable to delete.
     */
    where: QuestionsTableWhereUniqueInput
  }


  /**
   * QuestionsTable deleteMany
   */
  export type QuestionsTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionsTables to delete
     */
    where?: QuestionsTableWhereInput
  }


  /**
   * QuestionsTable.responses
   */
  export type QuestionsTable$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    where?: StudentResponseTableWhereInput
    orderBy?: StudentResponseTableOrderByWithRelationInput | StudentResponseTableOrderByWithRelationInput[]
    cursor?: StudentResponseTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentResponseTableScalarFieldEnum | StudentResponseTableScalarFieldEnum[]
  }


  /**
   * QuestionsTable without action
   */
  export type QuestionsTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestionsTableInclude<ExtArgs> | null
  }



  /**
   * Model ResultTable
   */

  export type AggregateResultTable = {
    _count: ResultTableCountAggregateOutputType | null
    _avg: ResultTableAvgAggregateOutputType | null
    _sum: ResultTableSumAggregateOutputType | null
    _min: ResultTableMinAggregateOutputType | null
    _max: ResultTableMaxAggregateOutputType | null
  }

  export type ResultTableAvgAggregateOutputType = {
    id: number | null
    totalmarks: number | null
    scoredmarks: number | null
    testId: number | null
    studentId: number | null
    tabSwitchCount: number | null
    fullScreenExits: number | null
    maxFaceCount: number | null
  }

  export type ResultTableSumAggregateOutputType = {
    id: number | null
    totalmarks: number | null
    scoredmarks: number | null
    testId: number | null
    studentId: number | null
    tabSwitchCount: number | null
    fullScreenExits: number | null
    maxFaceCount: number | null
  }

  export type ResultTableMinAggregateOutputType = {
    id: number | null
    totalmarks: number | null
    scoredmarks: number | null
    cheated: boolean | null
    testId: number | null
    studentId: number | null
    tabSwitchCount: number | null
    fullScreenExits: number | null
    maxFaceCount: number | null
  }

  export type ResultTableMaxAggregateOutputType = {
    id: number | null
    totalmarks: number | null
    scoredmarks: number | null
    cheated: boolean | null
    testId: number | null
    studentId: number | null
    tabSwitchCount: number | null
    fullScreenExits: number | null
    maxFaceCount: number | null
  }

  export type ResultTableCountAggregateOutputType = {
    id: number
    totalmarks: number
    scoredmarks: number
    cheated: number
    testId: number
    studentId: number
    tabSwitchCount: number
    fullScreenExits: number
    maxFaceCount: number
    _all: number
  }


  export type ResultTableAvgAggregateInputType = {
    id?: true
    totalmarks?: true
    scoredmarks?: true
    testId?: true
    studentId?: true
    tabSwitchCount?: true
    fullScreenExits?: true
    maxFaceCount?: true
  }

  export type ResultTableSumAggregateInputType = {
    id?: true
    totalmarks?: true
    scoredmarks?: true
    testId?: true
    studentId?: true
    tabSwitchCount?: true
    fullScreenExits?: true
    maxFaceCount?: true
  }

  export type ResultTableMinAggregateInputType = {
    id?: true
    totalmarks?: true
    scoredmarks?: true
    cheated?: true
    testId?: true
    studentId?: true
    tabSwitchCount?: true
    fullScreenExits?: true
    maxFaceCount?: true
  }

  export type ResultTableMaxAggregateInputType = {
    id?: true
    totalmarks?: true
    scoredmarks?: true
    cheated?: true
    testId?: true
    studentId?: true
    tabSwitchCount?: true
    fullScreenExits?: true
    maxFaceCount?: true
  }

  export type ResultTableCountAggregateInputType = {
    id?: true
    totalmarks?: true
    scoredmarks?: true
    cheated?: true
    testId?: true
    studentId?: true
    tabSwitchCount?: true
    fullScreenExits?: true
    maxFaceCount?: true
    _all?: true
  }

  export type ResultTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultTable to aggregate.
     */
    where?: ResultTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultTables to fetch.
     */
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResultTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResultTables
    **/
    _count?: true | ResultTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResultTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResultTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResultTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResultTableMaxAggregateInputType
  }

  export type GetResultTableAggregateType<T extends ResultTableAggregateArgs> = {
        [P in keyof T & keyof AggregateResultTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResultTable[P]>
      : GetScalarType<T[P], AggregateResultTable[P]>
  }




  export type ResultTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultTableWhereInput
    orderBy?: ResultTableOrderByWithAggregationInput | ResultTableOrderByWithAggregationInput[]
    by: ResultTableScalarFieldEnum[] | ResultTableScalarFieldEnum
    having?: ResultTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResultTableCountAggregateInputType | true
    _avg?: ResultTableAvgAggregateInputType
    _sum?: ResultTableSumAggregateInputType
    _min?: ResultTableMinAggregateInputType
    _max?: ResultTableMaxAggregateInputType
  }

  export type ResultTableGroupByOutputType = {
    id: number
    totalmarks: number
    scoredmarks: number
    cheated: boolean
    testId: number
    studentId: number
    tabSwitchCount: number
    fullScreenExits: number
    maxFaceCount: number
    _count: ResultTableCountAggregateOutputType | null
    _avg: ResultTableAvgAggregateOutputType | null
    _sum: ResultTableSumAggregateOutputType | null
    _min: ResultTableMinAggregateOutputType | null
    _max: ResultTableMaxAggregateOutputType | null
  }

  type GetResultTableGroupByPayload<T extends ResultTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResultTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResultTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResultTableGroupByOutputType[P]>
            : GetScalarType<T[P], ResultTableGroupByOutputType[P]>
        }
      >
    >


  export type ResultTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalmarks?: boolean
    scoredmarks?: boolean
    cheated?: boolean
    testId?: boolean
    studentId?: boolean
    tabSwitchCount?: boolean
    fullScreenExits?: boolean
    maxFaceCount?: boolean
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    student?: boolean | StudentTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultTable"]>

  export type ResultTableSelectScalar = {
    id?: boolean
    totalmarks?: boolean
    scoredmarks?: boolean
    cheated?: boolean
    testId?: boolean
    studentId?: boolean
    tabSwitchCount?: boolean
    fullScreenExits?: boolean
    maxFaceCount?: boolean
  }

  export type ResultTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    student?: boolean | StudentTableDefaultArgs<ExtArgs>
  }


  export type $ResultTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResultTable"
    objects: {
      test: Prisma.$TestTablePayload<ExtArgs>
      student: Prisma.$StudentTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalmarks: number
      scoredmarks: number
      cheated: boolean
      testId: number
      studentId: number
      tabSwitchCount: number
      fullScreenExits: number
      maxFaceCount: number
    }, ExtArgs["result"]["resultTable"]>
    composites: {}
  }


  type ResultTableGetPayload<S extends boolean | null | undefined | ResultTableDefaultArgs> = $Result.GetResult<Prisma.$ResultTablePayload, S>

  type ResultTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResultTableFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ResultTableCountAggregateInputType | true
    }

  export interface ResultTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResultTable'], meta: { name: 'ResultTable' } }
    /**
     * Find zero or one ResultTable that matches the filter.
     * @param {ResultTableFindUniqueArgs} args - Arguments to find a ResultTable
     * @example
     * // Get one ResultTable
     * const resultTable = await prisma.resultTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResultTableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ResultTableFindUniqueArgs<ExtArgs>>
    ): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ResultTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResultTableFindUniqueOrThrowArgs} args - Arguments to find a ResultTable
     * @example
     * // Get one ResultTable
     * const resultTable = await prisma.resultTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResultTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ResultTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableFindFirstArgs} args - Arguments to find a ResultTable
     * @example
     * // Get one ResultTable
     * const resultTable = await prisma.resultTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResultTableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultTableFindFirstArgs<ExtArgs>>
    ): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ResultTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableFindFirstOrThrowArgs} args - Arguments to find a ResultTable
     * @example
     * // Get one ResultTable
     * const resultTable = await prisma.resultTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResultTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ResultTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResultTables
     * const resultTables = await prisma.resultTable.findMany()
     * 
     * // Get first 10 ResultTables
     * const resultTables = await prisma.resultTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resultTableWithIdOnly = await prisma.resultTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResultTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ResultTable.
     * @param {ResultTableCreateArgs} args - Arguments to create a ResultTable.
     * @example
     * // Create one ResultTable
     * const ResultTable = await prisma.resultTable.create({
     *   data: {
     *     // ... data to create a ResultTable
     *   }
     * })
     * 
    **/
    create<T extends ResultTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResultTableCreateArgs<ExtArgs>>
    ): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ResultTables.
     *     @param {ResultTableCreateManyArgs} args - Arguments to create many ResultTables.
     *     @example
     *     // Create many ResultTables
     *     const resultTable = await prisma.resultTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResultTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResultTable.
     * @param {ResultTableDeleteArgs} args - Arguments to delete one ResultTable.
     * @example
     * // Delete one ResultTable
     * const ResultTable = await prisma.resultTable.delete({
     *   where: {
     *     // ... filter to delete one ResultTable
     *   }
     * })
     * 
    **/
    delete<T extends ResultTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResultTableDeleteArgs<ExtArgs>>
    ): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ResultTable.
     * @param {ResultTableUpdateArgs} args - Arguments to update one ResultTable.
     * @example
     * // Update one ResultTable
     * const resultTable = await prisma.resultTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResultTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResultTableUpdateArgs<ExtArgs>>
    ): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ResultTables.
     * @param {ResultTableDeleteManyArgs} args - Arguments to filter ResultTables to delete.
     * @example
     * // Delete a few ResultTables
     * const { count } = await prisma.resultTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResultTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResultTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResultTables
     * const resultTable = await prisma.resultTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResultTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResultTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResultTable.
     * @param {ResultTableUpsertArgs} args - Arguments to update or create a ResultTable.
     * @example
     * // Update or create a ResultTable
     * const resultTable = await prisma.resultTable.upsert({
     *   create: {
     *     // ... data to create a ResultTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResultTable we want to update
     *   }
     * })
    **/
    upsert<T extends ResultTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResultTableUpsertArgs<ExtArgs>>
    ): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ResultTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableCountArgs} args - Arguments to filter ResultTables to count.
     * @example
     * // Count the number of ResultTables
     * const count = await prisma.resultTable.count({
     *   where: {
     *     // ... the filter for the ResultTables we want to count
     *   }
     * })
    **/
    count<T extends ResultTableCountArgs>(
      args?: Subset<T, ResultTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResultTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResultTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResultTableAggregateArgs>(args: Subset<T, ResultTableAggregateArgs>): Prisma.PrismaPromise<GetResultTableAggregateType<T>>

    /**
     * Group by ResultTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResultTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResultTableGroupByArgs['orderBy'] }
        : { orderBy?: ResultTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResultTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResultTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResultTable model
   */
  readonly fields: ResultTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResultTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResultTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    test<T extends TestTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestTableDefaultArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    student<T extends StudentTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentTableDefaultArgs<ExtArgs>>): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ResultTable model
   */ 
  interface ResultTableFieldRefs {
    readonly id: FieldRef<"ResultTable", 'Int'>
    readonly totalmarks: FieldRef<"ResultTable", 'Int'>
    readonly scoredmarks: FieldRef<"ResultTable", 'Int'>
    readonly cheated: FieldRef<"ResultTable", 'Boolean'>
    readonly testId: FieldRef<"ResultTable", 'Int'>
    readonly studentId: FieldRef<"ResultTable", 'Int'>
    readonly tabSwitchCount: FieldRef<"ResultTable", 'Int'>
    readonly fullScreenExits: FieldRef<"ResultTable", 'Int'>
    readonly maxFaceCount: FieldRef<"ResultTable", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ResultTable findUnique
   */
  export type ResultTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter, which ResultTable to fetch.
     */
    where: ResultTableWhereUniqueInput
  }


  /**
   * ResultTable findUniqueOrThrow
   */
  export type ResultTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter, which ResultTable to fetch.
     */
    where: ResultTableWhereUniqueInput
  }


  /**
   * ResultTable findFirst
   */
  export type ResultTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter, which ResultTable to fetch.
     */
    where?: ResultTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultTables to fetch.
     */
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultTables.
     */
    cursor?: ResultTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultTables.
     */
    distinct?: ResultTableScalarFieldEnum | ResultTableScalarFieldEnum[]
  }


  /**
   * ResultTable findFirstOrThrow
   */
  export type ResultTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter, which ResultTable to fetch.
     */
    where?: ResultTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultTables to fetch.
     */
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultTables.
     */
    cursor?: ResultTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultTables.
     */
    distinct?: ResultTableScalarFieldEnum | ResultTableScalarFieldEnum[]
  }


  /**
   * ResultTable findMany
   */
  export type ResultTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter, which ResultTables to fetch.
     */
    where?: ResultTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultTables to fetch.
     */
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResultTables.
     */
    cursor?: ResultTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultTables.
     */
    skip?: number
    distinct?: ResultTableScalarFieldEnum | ResultTableScalarFieldEnum[]
  }


  /**
   * ResultTable create
   */
  export type ResultTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * The data needed to create a ResultTable.
     */
    data: XOR<ResultTableCreateInput, ResultTableUncheckedCreateInput>
  }


  /**
   * ResultTable createMany
   */
  export type ResultTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResultTables.
     */
    data: ResultTableCreateManyInput | ResultTableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ResultTable update
   */
  export type ResultTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * The data needed to update a ResultTable.
     */
    data: XOR<ResultTableUpdateInput, ResultTableUncheckedUpdateInput>
    /**
     * Choose, which ResultTable to update.
     */
    where: ResultTableWhereUniqueInput
  }


  /**
   * ResultTable updateMany
   */
  export type ResultTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResultTables.
     */
    data: XOR<ResultTableUpdateManyMutationInput, ResultTableUncheckedUpdateManyInput>
    /**
     * Filter which ResultTables to update
     */
    where?: ResultTableWhereInput
  }


  /**
   * ResultTable upsert
   */
  export type ResultTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * The filter to search for the ResultTable to update in case it exists.
     */
    where: ResultTableWhereUniqueInput
    /**
     * In case the ResultTable found by the `where` argument doesn't exist, create a new ResultTable with this data.
     */
    create: XOR<ResultTableCreateInput, ResultTableUncheckedCreateInput>
    /**
     * In case the ResultTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResultTableUpdateInput, ResultTableUncheckedUpdateInput>
  }


  /**
   * ResultTable delete
   */
  export type ResultTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter which ResultTable to delete.
     */
    where: ResultTableWhereUniqueInput
  }


  /**
   * ResultTable deleteMany
   */
  export type ResultTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultTables to delete
     */
    where?: ResultTableWhereInput
  }


  /**
   * ResultTable without action
   */
  export type ResultTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultTableInclude<ExtArgs> | null
  }



  /**
   * Model StudentResponseTable
   */

  export type AggregateStudentResponseTable = {
    _count: StudentResponseTableCountAggregateOutputType | null
    _avg: StudentResponseTableAvgAggregateOutputType | null
    _sum: StudentResponseTableSumAggregateOutputType | null
    _min: StudentResponseTableMinAggregateOutputType | null
    _max: StudentResponseTableMaxAggregateOutputType | null
  }

  export type StudentResponseTableAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    testId: number | null
    questionId: number | null
  }

  export type StudentResponseTableSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    testId: number | null
    questionId: number | null
  }

  export type StudentResponseTableMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    testId: number | null
    questionId: number | null
    selectedOption: string | null
    isCorrect: boolean | null
  }

  export type StudentResponseTableMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    testId: number | null
    questionId: number | null
    selectedOption: string | null
    isCorrect: boolean | null
  }

  export type StudentResponseTableCountAggregateOutputType = {
    id: number
    studentId: number
    testId: number
    questionId: number
    selectedOption: number
    isCorrect: number
    _all: number
  }


  export type StudentResponseTableAvgAggregateInputType = {
    id?: true
    studentId?: true
    testId?: true
    questionId?: true
  }

  export type StudentResponseTableSumAggregateInputType = {
    id?: true
    studentId?: true
    testId?: true
    questionId?: true
  }

  export type StudentResponseTableMinAggregateInputType = {
    id?: true
    studentId?: true
    testId?: true
    questionId?: true
    selectedOption?: true
    isCorrect?: true
  }

  export type StudentResponseTableMaxAggregateInputType = {
    id?: true
    studentId?: true
    testId?: true
    questionId?: true
    selectedOption?: true
    isCorrect?: true
  }

  export type StudentResponseTableCountAggregateInputType = {
    id?: true
    studentId?: true
    testId?: true
    questionId?: true
    selectedOption?: true
    isCorrect?: true
    _all?: true
  }

  export type StudentResponseTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentResponseTable to aggregate.
     */
    where?: StudentResponseTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentResponseTables to fetch.
     */
    orderBy?: StudentResponseTableOrderByWithRelationInput | StudentResponseTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentResponseTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentResponseTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentResponseTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentResponseTables
    **/
    _count?: true | StudentResponseTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentResponseTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentResponseTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentResponseTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentResponseTableMaxAggregateInputType
  }

  export type GetStudentResponseTableAggregateType<T extends StudentResponseTableAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentResponseTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentResponseTable[P]>
      : GetScalarType<T[P], AggregateStudentResponseTable[P]>
  }




  export type StudentResponseTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentResponseTableWhereInput
    orderBy?: StudentResponseTableOrderByWithAggregationInput | StudentResponseTableOrderByWithAggregationInput[]
    by: StudentResponseTableScalarFieldEnum[] | StudentResponseTableScalarFieldEnum
    having?: StudentResponseTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentResponseTableCountAggregateInputType | true
    _avg?: StudentResponseTableAvgAggregateInputType
    _sum?: StudentResponseTableSumAggregateInputType
    _min?: StudentResponseTableMinAggregateInputType
    _max?: StudentResponseTableMaxAggregateInputType
  }

  export type StudentResponseTableGroupByOutputType = {
    id: number
    studentId: number
    testId: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
    _count: StudentResponseTableCountAggregateOutputType | null
    _avg: StudentResponseTableAvgAggregateOutputType | null
    _sum: StudentResponseTableSumAggregateOutputType | null
    _min: StudentResponseTableMinAggregateOutputType | null
    _max: StudentResponseTableMaxAggregateOutputType | null
  }

  type GetStudentResponseTableGroupByPayload<T extends StudentResponseTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentResponseTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentResponseTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentResponseTableGroupByOutputType[P]>
            : GetScalarType<T[P], StudentResponseTableGroupByOutputType[P]>
        }
      >
    >


  export type StudentResponseTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    testId?: boolean
    questionId?: boolean
    selectedOption?: boolean
    isCorrect?: boolean
    student?: boolean | StudentTableDefaultArgs<ExtArgs>
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    question?: boolean | QuestionsTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentResponseTable"]>

  export type StudentResponseTableSelectScalar = {
    id?: boolean
    studentId?: boolean
    testId?: boolean
    questionId?: boolean
    selectedOption?: boolean
    isCorrect?: boolean
  }

  export type StudentResponseTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentTableDefaultArgs<ExtArgs>
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    question?: boolean | QuestionsTableDefaultArgs<ExtArgs>
  }


  export type $StudentResponseTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentResponseTable"
    objects: {
      student: Prisma.$StudentTablePayload<ExtArgs>
      test: Prisma.$TestTablePayload<ExtArgs>
      question: Prisma.$QuestionsTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      testId: number
      questionId: number
      selectedOption: string
      isCorrect: boolean
    }, ExtArgs["result"]["studentResponseTable"]>
    composites: {}
  }


  type StudentResponseTableGetPayload<S extends boolean | null | undefined | StudentResponseTableDefaultArgs> = $Result.GetResult<Prisma.$StudentResponseTablePayload, S>

  type StudentResponseTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentResponseTableFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StudentResponseTableCountAggregateInputType | true
    }

  export interface StudentResponseTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentResponseTable'], meta: { name: 'StudentResponseTable' } }
    /**
     * Find zero or one StudentResponseTable that matches the filter.
     * @param {StudentResponseTableFindUniqueArgs} args - Arguments to find a StudentResponseTable
     * @example
     * // Get one StudentResponseTable
     * const studentResponseTable = await prisma.studentResponseTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentResponseTableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentResponseTableFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentResponseTableClient<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentResponseTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentResponseTableFindUniqueOrThrowArgs} args - Arguments to find a StudentResponseTable
     * @example
     * // Get one StudentResponseTable
     * const studentResponseTable = await prisma.studentResponseTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentResponseTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentResponseTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentResponseTableClient<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentResponseTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponseTableFindFirstArgs} args - Arguments to find a StudentResponseTable
     * @example
     * // Get one StudentResponseTable
     * const studentResponseTable = await prisma.studentResponseTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentResponseTableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentResponseTableFindFirstArgs<ExtArgs>>
    ): Prisma__StudentResponseTableClient<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentResponseTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponseTableFindFirstOrThrowArgs} args - Arguments to find a StudentResponseTable
     * @example
     * // Get one StudentResponseTable
     * const studentResponseTable = await prisma.studentResponseTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentResponseTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentResponseTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentResponseTableClient<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentResponseTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponseTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentResponseTables
     * const studentResponseTables = await prisma.studentResponseTable.findMany()
     * 
     * // Get first 10 StudentResponseTables
     * const studentResponseTables = await prisma.studentResponseTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentResponseTableWithIdOnly = await prisma.studentResponseTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentResponseTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentResponseTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentResponseTable.
     * @param {StudentResponseTableCreateArgs} args - Arguments to create a StudentResponseTable.
     * @example
     * // Create one StudentResponseTable
     * const StudentResponseTable = await prisma.studentResponseTable.create({
     *   data: {
     *     // ... data to create a StudentResponseTable
     *   }
     * })
     * 
    **/
    create<T extends StudentResponseTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentResponseTableCreateArgs<ExtArgs>>
    ): Prisma__StudentResponseTableClient<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentResponseTables.
     *     @param {StudentResponseTableCreateManyArgs} args - Arguments to create many StudentResponseTables.
     *     @example
     *     // Create many StudentResponseTables
     *     const studentResponseTable = await prisma.studentResponseTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentResponseTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentResponseTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentResponseTable.
     * @param {StudentResponseTableDeleteArgs} args - Arguments to delete one StudentResponseTable.
     * @example
     * // Delete one StudentResponseTable
     * const StudentResponseTable = await prisma.studentResponseTable.delete({
     *   where: {
     *     // ... filter to delete one StudentResponseTable
     *   }
     * })
     * 
    **/
    delete<T extends StudentResponseTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentResponseTableDeleteArgs<ExtArgs>>
    ): Prisma__StudentResponseTableClient<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentResponseTable.
     * @param {StudentResponseTableUpdateArgs} args - Arguments to update one StudentResponseTable.
     * @example
     * // Update one StudentResponseTable
     * const studentResponseTable = await prisma.studentResponseTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentResponseTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentResponseTableUpdateArgs<ExtArgs>>
    ): Prisma__StudentResponseTableClient<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentResponseTables.
     * @param {StudentResponseTableDeleteManyArgs} args - Arguments to filter StudentResponseTables to delete.
     * @example
     * // Delete a few StudentResponseTables
     * const { count } = await prisma.studentResponseTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentResponseTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentResponseTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentResponseTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponseTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentResponseTables
     * const studentResponseTable = await prisma.studentResponseTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentResponseTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentResponseTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentResponseTable.
     * @param {StudentResponseTableUpsertArgs} args - Arguments to update or create a StudentResponseTable.
     * @example
     * // Update or create a StudentResponseTable
     * const studentResponseTable = await prisma.studentResponseTable.upsert({
     *   create: {
     *     // ... data to create a StudentResponseTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentResponseTable we want to update
     *   }
     * })
    **/
    upsert<T extends StudentResponseTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentResponseTableUpsertArgs<ExtArgs>>
    ): Prisma__StudentResponseTableClient<$Result.GetResult<Prisma.$StudentResponseTablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentResponseTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponseTableCountArgs} args - Arguments to filter StudentResponseTables to count.
     * @example
     * // Count the number of StudentResponseTables
     * const count = await prisma.studentResponseTable.count({
     *   where: {
     *     // ... the filter for the StudentResponseTables we want to count
     *   }
     * })
    **/
    count<T extends StudentResponseTableCountArgs>(
      args?: Subset<T, StudentResponseTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentResponseTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentResponseTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponseTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentResponseTableAggregateArgs>(args: Subset<T, StudentResponseTableAggregateArgs>): Prisma.PrismaPromise<GetStudentResponseTableAggregateType<T>>

    /**
     * Group by StudentResponseTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponseTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentResponseTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentResponseTableGroupByArgs['orderBy'] }
        : { orderBy?: StudentResponseTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentResponseTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentResponseTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentResponseTable model
   */
  readonly fields: StudentResponseTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentResponseTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentResponseTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    student<T extends StudentTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentTableDefaultArgs<ExtArgs>>): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    test<T extends TestTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestTableDefaultArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    question<T extends QuestionsTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionsTableDefaultArgs<ExtArgs>>): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentResponseTable model
   */ 
  interface StudentResponseTableFieldRefs {
    readonly id: FieldRef<"StudentResponseTable", 'Int'>
    readonly studentId: FieldRef<"StudentResponseTable", 'Int'>
    readonly testId: FieldRef<"StudentResponseTable", 'Int'>
    readonly questionId: FieldRef<"StudentResponseTable", 'Int'>
    readonly selectedOption: FieldRef<"StudentResponseTable", 'String'>
    readonly isCorrect: FieldRef<"StudentResponseTable", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * StudentResponseTable findUnique
   */
  export type StudentResponseTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentResponseTable to fetch.
     */
    where: StudentResponseTableWhereUniqueInput
  }


  /**
   * StudentResponseTable findUniqueOrThrow
   */
  export type StudentResponseTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentResponseTable to fetch.
     */
    where: StudentResponseTableWhereUniqueInput
  }


  /**
   * StudentResponseTable findFirst
   */
  export type StudentResponseTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentResponseTable to fetch.
     */
    where?: StudentResponseTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentResponseTables to fetch.
     */
    orderBy?: StudentResponseTableOrderByWithRelationInput | StudentResponseTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentResponseTables.
     */
    cursor?: StudentResponseTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentResponseTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentResponseTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentResponseTables.
     */
    distinct?: StudentResponseTableScalarFieldEnum | StudentResponseTableScalarFieldEnum[]
  }


  /**
   * StudentResponseTable findFirstOrThrow
   */
  export type StudentResponseTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentResponseTable to fetch.
     */
    where?: StudentResponseTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentResponseTables to fetch.
     */
    orderBy?: StudentResponseTableOrderByWithRelationInput | StudentResponseTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentResponseTables.
     */
    cursor?: StudentResponseTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentResponseTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentResponseTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentResponseTables.
     */
    distinct?: StudentResponseTableScalarFieldEnum | StudentResponseTableScalarFieldEnum[]
  }


  /**
   * StudentResponseTable findMany
   */
  export type StudentResponseTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentResponseTables to fetch.
     */
    where?: StudentResponseTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentResponseTables to fetch.
     */
    orderBy?: StudentResponseTableOrderByWithRelationInput | StudentResponseTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentResponseTables.
     */
    cursor?: StudentResponseTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentResponseTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentResponseTables.
     */
    skip?: number
    distinct?: StudentResponseTableScalarFieldEnum | StudentResponseTableScalarFieldEnum[]
  }


  /**
   * StudentResponseTable create
   */
  export type StudentResponseTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentResponseTable.
     */
    data: XOR<StudentResponseTableCreateInput, StudentResponseTableUncheckedCreateInput>
  }


  /**
   * StudentResponseTable createMany
   */
  export type StudentResponseTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentResponseTables.
     */
    data: StudentResponseTableCreateManyInput | StudentResponseTableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentResponseTable update
   */
  export type StudentResponseTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentResponseTable.
     */
    data: XOR<StudentResponseTableUpdateInput, StudentResponseTableUncheckedUpdateInput>
    /**
     * Choose, which StudentResponseTable to update.
     */
    where: StudentResponseTableWhereUniqueInput
  }


  /**
   * StudentResponseTable updateMany
   */
  export type StudentResponseTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentResponseTables.
     */
    data: XOR<StudentResponseTableUpdateManyMutationInput, StudentResponseTableUncheckedUpdateManyInput>
    /**
     * Filter which StudentResponseTables to update
     */
    where?: StudentResponseTableWhereInput
  }


  /**
   * StudentResponseTable upsert
   */
  export type StudentResponseTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentResponseTable to update in case it exists.
     */
    where: StudentResponseTableWhereUniqueInput
    /**
     * In case the StudentResponseTable found by the `where` argument doesn't exist, create a new StudentResponseTable with this data.
     */
    create: XOR<StudentResponseTableCreateInput, StudentResponseTableUncheckedCreateInput>
    /**
     * In case the StudentResponseTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentResponseTableUpdateInput, StudentResponseTableUncheckedUpdateInput>
  }


  /**
   * StudentResponseTable delete
   */
  export type StudentResponseTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
    /**
     * Filter which StudentResponseTable to delete.
     */
    where: StudentResponseTableWhereUniqueInput
  }


  /**
   * StudentResponseTable deleteMany
   */
  export type StudentResponseTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentResponseTables to delete
     */
    where?: StudentResponseTableWhereInput
  }


  /**
   * StudentResponseTable without action
   */
  export type StudentResponseTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentResponseTable
     */
    select?: StudentResponseTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentResponseTableInclude<ExtArgs> | null
  }



  /**
   * Model NotesTable
   */

  export type AggregateNotesTable = {
    _count: NotesTableCountAggregateOutputType | null
    _avg: NotesTableAvgAggregateOutputType | null
    _sum: NotesTableSumAggregateOutputType | null
    _min: NotesTableMinAggregateOutputType | null
    _max: NotesTableMaxAggregateOutputType | null
  }

  export type NotesTableAvgAggregateOutputType = {
    id: number | null
    teacherId: number | null
    universityId: number | null
    branchId: number | null
    yearId: number | null
  }

  export type NotesTableSumAggregateOutputType = {
    id: number | null
    teacherId: number | null
    universityId: number | null
    branchId: number | null
    yearId: number | null
  }

  export type NotesTableMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    driveLink: string | null
    uploadedAt: Date | null
    teacherId: number | null
    universityId: number | null
    branchId: number | null
    yearId: number | null
  }

  export type NotesTableMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    driveLink: string | null
    uploadedAt: Date | null
    teacherId: number | null
    universityId: number | null
    branchId: number | null
    yearId: number | null
  }

  export type NotesTableCountAggregateOutputType = {
    id: number
    title: number
    description: number
    driveLink: number
    uploadedAt: number
    teacherId: number
    universityId: number
    branchId: number
    yearId: number
    _all: number
  }


  export type NotesTableAvgAggregateInputType = {
    id?: true
    teacherId?: true
    universityId?: true
    branchId?: true
    yearId?: true
  }

  export type NotesTableSumAggregateInputType = {
    id?: true
    teacherId?: true
    universityId?: true
    branchId?: true
    yearId?: true
  }

  export type NotesTableMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    driveLink?: true
    uploadedAt?: true
    teacherId?: true
    universityId?: true
    branchId?: true
    yearId?: true
  }

  export type NotesTableMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    driveLink?: true
    uploadedAt?: true
    teacherId?: true
    universityId?: true
    branchId?: true
    yearId?: true
  }

  export type NotesTableCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    driveLink?: true
    uploadedAt?: true
    teacherId?: true
    universityId?: true
    branchId?: true
    yearId?: true
    _all?: true
  }

  export type NotesTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotesTable to aggregate.
     */
    where?: NotesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesTables to fetch.
     */
    orderBy?: NotesTableOrderByWithRelationInput | NotesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotesTables
    **/
    _count?: true | NotesTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesTableMaxAggregateInputType
  }

  export type GetNotesTableAggregateType<T extends NotesTableAggregateArgs> = {
        [P in keyof T & keyof AggregateNotesTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotesTable[P]>
      : GetScalarType<T[P], AggregateNotesTable[P]>
  }




  export type NotesTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesTableWhereInput
    orderBy?: NotesTableOrderByWithAggregationInput | NotesTableOrderByWithAggregationInput[]
    by: NotesTableScalarFieldEnum[] | NotesTableScalarFieldEnum
    having?: NotesTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesTableCountAggregateInputType | true
    _avg?: NotesTableAvgAggregateInputType
    _sum?: NotesTableSumAggregateInputType
    _min?: NotesTableMinAggregateInputType
    _max?: NotesTableMaxAggregateInputType
  }

  export type NotesTableGroupByOutputType = {
    id: number
    title: string
    description: string
    driveLink: string
    uploadedAt: Date
    teacherId: number
    universityId: number
    branchId: number
    yearId: number
    _count: NotesTableCountAggregateOutputType | null
    _avg: NotesTableAvgAggregateOutputType | null
    _sum: NotesTableSumAggregateOutputType | null
    _min: NotesTableMinAggregateOutputType | null
    _max: NotesTableMaxAggregateOutputType | null
  }

  type GetNotesTableGroupByPayload<T extends NotesTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotesTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesTableGroupByOutputType[P]>
            : GetScalarType<T[P], NotesTableGroupByOutputType[P]>
        }
      >
    >


  export type NotesTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    driveLink?: boolean
    uploadedAt?: boolean
    teacherId?: boolean
    universityId?: boolean
    branchId?: boolean
    yearId?: boolean
    teacher?: boolean | TeacherTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notesTable"]>

  export type NotesTableSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    driveLink?: boolean
    uploadedAt?: boolean
    teacherId?: boolean
    universityId?: boolean
    branchId?: boolean
    yearId?: boolean
  }

  export type NotesTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
  }


  export type $NotesTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotesTable"
    objects: {
      teacher: Prisma.$TeacherTablePayload<ExtArgs>
      university: Prisma.$UniversityTablePayload<ExtArgs>
      branch: Prisma.$BranchTablePayload<ExtArgs>
      year: Prisma.$YearTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      driveLink: string
      uploadedAt: Date
      teacherId: number
      universityId: number
      branchId: number
      yearId: number
    }, ExtArgs["result"]["notesTable"]>
    composites: {}
  }


  type NotesTableGetPayload<S extends boolean | null | undefined | NotesTableDefaultArgs> = $Result.GetResult<Prisma.$NotesTablePayload, S>

  type NotesTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotesTableFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: NotesTableCountAggregateInputType | true
    }

  export interface NotesTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotesTable'], meta: { name: 'NotesTable' } }
    /**
     * Find zero or one NotesTable that matches the filter.
     * @param {NotesTableFindUniqueArgs} args - Arguments to find a NotesTable
     * @example
     * // Get one NotesTable
     * const notesTable = await prisma.notesTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotesTableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotesTableFindUniqueArgs<ExtArgs>>
    ): Prisma__NotesTableClient<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NotesTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotesTableFindUniqueOrThrowArgs} args - Arguments to find a NotesTable
     * @example
     * // Get one NotesTable
     * const notesTable = await prisma.notesTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotesTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotesTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotesTableClient<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NotesTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesTableFindFirstArgs} args - Arguments to find a NotesTable
     * @example
     * // Get one NotesTable
     * const notesTable = await prisma.notesTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotesTableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotesTableFindFirstArgs<ExtArgs>>
    ): Prisma__NotesTableClient<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NotesTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesTableFindFirstOrThrowArgs} args - Arguments to find a NotesTable
     * @example
     * // Get one NotesTable
     * const notesTable = await prisma.notesTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotesTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotesTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotesTableClient<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NotesTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotesTables
     * const notesTables = await prisma.notesTable.findMany()
     * 
     * // Get first 10 NotesTables
     * const notesTables = await prisma.notesTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesTableWithIdOnly = await prisma.notesTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotesTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotesTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NotesTable.
     * @param {NotesTableCreateArgs} args - Arguments to create a NotesTable.
     * @example
     * // Create one NotesTable
     * const NotesTable = await prisma.notesTable.create({
     *   data: {
     *     // ... data to create a NotesTable
     *   }
     * })
     * 
    **/
    create<T extends NotesTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotesTableCreateArgs<ExtArgs>>
    ): Prisma__NotesTableClient<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many NotesTables.
     *     @param {NotesTableCreateManyArgs} args - Arguments to create many NotesTables.
     *     @example
     *     // Create many NotesTables
     *     const notesTable = await prisma.notesTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotesTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotesTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NotesTable.
     * @param {NotesTableDeleteArgs} args - Arguments to delete one NotesTable.
     * @example
     * // Delete one NotesTable
     * const NotesTable = await prisma.notesTable.delete({
     *   where: {
     *     // ... filter to delete one NotesTable
     *   }
     * })
     * 
    **/
    delete<T extends NotesTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotesTableDeleteArgs<ExtArgs>>
    ): Prisma__NotesTableClient<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NotesTable.
     * @param {NotesTableUpdateArgs} args - Arguments to update one NotesTable.
     * @example
     * // Update one NotesTable
     * const notesTable = await prisma.notesTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotesTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotesTableUpdateArgs<ExtArgs>>
    ): Prisma__NotesTableClient<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NotesTables.
     * @param {NotesTableDeleteManyArgs} args - Arguments to filter NotesTables to delete.
     * @example
     * // Delete a few NotesTables
     * const { count } = await prisma.notesTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotesTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotesTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotesTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotesTables
     * const notesTable = await prisma.notesTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotesTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotesTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotesTable.
     * @param {NotesTableUpsertArgs} args - Arguments to update or create a NotesTable.
     * @example
     * // Update or create a NotesTable
     * const notesTable = await prisma.notesTable.upsert({
     *   create: {
     *     // ... data to create a NotesTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotesTable we want to update
     *   }
     * })
    **/
    upsert<T extends NotesTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotesTableUpsertArgs<ExtArgs>>
    ): Prisma__NotesTableClient<$Result.GetResult<Prisma.$NotesTablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NotesTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesTableCountArgs} args - Arguments to filter NotesTables to count.
     * @example
     * // Count the number of NotesTables
     * const count = await prisma.notesTable.count({
     *   where: {
     *     // ... the filter for the NotesTables we want to count
     *   }
     * })
    **/
    count<T extends NotesTableCountArgs>(
      args?: Subset<T, NotesTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotesTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesTableAggregateArgs>(args: Subset<T, NotesTableAggregateArgs>): Prisma.PrismaPromise<GetNotesTableAggregateType<T>>

    /**
     * Group by NotesTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotesTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotesTableGroupByArgs['orderBy'] }
        : { orderBy?: NotesTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotesTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotesTable model
   */
  readonly fields: NotesTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotesTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotesTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    teacher<T extends TeacherTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherTableDefaultArgs<ExtArgs>>): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    university<T extends UniversityTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTableDefaultArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    branch<T extends BranchTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchTableDefaultArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    year<T extends YearTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearTableDefaultArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NotesTable model
   */ 
  interface NotesTableFieldRefs {
    readonly id: FieldRef<"NotesTable", 'Int'>
    readonly title: FieldRef<"NotesTable", 'String'>
    readonly description: FieldRef<"NotesTable", 'String'>
    readonly driveLink: FieldRef<"NotesTable", 'String'>
    readonly uploadedAt: FieldRef<"NotesTable", 'DateTime'>
    readonly teacherId: FieldRef<"NotesTable", 'Int'>
    readonly universityId: FieldRef<"NotesTable", 'Int'>
    readonly branchId: FieldRef<"NotesTable", 'Int'>
    readonly yearId: FieldRef<"NotesTable", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * NotesTable findUnique
   */
  export type NotesTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    /**
     * Filter, which NotesTable to fetch.
     */
    where: NotesTableWhereUniqueInput
  }


  /**
   * NotesTable findUniqueOrThrow
   */
  export type NotesTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    /**
     * Filter, which NotesTable to fetch.
     */
    where: NotesTableWhereUniqueInput
  }


  /**
   * NotesTable findFirst
   */
  export type NotesTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    /**
     * Filter, which NotesTable to fetch.
     */
    where?: NotesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesTables to fetch.
     */
    orderBy?: NotesTableOrderByWithRelationInput | NotesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotesTables.
     */
    cursor?: NotesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotesTables.
     */
    distinct?: NotesTableScalarFieldEnum | NotesTableScalarFieldEnum[]
  }


  /**
   * NotesTable findFirstOrThrow
   */
  export type NotesTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    /**
     * Filter, which NotesTable to fetch.
     */
    where?: NotesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesTables to fetch.
     */
    orderBy?: NotesTableOrderByWithRelationInput | NotesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotesTables.
     */
    cursor?: NotesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotesTables.
     */
    distinct?: NotesTableScalarFieldEnum | NotesTableScalarFieldEnum[]
  }


  /**
   * NotesTable findMany
   */
  export type NotesTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    /**
     * Filter, which NotesTables to fetch.
     */
    where?: NotesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesTables to fetch.
     */
    orderBy?: NotesTableOrderByWithRelationInput | NotesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotesTables.
     */
    cursor?: NotesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesTables.
     */
    skip?: number
    distinct?: NotesTableScalarFieldEnum | NotesTableScalarFieldEnum[]
  }


  /**
   * NotesTable create
   */
  export type NotesTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    /**
     * The data needed to create a NotesTable.
     */
    data: XOR<NotesTableCreateInput, NotesTableUncheckedCreateInput>
  }


  /**
   * NotesTable createMany
   */
  export type NotesTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotesTables.
     */
    data: NotesTableCreateManyInput | NotesTableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * NotesTable update
   */
  export type NotesTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    /**
     * The data needed to update a NotesTable.
     */
    data: XOR<NotesTableUpdateInput, NotesTableUncheckedUpdateInput>
    /**
     * Choose, which NotesTable to update.
     */
    where: NotesTableWhereUniqueInput
  }


  /**
   * NotesTable updateMany
   */
  export type NotesTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotesTables.
     */
    data: XOR<NotesTableUpdateManyMutationInput, NotesTableUncheckedUpdateManyInput>
    /**
     * Filter which NotesTables to update
     */
    where?: NotesTableWhereInput
  }


  /**
   * NotesTable upsert
   */
  export type NotesTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    /**
     * The filter to search for the NotesTable to update in case it exists.
     */
    where: NotesTableWhereUniqueInput
    /**
     * In case the NotesTable found by the `where` argument doesn't exist, create a new NotesTable with this data.
     */
    create: XOR<NotesTableCreateInput, NotesTableUncheckedCreateInput>
    /**
     * In case the NotesTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotesTableUpdateInput, NotesTableUncheckedUpdateInput>
  }


  /**
   * NotesTable delete
   */
  export type NotesTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
    /**
     * Filter which NotesTable to delete.
     */
    where: NotesTableWhereUniqueInput
  }


  /**
   * NotesTable deleteMany
   */
  export type NotesTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotesTables to delete
     */
    where?: NotesTableWhereInput
  }


  /**
   * NotesTable without action
   */
  export type NotesTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesTable
     */
    select?: NotesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesTableInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UniversityTableScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address'
  };

  export type UniversityTableScalarFieldEnum = (typeof UniversityTableScalarFieldEnum)[keyof typeof UniversityTableScalarFieldEnum]


  export const BranchTableScalarFieldEnum: {
    id: 'id',
    Branchcode: 'Branchcode',
    Branchname: 'Branchname',
    universityId: 'universityId'
  };

  export type BranchTableScalarFieldEnum = (typeof BranchTableScalarFieldEnum)[keyof typeof BranchTableScalarFieldEnum]


  export const YearTableScalarFieldEnum: {
    id: 'id',
    name: 'name',
    year: 'year',
    universityId: 'universityId',
    branchId: 'branchId'
  };

  export type YearTableScalarFieldEnum = (typeof YearTableScalarFieldEnum)[keyof typeof YearTableScalarFieldEnum]


  export const StudentTableScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    password: 'password',
    PRN: 'PRN',
    branchId: 'branchId',
    universityId: 'universityId',
    yearId: 'yearId'
  };

  export type StudentTableScalarFieldEnum = (typeof StudentTableScalarFieldEnum)[keyof typeof StudentTableScalarFieldEnum]


  export const TeacherTableScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    password: 'password',
    branchId: 'branchId',
    universityId: 'universityId'
  };

  export type TeacherTableScalarFieldEnum = (typeof TeacherTableScalarFieldEnum)[keyof typeof TeacherTableScalarFieldEnum]


  export const TestTableScalarFieldEnum: {
    id: 'id',
    title: 'title',
    teacherID: 'teacherID',
    branchId: 'branchId',
    subject: 'subject',
    yearId: 'yearId',
    totalmarks: 'totalmarks',
    duration: 'duration',
    scheduledDate: 'scheduledDate'
  };

  export type TestTableScalarFieldEnum = (typeof TestTableScalarFieldEnum)[keyof typeof TestTableScalarFieldEnum]


  export const QuestionsTableScalarFieldEnum: {
    id: 'id',
    queText: 'queText',
    optionA: 'optionA',
    optionB: 'optionB',
    optionC: 'optionC',
    optionD: 'optionD',
    correctOption: 'correctOption',
    maxMark: 'maxMark',
    testId: 'testId'
  };

  export type QuestionsTableScalarFieldEnum = (typeof QuestionsTableScalarFieldEnum)[keyof typeof QuestionsTableScalarFieldEnum]


  export const ResultTableScalarFieldEnum: {
    id: 'id',
    totalmarks: 'totalmarks',
    scoredmarks: 'scoredmarks',
    cheated: 'cheated',
    testId: 'testId',
    studentId: 'studentId',
    tabSwitchCount: 'tabSwitchCount',
    fullScreenExits: 'fullScreenExits',
    maxFaceCount: 'maxFaceCount'
  };

  export type ResultTableScalarFieldEnum = (typeof ResultTableScalarFieldEnum)[keyof typeof ResultTableScalarFieldEnum]


  export const StudentResponseTableScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    testId: 'testId',
    questionId: 'questionId',
    selectedOption: 'selectedOption',
    isCorrect: 'isCorrect'
  };

  export type StudentResponseTableScalarFieldEnum = (typeof StudentResponseTableScalarFieldEnum)[keyof typeof StudentResponseTableScalarFieldEnum]


  export const NotesTableScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    driveLink: 'driveLink',
    uploadedAt: 'uploadedAt',
    teacherId: 'teacherId',
    universityId: 'universityId',
    branchId: 'branchId',
    yearId: 'yearId'
  };

  export type NotesTableScalarFieldEnum = (typeof NotesTableScalarFieldEnum)[keyof typeof NotesTableScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UniversityTableWhereInput = {
    AND?: UniversityTableWhereInput | UniversityTableWhereInput[]
    OR?: UniversityTableWhereInput[]
    NOT?: UniversityTableWhereInput | UniversityTableWhereInput[]
    id?: IntFilter<"UniversityTable"> | number
    name?: StringFilter<"UniversityTable"> | string
    address?: StringFilter<"UniversityTable"> | string
    branches?: BranchTableListRelationFilter
    students?: StudentTableListRelationFilter
    teachers?: TeacherTableListRelationFilter
    years?: YearTableListRelationFilter
    notes?: NotesTableListRelationFilter
  }

  export type UniversityTableOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    branches?: BranchTableOrderByRelationAggregateInput
    students?: StudentTableOrderByRelationAggregateInput
    teachers?: TeacherTableOrderByRelationAggregateInput
    years?: YearTableOrderByRelationAggregateInput
    notes?: NotesTableOrderByRelationAggregateInput
  }

  export type UniversityTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UniversityTableWhereInput | UniversityTableWhereInput[]
    OR?: UniversityTableWhereInput[]
    NOT?: UniversityTableWhereInput | UniversityTableWhereInput[]
    name?: StringFilter<"UniversityTable"> | string
    address?: StringFilter<"UniversityTable"> | string
    branches?: BranchTableListRelationFilter
    students?: StudentTableListRelationFilter
    teachers?: TeacherTableListRelationFilter
    years?: YearTableListRelationFilter
    notes?: NotesTableListRelationFilter
  }, "id">

  export type UniversityTableOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    _count?: UniversityTableCountOrderByAggregateInput
    _avg?: UniversityTableAvgOrderByAggregateInput
    _max?: UniversityTableMaxOrderByAggregateInput
    _min?: UniversityTableMinOrderByAggregateInput
    _sum?: UniversityTableSumOrderByAggregateInput
  }

  export type UniversityTableScalarWhereWithAggregatesInput = {
    AND?: UniversityTableScalarWhereWithAggregatesInput | UniversityTableScalarWhereWithAggregatesInput[]
    OR?: UniversityTableScalarWhereWithAggregatesInput[]
    NOT?: UniversityTableScalarWhereWithAggregatesInput | UniversityTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UniversityTable"> | number
    name?: StringWithAggregatesFilter<"UniversityTable"> | string
    address?: StringWithAggregatesFilter<"UniversityTable"> | string
  }

  export type BranchTableWhereInput = {
    AND?: BranchTableWhereInput | BranchTableWhereInput[]
    OR?: BranchTableWhereInput[]
    NOT?: BranchTableWhereInput | BranchTableWhereInput[]
    id?: IntFilter<"BranchTable"> | number
    Branchcode?: StringFilter<"BranchTable"> | string
    Branchname?: StringFilter<"BranchTable"> | string
    universityId?: IntFilter<"BranchTable"> | number
    university?: XOR<UniversityTableRelationFilter, UniversityTableWhereInput>
    students?: StudentTableListRelationFilter
    teachers?: TeacherTableListRelationFilter
    tests?: TestTableListRelationFilter
    years?: YearTableListRelationFilter
    notes?: NotesTableListRelationFilter
  }

  export type BranchTableOrderByWithRelationInput = {
    id?: SortOrder
    Branchcode?: SortOrder
    Branchname?: SortOrder
    universityId?: SortOrder
    university?: UniversityTableOrderByWithRelationInput
    students?: StudentTableOrderByRelationAggregateInput
    teachers?: TeacherTableOrderByRelationAggregateInput
    tests?: TestTableOrderByRelationAggregateInput
    years?: YearTableOrderByRelationAggregateInput
    notes?: NotesTableOrderByRelationAggregateInput
  }

  export type BranchTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BranchTableWhereInput | BranchTableWhereInput[]
    OR?: BranchTableWhereInput[]
    NOT?: BranchTableWhereInput | BranchTableWhereInput[]
    Branchcode?: StringFilter<"BranchTable"> | string
    Branchname?: StringFilter<"BranchTable"> | string
    universityId?: IntFilter<"BranchTable"> | number
    university?: XOR<UniversityTableRelationFilter, UniversityTableWhereInput>
    students?: StudentTableListRelationFilter
    teachers?: TeacherTableListRelationFilter
    tests?: TestTableListRelationFilter
    years?: YearTableListRelationFilter
    notes?: NotesTableListRelationFilter
  }, "id">

  export type BranchTableOrderByWithAggregationInput = {
    id?: SortOrder
    Branchcode?: SortOrder
    Branchname?: SortOrder
    universityId?: SortOrder
    _count?: BranchTableCountOrderByAggregateInput
    _avg?: BranchTableAvgOrderByAggregateInput
    _max?: BranchTableMaxOrderByAggregateInput
    _min?: BranchTableMinOrderByAggregateInput
    _sum?: BranchTableSumOrderByAggregateInput
  }

  export type BranchTableScalarWhereWithAggregatesInput = {
    AND?: BranchTableScalarWhereWithAggregatesInput | BranchTableScalarWhereWithAggregatesInput[]
    OR?: BranchTableScalarWhereWithAggregatesInput[]
    NOT?: BranchTableScalarWhereWithAggregatesInput | BranchTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BranchTable"> | number
    Branchcode?: StringWithAggregatesFilter<"BranchTable"> | string
    Branchname?: StringWithAggregatesFilter<"BranchTable"> | string
    universityId?: IntWithAggregatesFilter<"BranchTable"> | number
  }

  export type YearTableWhereInput = {
    AND?: YearTableWhereInput | YearTableWhereInput[]
    OR?: YearTableWhereInput[]
    NOT?: YearTableWhereInput | YearTableWhereInput[]
    id?: IntFilter<"YearTable"> | number
    name?: StringFilter<"YearTable"> | string
    year?: IntFilter<"YearTable"> | number
    universityId?: IntFilter<"YearTable"> | number
    branchId?: IntFilter<"YearTable"> | number
    university?: XOR<UniversityTableRelationFilter, UniversityTableWhereInput>
    branch?: XOR<BranchTableRelationFilter, BranchTableWhereInput>
    students?: StudentTableListRelationFilter
    tests?: TestTableListRelationFilter
    notes?: NotesTableListRelationFilter
  }

  export type YearTableOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
    university?: UniversityTableOrderByWithRelationInput
    branch?: BranchTableOrderByWithRelationInput
    students?: StudentTableOrderByRelationAggregateInput
    tests?: TestTableOrderByRelationAggregateInput
    notes?: NotesTableOrderByRelationAggregateInput
  }

  export type YearTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: YearTableWhereInput | YearTableWhereInput[]
    OR?: YearTableWhereInput[]
    NOT?: YearTableWhereInput | YearTableWhereInput[]
    name?: StringFilter<"YearTable"> | string
    year?: IntFilter<"YearTable"> | number
    universityId?: IntFilter<"YearTable"> | number
    branchId?: IntFilter<"YearTable"> | number
    university?: XOR<UniversityTableRelationFilter, UniversityTableWhereInput>
    branch?: XOR<BranchTableRelationFilter, BranchTableWhereInput>
    students?: StudentTableListRelationFilter
    tests?: TestTableListRelationFilter
    notes?: NotesTableListRelationFilter
  }, "id">

  export type YearTableOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
    _count?: YearTableCountOrderByAggregateInput
    _avg?: YearTableAvgOrderByAggregateInput
    _max?: YearTableMaxOrderByAggregateInput
    _min?: YearTableMinOrderByAggregateInput
    _sum?: YearTableSumOrderByAggregateInput
  }

  export type YearTableScalarWhereWithAggregatesInput = {
    AND?: YearTableScalarWhereWithAggregatesInput | YearTableScalarWhereWithAggregatesInput[]
    OR?: YearTableScalarWhereWithAggregatesInput[]
    NOT?: YearTableScalarWhereWithAggregatesInput | YearTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"YearTable"> | number
    name?: StringWithAggregatesFilter<"YearTable"> | string
    year?: IntWithAggregatesFilter<"YearTable"> | number
    universityId?: IntWithAggregatesFilter<"YearTable"> | number
    branchId?: IntWithAggregatesFilter<"YearTable"> | number
  }

  export type StudentTableWhereInput = {
    AND?: StudentTableWhereInput | StudentTableWhereInput[]
    OR?: StudentTableWhereInput[]
    NOT?: StudentTableWhereInput | StudentTableWhereInput[]
    id?: IntFilter<"StudentTable"> | number
    firstname?: StringFilter<"StudentTable"> | string
    lastname?: StringFilter<"StudentTable"> | string
    email?: StringFilter<"StudentTable"> | string
    password?: StringFilter<"StudentTable"> | string
    PRN?: StringFilter<"StudentTable"> | string
    branchId?: IntFilter<"StudentTable"> | number
    universityId?: IntFilter<"StudentTable"> | number
    yearId?: IntFilter<"StudentTable"> | number
    branch?: XOR<BranchTableRelationFilter, BranchTableWhereInput>
    university?: XOR<UniversityTableRelationFilter, UniversityTableWhereInput>
    year?: XOR<YearTableRelationFilter, YearTableWhereInput>
    results?: ResultTableListRelationFilter
    responses?: StudentResponseTableListRelationFilter
  }

  export type StudentTableOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    PRN?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
    branch?: BranchTableOrderByWithRelationInput
    university?: UniversityTableOrderByWithRelationInput
    year?: YearTableOrderByWithRelationInput
    results?: ResultTableOrderByRelationAggregateInput
    responses?: StudentResponseTableOrderByRelationAggregateInput
  }

  export type StudentTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: StudentTableWhereInput | StudentTableWhereInput[]
    OR?: StudentTableWhereInput[]
    NOT?: StudentTableWhereInput | StudentTableWhereInput[]
    firstname?: StringFilter<"StudentTable"> | string
    lastname?: StringFilter<"StudentTable"> | string
    password?: StringFilter<"StudentTable"> | string
    PRN?: StringFilter<"StudentTable"> | string
    branchId?: IntFilter<"StudentTable"> | number
    universityId?: IntFilter<"StudentTable"> | number
    yearId?: IntFilter<"StudentTable"> | number
    branch?: XOR<BranchTableRelationFilter, BranchTableWhereInput>
    university?: XOR<UniversityTableRelationFilter, UniversityTableWhereInput>
    year?: XOR<YearTableRelationFilter, YearTableWhereInput>
    results?: ResultTableListRelationFilter
    responses?: StudentResponseTableListRelationFilter
  }, "id" | "email">

  export type StudentTableOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    PRN?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
    _count?: StudentTableCountOrderByAggregateInput
    _avg?: StudentTableAvgOrderByAggregateInput
    _max?: StudentTableMaxOrderByAggregateInput
    _min?: StudentTableMinOrderByAggregateInput
    _sum?: StudentTableSumOrderByAggregateInput
  }

  export type StudentTableScalarWhereWithAggregatesInput = {
    AND?: StudentTableScalarWhereWithAggregatesInput | StudentTableScalarWhereWithAggregatesInput[]
    OR?: StudentTableScalarWhereWithAggregatesInput[]
    NOT?: StudentTableScalarWhereWithAggregatesInput | StudentTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentTable"> | number
    firstname?: StringWithAggregatesFilter<"StudentTable"> | string
    lastname?: StringWithAggregatesFilter<"StudentTable"> | string
    email?: StringWithAggregatesFilter<"StudentTable"> | string
    password?: StringWithAggregatesFilter<"StudentTable"> | string
    PRN?: StringWithAggregatesFilter<"StudentTable"> | string
    branchId?: IntWithAggregatesFilter<"StudentTable"> | number
    universityId?: IntWithAggregatesFilter<"StudentTable"> | number
    yearId?: IntWithAggregatesFilter<"StudentTable"> | number
  }

  export type TeacherTableWhereInput = {
    AND?: TeacherTableWhereInput | TeacherTableWhereInput[]
    OR?: TeacherTableWhereInput[]
    NOT?: TeacherTableWhereInput | TeacherTableWhereInput[]
    id?: IntFilter<"TeacherTable"> | number
    firstname?: StringFilter<"TeacherTable"> | string
    lastname?: StringFilter<"TeacherTable"> | string
    email?: StringFilter<"TeacherTable"> | string
    password?: StringFilter<"TeacherTable"> | string
    branchId?: IntFilter<"TeacherTable"> | number
    universityId?: IntFilter<"TeacherTable"> | number
    branch?: XOR<BranchTableRelationFilter, BranchTableWhereInput>
    university?: XOR<UniversityTableRelationFilter, UniversityTableWhereInput>
    tests?: TestTableListRelationFilter
    notes?: NotesTableListRelationFilter
  }

  export type TeacherTableOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    branch?: BranchTableOrderByWithRelationInput
    university?: UniversityTableOrderByWithRelationInput
    tests?: TestTableOrderByRelationAggregateInput
    notes?: NotesTableOrderByRelationAggregateInput
  }

  export type TeacherTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: TeacherTableWhereInput | TeacherTableWhereInput[]
    OR?: TeacherTableWhereInput[]
    NOT?: TeacherTableWhereInput | TeacherTableWhereInput[]
    firstname?: StringFilter<"TeacherTable"> | string
    lastname?: StringFilter<"TeacherTable"> | string
    password?: StringFilter<"TeacherTable"> | string
    branchId?: IntFilter<"TeacherTable"> | number
    universityId?: IntFilter<"TeacherTable"> | number
    branch?: XOR<BranchTableRelationFilter, BranchTableWhereInput>
    university?: XOR<UniversityTableRelationFilter, UniversityTableWhereInput>
    tests?: TestTableListRelationFilter
    notes?: NotesTableListRelationFilter
  }, "id" | "email">

  export type TeacherTableOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    _count?: TeacherTableCountOrderByAggregateInput
    _avg?: TeacherTableAvgOrderByAggregateInput
    _max?: TeacherTableMaxOrderByAggregateInput
    _min?: TeacherTableMinOrderByAggregateInput
    _sum?: TeacherTableSumOrderByAggregateInput
  }

  export type TeacherTableScalarWhereWithAggregatesInput = {
    AND?: TeacherTableScalarWhereWithAggregatesInput | TeacherTableScalarWhereWithAggregatesInput[]
    OR?: TeacherTableScalarWhereWithAggregatesInput[]
    NOT?: TeacherTableScalarWhereWithAggregatesInput | TeacherTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeacherTable"> | number
    firstname?: StringWithAggregatesFilter<"TeacherTable"> | string
    lastname?: StringWithAggregatesFilter<"TeacherTable"> | string
    email?: StringWithAggregatesFilter<"TeacherTable"> | string
    password?: StringWithAggregatesFilter<"TeacherTable"> | string
    branchId?: IntWithAggregatesFilter<"TeacherTable"> | number
    universityId?: IntWithAggregatesFilter<"TeacherTable"> | number
  }

  export type TestTableWhereInput = {
    AND?: TestTableWhereInput | TestTableWhereInput[]
    OR?: TestTableWhereInput[]
    NOT?: TestTableWhereInput | TestTableWhereInput[]
    id?: IntFilter<"TestTable"> | number
    title?: StringFilter<"TestTable"> | string
    teacherID?: IntFilter<"TestTable"> | number
    branchId?: IntFilter<"TestTable"> | number
    subject?: StringFilter<"TestTable"> | string
    yearId?: IntFilter<"TestTable"> | number
    totalmarks?: IntFilter<"TestTable"> | number
    duration?: IntFilter<"TestTable"> | number
    scheduledDate?: DateTimeFilter<"TestTable"> | Date | string
    teacher?: XOR<TeacherTableRelationFilter, TeacherTableWhereInput>
    branch?: XOR<BranchTableRelationFilter, BranchTableWhereInput>
    year?: XOR<YearTableRelationFilter, YearTableWhereInput>
    questions?: QuestionsTableListRelationFilter
    results?: ResultTableListRelationFilter
    responses?: StudentResponseTableListRelationFilter
  }

  export type TestTableOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    subject?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
    scheduledDate?: SortOrder
    teacher?: TeacherTableOrderByWithRelationInput
    branch?: BranchTableOrderByWithRelationInput
    year?: YearTableOrderByWithRelationInput
    questions?: QuestionsTableOrderByRelationAggregateInput
    results?: ResultTableOrderByRelationAggregateInput
    responses?: StudentResponseTableOrderByRelationAggregateInput
  }

  export type TestTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestTableWhereInput | TestTableWhereInput[]
    OR?: TestTableWhereInput[]
    NOT?: TestTableWhereInput | TestTableWhereInput[]
    title?: StringFilter<"TestTable"> | string
    teacherID?: IntFilter<"TestTable"> | number
    branchId?: IntFilter<"TestTable"> | number
    subject?: StringFilter<"TestTable"> | string
    yearId?: IntFilter<"TestTable"> | number
    totalmarks?: IntFilter<"TestTable"> | number
    duration?: IntFilter<"TestTable"> | number
    scheduledDate?: DateTimeFilter<"TestTable"> | Date | string
    teacher?: XOR<TeacherTableRelationFilter, TeacherTableWhereInput>
    branch?: XOR<BranchTableRelationFilter, BranchTableWhereInput>
    year?: XOR<YearTableRelationFilter, YearTableWhereInput>
    questions?: QuestionsTableListRelationFilter
    results?: ResultTableListRelationFilter
    responses?: StudentResponseTableListRelationFilter
  }, "id">

  export type TestTableOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    subject?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
    scheduledDate?: SortOrder
    _count?: TestTableCountOrderByAggregateInput
    _avg?: TestTableAvgOrderByAggregateInput
    _max?: TestTableMaxOrderByAggregateInput
    _min?: TestTableMinOrderByAggregateInput
    _sum?: TestTableSumOrderByAggregateInput
  }

  export type TestTableScalarWhereWithAggregatesInput = {
    AND?: TestTableScalarWhereWithAggregatesInput | TestTableScalarWhereWithAggregatesInput[]
    OR?: TestTableScalarWhereWithAggregatesInput[]
    NOT?: TestTableScalarWhereWithAggregatesInput | TestTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestTable"> | number
    title?: StringWithAggregatesFilter<"TestTable"> | string
    teacherID?: IntWithAggregatesFilter<"TestTable"> | number
    branchId?: IntWithAggregatesFilter<"TestTable"> | number
    subject?: StringWithAggregatesFilter<"TestTable"> | string
    yearId?: IntWithAggregatesFilter<"TestTable"> | number
    totalmarks?: IntWithAggregatesFilter<"TestTable"> | number
    duration?: IntWithAggregatesFilter<"TestTable"> | number
    scheduledDate?: DateTimeWithAggregatesFilter<"TestTable"> | Date | string
  }

  export type QuestionsTableWhereInput = {
    AND?: QuestionsTableWhereInput | QuestionsTableWhereInput[]
    OR?: QuestionsTableWhereInput[]
    NOT?: QuestionsTableWhereInput | QuestionsTableWhereInput[]
    id?: IntFilter<"QuestionsTable"> | number
    queText?: StringFilter<"QuestionsTable"> | string
    optionA?: StringFilter<"QuestionsTable"> | string
    optionB?: StringFilter<"QuestionsTable"> | string
    optionC?: StringFilter<"QuestionsTable"> | string
    optionD?: StringFilter<"QuestionsTable"> | string
    correctOption?: StringFilter<"QuestionsTable"> | string
    maxMark?: IntFilter<"QuestionsTable"> | number
    testId?: IntFilter<"QuestionsTable"> | number
    test?: XOR<TestTableRelationFilter, TestTableWhereInput>
    responses?: StudentResponseTableListRelationFilter
  }

  export type QuestionsTableOrderByWithRelationInput = {
    id?: SortOrder
    queText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
    test?: TestTableOrderByWithRelationInput
    responses?: StudentResponseTableOrderByRelationAggregateInput
  }

  export type QuestionsTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestionsTableWhereInput | QuestionsTableWhereInput[]
    OR?: QuestionsTableWhereInput[]
    NOT?: QuestionsTableWhereInput | QuestionsTableWhereInput[]
    queText?: StringFilter<"QuestionsTable"> | string
    optionA?: StringFilter<"QuestionsTable"> | string
    optionB?: StringFilter<"QuestionsTable"> | string
    optionC?: StringFilter<"QuestionsTable"> | string
    optionD?: StringFilter<"QuestionsTable"> | string
    correctOption?: StringFilter<"QuestionsTable"> | string
    maxMark?: IntFilter<"QuestionsTable"> | number
    testId?: IntFilter<"QuestionsTable"> | number
    test?: XOR<TestTableRelationFilter, TestTableWhereInput>
    responses?: StudentResponseTableListRelationFilter
  }, "id">

  export type QuestionsTableOrderByWithAggregationInput = {
    id?: SortOrder
    queText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
    _count?: QuestionsTableCountOrderByAggregateInput
    _avg?: QuestionsTableAvgOrderByAggregateInput
    _max?: QuestionsTableMaxOrderByAggregateInput
    _min?: QuestionsTableMinOrderByAggregateInput
    _sum?: QuestionsTableSumOrderByAggregateInput
  }

  export type QuestionsTableScalarWhereWithAggregatesInput = {
    AND?: QuestionsTableScalarWhereWithAggregatesInput | QuestionsTableScalarWhereWithAggregatesInput[]
    OR?: QuestionsTableScalarWhereWithAggregatesInput[]
    NOT?: QuestionsTableScalarWhereWithAggregatesInput | QuestionsTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuestionsTable"> | number
    queText?: StringWithAggregatesFilter<"QuestionsTable"> | string
    optionA?: StringWithAggregatesFilter<"QuestionsTable"> | string
    optionB?: StringWithAggregatesFilter<"QuestionsTable"> | string
    optionC?: StringWithAggregatesFilter<"QuestionsTable"> | string
    optionD?: StringWithAggregatesFilter<"QuestionsTable"> | string
    correctOption?: StringWithAggregatesFilter<"QuestionsTable"> | string
    maxMark?: IntWithAggregatesFilter<"QuestionsTable"> | number
    testId?: IntWithAggregatesFilter<"QuestionsTable"> | number
  }

  export type ResultTableWhereInput = {
    AND?: ResultTableWhereInput | ResultTableWhereInput[]
    OR?: ResultTableWhereInput[]
    NOT?: ResultTableWhereInput | ResultTableWhereInput[]
    id?: IntFilter<"ResultTable"> | number
    totalmarks?: IntFilter<"ResultTable"> | number
    scoredmarks?: IntFilter<"ResultTable"> | number
    cheated?: BoolFilter<"ResultTable"> | boolean
    testId?: IntFilter<"ResultTable"> | number
    studentId?: IntFilter<"ResultTable"> | number
    tabSwitchCount?: IntFilter<"ResultTable"> | number
    fullScreenExits?: IntFilter<"ResultTable"> | number
    maxFaceCount?: IntFilter<"ResultTable"> | number
    test?: XOR<TestTableRelationFilter, TestTableWhereInput>
    student?: XOR<StudentTableRelationFilter, StudentTableWhereInput>
  }

  export type ResultTableOrderByWithRelationInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    cheated?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    tabSwitchCount?: SortOrder
    fullScreenExits?: SortOrder
    maxFaceCount?: SortOrder
    test?: TestTableOrderByWithRelationInput
    student?: StudentTableOrderByWithRelationInput
  }

  export type ResultTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResultTableWhereInput | ResultTableWhereInput[]
    OR?: ResultTableWhereInput[]
    NOT?: ResultTableWhereInput | ResultTableWhereInput[]
    totalmarks?: IntFilter<"ResultTable"> | number
    scoredmarks?: IntFilter<"ResultTable"> | number
    cheated?: BoolFilter<"ResultTable"> | boolean
    testId?: IntFilter<"ResultTable"> | number
    studentId?: IntFilter<"ResultTable"> | number
    tabSwitchCount?: IntFilter<"ResultTable"> | number
    fullScreenExits?: IntFilter<"ResultTable"> | number
    maxFaceCount?: IntFilter<"ResultTable"> | number
    test?: XOR<TestTableRelationFilter, TestTableWhereInput>
    student?: XOR<StudentTableRelationFilter, StudentTableWhereInput>
  }, "id">

  export type ResultTableOrderByWithAggregationInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    cheated?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    tabSwitchCount?: SortOrder
    fullScreenExits?: SortOrder
    maxFaceCount?: SortOrder
    _count?: ResultTableCountOrderByAggregateInput
    _avg?: ResultTableAvgOrderByAggregateInput
    _max?: ResultTableMaxOrderByAggregateInput
    _min?: ResultTableMinOrderByAggregateInput
    _sum?: ResultTableSumOrderByAggregateInput
  }

  export type ResultTableScalarWhereWithAggregatesInput = {
    AND?: ResultTableScalarWhereWithAggregatesInput | ResultTableScalarWhereWithAggregatesInput[]
    OR?: ResultTableScalarWhereWithAggregatesInput[]
    NOT?: ResultTableScalarWhereWithAggregatesInput | ResultTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ResultTable"> | number
    totalmarks?: IntWithAggregatesFilter<"ResultTable"> | number
    scoredmarks?: IntWithAggregatesFilter<"ResultTable"> | number
    cheated?: BoolWithAggregatesFilter<"ResultTable"> | boolean
    testId?: IntWithAggregatesFilter<"ResultTable"> | number
    studentId?: IntWithAggregatesFilter<"ResultTable"> | number
    tabSwitchCount?: IntWithAggregatesFilter<"ResultTable"> | number
    fullScreenExits?: IntWithAggregatesFilter<"ResultTable"> | number
    maxFaceCount?: IntWithAggregatesFilter<"ResultTable"> | number
  }

  export type StudentResponseTableWhereInput = {
    AND?: StudentResponseTableWhereInput | StudentResponseTableWhereInput[]
    OR?: StudentResponseTableWhereInput[]
    NOT?: StudentResponseTableWhereInput | StudentResponseTableWhereInput[]
    id?: IntFilter<"StudentResponseTable"> | number
    studentId?: IntFilter<"StudentResponseTable"> | number
    testId?: IntFilter<"StudentResponseTable"> | number
    questionId?: IntFilter<"StudentResponseTable"> | number
    selectedOption?: StringFilter<"StudentResponseTable"> | string
    isCorrect?: BoolFilter<"StudentResponseTable"> | boolean
    student?: XOR<StudentTableRelationFilter, StudentTableWhereInput>
    test?: XOR<TestTableRelationFilter, TestTableWhereInput>
    question?: XOR<QuestionsTableRelationFilter, QuestionsTableWhereInput>
  }

  export type StudentResponseTableOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    testId?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
    student?: StudentTableOrderByWithRelationInput
    test?: TestTableOrderByWithRelationInput
    question?: QuestionsTableOrderByWithRelationInput
  }

  export type StudentResponseTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentResponseTableWhereInput | StudentResponseTableWhereInput[]
    OR?: StudentResponseTableWhereInput[]
    NOT?: StudentResponseTableWhereInput | StudentResponseTableWhereInput[]
    studentId?: IntFilter<"StudentResponseTable"> | number
    testId?: IntFilter<"StudentResponseTable"> | number
    questionId?: IntFilter<"StudentResponseTable"> | number
    selectedOption?: StringFilter<"StudentResponseTable"> | string
    isCorrect?: BoolFilter<"StudentResponseTable"> | boolean
    student?: XOR<StudentTableRelationFilter, StudentTableWhereInput>
    test?: XOR<TestTableRelationFilter, TestTableWhereInput>
    question?: XOR<QuestionsTableRelationFilter, QuestionsTableWhereInput>
  }, "id">

  export type StudentResponseTableOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    testId?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
    _count?: StudentResponseTableCountOrderByAggregateInput
    _avg?: StudentResponseTableAvgOrderByAggregateInput
    _max?: StudentResponseTableMaxOrderByAggregateInput
    _min?: StudentResponseTableMinOrderByAggregateInput
    _sum?: StudentResponseTableSumOrderByAggregateInput
  }

  export type StudentResponseTableScalarWhereWithAggregatesInput = {
    AND?: StudentResponseTableScalarWhereWithAggregatesInput | StudentResponseTableScalarWhereWithAggregatesInput[]
    OR?: StudentResponseTableScalarWhereWithAggregatesInput[]
    NOT?: StudentResponseTableScalarWhereWithAggregatesInput | StudentResponseTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentResponseTable"> | number
    studentId?: IntWithAggregatesFilter<"StudentResponseTable"> | number
    testId?: IntWithAggregatesFilter<"StudentResponseTable"> | number
    questionId?: IntWithAggregatesFilter<"StudentResponseTable"> | number
    selectedOption?: StringWithAggregatesFilter<"StudentResponseTable"> | string
    isCorrect?: BoolWithAggregatesFilter<"StudentResponseTable"> | boolean
  }

  export type NotesTableWhereInput = {
    AND?: NotesTableWhereInput | NotesTableWhereInput[]
    OR?: NotesTableWhereInput[]
    NOT?: NotesTableWhereInput | NotesTableWhereInput[]
    id?: IntFilter<"NotesTable"> | number
    title?: StringFilter<"NotesTable"> | string
    description?: StringFilter<"NotesTable"> | string
    driveLink?: StringFilter<"NotesTable"> | string
    uploadedAt?: DateTimeFilter<"NotesTable"> | Date | string
    teacherId?: IntFilter<"NotesTable"> | number
    universityId?: IntFilter<"NotesTable"> | number
    branchId?: IntFilter<"NotesTable"> | number
    yearId?: IntFilter<"NotesTable"> | number
    teacher?: XOR<TeacherTableRelationFilter, TeacherTableWhereInput>
    university?: XOR<UniversityTableRelationFilter, UniversityTableWhereInput>
    branch?: XOR<BranchTableRelationFilter, BranchTableWhereInput>
    year?: XOR<YearTableRelationFilter, YearTableWhereInput>
  }

  export type NotesTableOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    driveLink?: SortOrder
    uploadedAt?: SortOrder
    teacherId?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
    yearId?: SortOrder
    teacher?: TeacherTableOrderByWithRelationInput
    university?: UniversityTableOrderByWithRelationInput
    branch?: BranchTableOrderByWithRelationInput
    year?: YearTableOrderByWithRelationInput
  }

  export type NotesTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotesTableWhereInput | NotesTableWhereInput[]
    OR?: NotesTableWhereInput[]
    NOT?: NotesTableWhereInput | NotesTableWhereInput[]
    title?: StringFilter<"NotesTable"> | string
    description?: StringFilter<"NotesTable"> | string
    driveLink?: StringFilter<"NotesTable"> | string
    uploadedAt?: DateTimeFilter<"NotesTable"> | Date | string
    teacherId?: IntFilter<"NotesTable"> | number
    universityId?: IntFilter<"NotesTable"> | number
    branchId?: IntFilter<"NotesTable"> | number
    yearId?: IntFilter<"NotesTable"> | number
    teacher?: XOR<TeacherTableRelationFilter, TeacherTableWhereInput>
    university?: XOR<UniversityTableRelationFilter, UniversityTableWhereInput>
    branch?: XOR<BranchTableRelationFilter, BranchTableWhereInput>
    year?: XOR<YearTableRelationFilter, YearTableWhereInput>
  }, "id">

  export type NotesTableOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    driveLink?: SortOrder
    uploadedAt?: SortOrder
    teacherId?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
    yearId?: SortOrder
    _count?: NotesTableCountOrderByAggregateInput
    _avg?: NotesTableAvgOrderByAggregateInput
    _max?: NotesTableMaxOrderByAggregateInput
    _min?: NotesTableMinOrderByAggregateInput
    _sum?: NotesTableSumOrderByAggregateInput
  }

  export type NotesTableScalarWhereWithAggregatesInput = {
    AND?: NotesTableScalarWhereWithAggregatesInput | NotesTableScalarWhereWithAggregatesInput[]
    OR?: NotesTableScalarWhereWithAggregatesInput[]
    NOT?: NotesTableScalarWhereWithAggregatesInput | NotesTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotesTable"> | number
    title?: StringWithAggregatesFilter<"NotesTable"> | string
    description?: StringWithAggregatesFilter<"NotesTable"> | string
    driveLink?: StringWithAggregatesFilter<"NotesTable"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"NotesTable"> | Date | string
    teacherId?: IntWithAggregatesFilter<"NotesTable"> | number
    universityId?: IntWithAggregatesFilter<"NotesTable"> | number
    branchId?: IntWithAggregatesFilter<"NotesTable"> | number
    yearId?: IntWithAggregatesFilter<"NotesTable"> | number
  }

  export type UniversityTableCreateInput = {
    name: string
    address: string
    branches?: BranchTableCreateNestedManyWithoutUniversityInput
    students?: StudentTableCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableCreateNestedManyWithoutUniversityInput
    years?: YearTableCreateNestedManyWithoutUniversityInput
    notes?: NotesTableCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    branches?: BranchTableUncheckedCreateNestedManyWithoutUniversityInput
    students?: StudentTableUncheckedCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutUniversityInput
    years?: YearTableUncheckedCreateNestedManyWithoutUniversityInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUpdateManyWithoutUniversityNestedInput
    years?: YearTableUpdateManyWithoutUniversityNestedInput
    notes?: NotesTableUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUncheckedUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUncheckedUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutUniversityNestedInput
    years?: YearTableUncheckedUpdateManyWithoutUniversityNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableCreateManyInput = {
    id?: number
    name: string
    address: string
  }

  export type UniversityTableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type UniversityTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type BranchTableCreateInput = {
    Branchcode: string
    Branchname: string
    university: UniversityTableCreateNestedOneWithoutBranchesInput
    students?: StudentTableCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableCreateNestedManyWithoutBranchInput
    tests?: TestTableCreateNestedManyWithoutBranchInput
    years?: YearTableCreateNestedManyWithoutBranchInput
    notes?: NotesTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutBranchInput
    tests?: TestTableUncheckedCreateNestedManyWithoutBranchInput
    years?: YearTableUncheckedCreateNestedManyWithoutBranchInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUpdateInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutBranchesNestedInput
    students?: StudentTableUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUpdateManyWithoutBranchNestedInput
    tests?: TestTableUpdateManyWithoutBranchNestedInput
    years?: YearTableUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutBranchNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutBranchNestedInput
    years?: YearTableUncheckedUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableCreateManyInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
  }

  export type BranchTableUpdateManyMutationInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
  }

  export type BranchTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type YearTableCreateInput = {
    name: string
    year: number
    university: UniversityTableCreateNestedOneWithoutYearsInput
    branch: BranchTableCreateNestedOneWithoutYearsInput
    students?: StudentTableCreateNestedManyWithoutYearInput
    tests?: TestTableCreateNestedManyWithoutYearInput
    notes?: NotesTableCreateNestedManyWithoutYearInput
  }

  export type YearTableUncheckedCreateInput = {
    id?: number
    name: string
    year: number
    universityId: number
    branchId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutYearInput
    tests?: TestTableUncheckedCreateNestedManyWithoutYearInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutYearInput
  }

  export type YearTableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    university?: UniversityTableUpdateOneRequiredWithoutYearsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutYearsNestedInput
    students?: StudentTableUpdateManyWithoutYearNestedInput
    tests?: TestTableUpdateManyWithoutYearNestedInput
    notes?: NotesTableUpdateManyWithoutYearNestedInput
  }

  export type YearTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutYearNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutYearNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutYearNestedInput
  }

  export type YearTableCreateManyInput = {
    id?: number
    name: string
    year: number
    universityId: number
    branchId: number
  }

  export type YearTableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type YearTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentTableCreateInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branch: BranchTableCreateNestedOneWithoutStudentsInput
    university: UniversityTableCreateNestedOneWithoutStudentsInput
    year: YearTableCreateNestedOneWithoutStudentsInput
    results?: ResultTableCreateNestedManyWithoutStudentInput
    responses?: StudentResponseTableCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUncheckedCreateInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
    yearId: number
    results?: ResultTableUncheckedCreateNestedManyWithoutStudentInput
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUpdateInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutStudentsNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutStudentsNestedInput
    year?: YearTableUpdateOneRequiredWithoutStudentsNestedInput
    results?: ResultTableUpdateManyWithoutStudentNestedInput
    responses?: StudentResponseTableUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
    results?: ResultTableUncheckedUpdateManyWithoutStudentNestedInput
    responses?: StudentResponseTableUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableCreateManyInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
    yearId: number
  }

  export type StudentTableUpdateManyMutationInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherTableCreateInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    branch: BranchTableCreateNestedOneWithoutTeachersInput
    university: UniversityTableCreateNestedOneWithoutTeachersInput
    tests?: TestTableCreateNestedManyWithoutTeacherInput
    notes?: NotesTableCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableUncheckedCreateInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
    universityId: number
    tests?: TestTableUncheckedCreateNestedManyWithoutTeacherInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableUpdateInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutTeachersNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutTeachersNestedInput
    tests?: TestTableUpdateManyWithoutTeacherNestedInput
    notes?: NotesTableUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    tests?: TestTableUncheckedUpdateManyWithoutTeacherNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableCreateManyInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
    universityId: number
  }

  export type TeacherTableUpdateManyMutationInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type TestTableCreateInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    teacher: TeacherTableCreateNestedOneWithoutTestsInput
    branch: BranchTableCreateNestedOneWithoutTestsInput
    year: YearTableCreateNestedOneWithoutTestsInput
    questions?: QuestionsTableCreateNestedManyWithoutTestInput
    results?: ResultTableCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    questions?: QuestionsTableUncheckedCreateNestedManyWithoutTestInput
    results?: ResultTableUncheckedCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutTestsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutTestsNestedInput
    year?: YearTableUpdateOneRequiredWithoutTestsNestedInput
    questions?: QuestionsTableUpdateManyWithoutTestNestedInput
    results?: ResultTableUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionsTableUncheckedUpdateManyWithoutTestNestedInput
    results?: ResultTableUncheckedUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestTableCreateManyInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
  }

  export type TestTableUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsTableCreateInput = {
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    test: TestTableCreateNestedOneWithoutQuestionsInput
    responses?: StudentResponseTableCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsTableUncheckedCreateInput = {
    id?: number
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    testId: number
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsTableUpdateInput = {
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
    test?: TestTableUpdateOneRequiredWithoutQuestionsNestedInput
    responses?: StudentResponseTableUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    responses?: StudentResponseTableUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsTableCreateManyInput = {
    id?: number
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    testId: number
  }

  export type QuestionsTableUpdateManyMutationInput = {
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionsTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableCreateInput = {
    totalmarks: number
    scoredmarks: number
    cheated?: boolean
    tabSwitchCount?: number
    fullScreenExits?: number
    maxFaceCount?: number
    test: TestTableCreateNestedOneWithoutResultsInput
    student: StudentTableCreateNestedOneWithoutResultsInput
  }

  export type ResultTableUncheckedCreateInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    cheated?: boolean
    testId: number
    studentId: number
    tabSwitchCount?: number
    fullScreenExits?: number
    maxFaceCount?: number
  }

  export type ResultTableUpdateInput = {
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    cheated?: BoolFieldUpdateOperationsInput | boolean
    tabSwitchCount?: IntFieldUpdateOperationsInput | number
    fullScreenExits?: IntFieldUpdateOperationsInput | number
    maxFaceCount?: IntFieldUpdateOperationsInput | number
    test?: TestTableUpdateOneRequiredWithoutResultsNestedInput
    student?: StudentTableUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ResultTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    cheated?: BoolFieldUpdateOperationsInput | boolean
    testId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    tabSwitchCount?: IntFieldUpdateOperationsInput | number
    fullScreenExits?: IntFieldUpdateOperationsInput | number
    maxFaceCount?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableCreateManyInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    cheated?: boolean
    testId: number
    studentId: number
    tabSwitchCount?: number
    fullScreenExits?: number
    maxFaceCount?: number
  }

  export type ResultTableUpdateManyMutationInput = {
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    cheated?: BoolFieldUpdateOperationsInput | boolean
    tabSwitchCount?: IntFieldUpdateOperationsInput | number
    fullScreenExits?: IntFieldUpdateOperationsInput | number
    maxFaceCount?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    cheated?: BoolFieldUpdateOperationsInput | boolean
    testId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    tabSwitchCount?: IntFieldUpdateOperationsInput | number
    fullScreenExits?: IntFieldUpdateOperationsInput | number
    maxFaceCount?: IntFieldUpdateOperationsInput | number
  }

  export type StudentResponseTableCreateInput = {
    selectedOption: string
    isCorrect: boolean
    student: StudentTableCreateNestedOneWithoutResponsesInput
    test: TestTableCreateNestedOneWithoutResponsesInput
    question: QuestionsTableCreateNestedOneWithoutResponsesInput
  }

  export type StudentResponseTableUncheckedCreateInput = {
    id?: number
    studentId: number
    testId: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type StudentResponseTableUpdateInput = {
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentTableUpdateOneRequiredWithoutResponsesNestedInput
    test?: TestTableUpdateOneRequiredWithoutResponsesNestedInput
    question?: QuestionsTableUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type StudentResponseTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentResponseTableCreateManyInput = {
    id?: number
    studentId: number
    testId: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type StudentResponseTableUpdateManyMutationInput = {
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentResponseTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesTableCreateInput = {
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacher: TeacherTableCreateNestedOneWithoutNotesInput
    university: UniversityTableCreateNestedOneWithoutNotesInput
    branch: BranchTableCreateNestedOneWithoutNotesInput
    year: YearTableCreateNestedOneWithoutNotesInput
  }

  export type NotesTableUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacherId: number
    universityId: number
    branchId: number
    yearId: number
  }

  export type NotesTableUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutNotesNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutNotesNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutNotesNestedInput
    year?: YearTableUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type NotesTableCreateManyInput = {
    id?: number
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacherId: number
    universityId: number
    branchId: number
    yearId: number
  }

  export type NotesTableUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotesTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BranchTableListRelationFilter = {
    every?: BranchTableWhereInput
    some?: BranchTableWhereInput
    none?: BranchTableWhereInput
  }

  export type StudentTableListRelationFilter = {
    every?: StudentTableWhereInput
    some?: StudentTableWhereInput
    none?: StudentTableWhereInput
  }

  export type TeacherTableListRelationFilter = {
    every?: TeacherTableWhereInput
    some?: TeacherTableWhereInput
    none?: TeacherTableWhereInput
  }

  export type YearTableListRelationFilter = {
    every?: YearTableWhereInput
    some?: YearTableWhereInput
    none?: YearTableWhereInput
  }

  export type NotesTableListRelationFilter = {
    every?: NotesTableWhereInput
    some?: NotesTableWhereInput
    none?: NotesTableWhereInput
  }

  export type BranchTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YearTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotesTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UniversityTableCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type UniversityTableAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UniversityTableMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type UniversityTableMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type UniversityTableSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UniversityTableRelationFilter = {
    is?: UniversityTableWhereInput
    isNot?: UniversityTableWhereInput
  }

  export type TestTableListRelationFilter = {
    every?: TestTableWhereInput
    some?: TestTableWhereInput
    none?: TestTableWhereInput
  }

  export type TestTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchTableCountOrderByAggregateInput = {
    id?: SortOrder
    Branchcode?: SortOrder
    Branchname?: SortOrder
    universityId?: SortOrder
  }

  export type BranchTableAvgOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type BranchTableMaxOrderByAggregateInput = {
    id?: SortOrder
    Branchcode?: SortOrder
    Branchname?: SortOrder
    universityId?: SortOrder
  }

  export type BranchTableMinOrderByAggregateInput = {
    id?: SortOrder
    Branchcode?: SortOrder
    Branchname?: SortOrder
    universityId?: SortOrder
  }

  export type BranchTableSumOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type BranchTableRelationFilter = {
    is?: BranchTableWhereInput
    isNot?: BranchTableWhereInput
  }

  export type YearTableCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
  }

  export type YearTableAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
  }

  export type YearTableMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
  }

  export type YearTableMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
  }

  export type YearTableSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
  }

  export type YearTableRelationFilter = {
    is?: YearTableWhereInput
    isNot?: YearTableWhereInput
  }

  export type ResultTableListRelationFilter = {
    every?: ResultTableWhereInput
    some?: ResultTableWhereInput
    none?: ResultTableWhereInput
  }

  export type StudentResponseTableListRelationFilter = {
    every?: StudentResponseTableWhereInput
    some?: StudentResponseTableWhereInput
    none?: StudentResponseTableWhereInput
  }

  export type ResultTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentResponseTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentTableCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    PRN?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
  }

  export type StudentTableAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
  }

  export type StudentTableMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    PRN?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
  }

  export type StudentTableMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    PRN?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
  }

  export type StudentTableSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
  }

  export type TeacherTableCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
  }

  export type TeacherTableAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
  }

  export type TeacherTableMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
  }

  export type TeacherTableMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
  }

  export type TeacherTableSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TeacherTableRelationFilter = {
    is?: TeacherTableWhereInput
    isNot?: TeacherTableWhereInput
  }

  export type QuestionsTableListRelationFilter = {
    every?: QuestionsTableWhereInput
    some?: QuestionsTableWhereInput
    none?: QuestionsTableWhereInput
  }

  export type QuestionsTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestTableCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    subject?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
    scheduledDate?: SortOrder
  }

  export type TestTableAvgOrderByAggregateInput = {
    id?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
  }

  export type TestTableMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    subject?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
    scheduledDate?: SortOrder
  }

  export type TestTableMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    subject?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
    scheduledDate?: SortOrder
  }

  export type TestTableSumOrderByAggregateInput = {
    id?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TestTableRelationFilter = {
    is?: TestTableWhereInput
    isNot?: TestTableWhereInput
  }

  export type QuestionsTableCountOrderByAggregateInput = {
    id?: SortOrder
    queText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
  }

  export type QuestionsTableAvgOrderByAggregateInput = {
    id?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
  }

  export type QuestionsTableMaxOrderByAggregateInput = {
    id?: SortOrder
    queText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
  }

  export type QuestionsTableMinOrderByAggregateInput = {
    id?: SortOrder
    queText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
  }

  export type QuestionsTableSumOrderByAggregateInput = {
    id?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StudentTableRelationFilter = {
    is?: StudentTableWhereInput
    isNot?: StudentTableWhereInput
  }

  export type ResultTableCountOrderByAggregateInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    cheated?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    tabSwitchCount?: SortOrder
    fullScreenExits?: SortOrder
    maxFaceCount?: SortOrder
  }

  export type ResultTableAvgOrderByAggregateInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    tabSwitchCount?: SortOrder
    fullScreenExits?: SortOrder
    maxFaceCount?: SortOrder
  }

  export type ResultTableMaxOrderByAggregateInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    cheated?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    tabSwitchCount?: SortOrder
    fullScreenExits?: SortOrder
    maxFaceCount?: SortOrder
  }

  export type ResultTableMinOrderByAggregateInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    cheated?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    tabSwitchCount?: SortOrder
    fullScreenExits?: SortOrder
    maxFaceCount?: SortOrder
  }

  export type ResultTableSumOrderByAggregateInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    tabSwitchCount?: SortOrder
    fullScreenExits?: SortOrder
    maxFaceCount?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type QuestionsTableRelationFilter = {
    is?: QuestionsTableWhereInput
    isNot?: QuestionsTableWhereInput
  }

  export type StudentResponseTableCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    testId?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
  }

  export type StudentResponseTableAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    testId?: SortOrder
    questionId?: SortOrder
  }

  export type StudentResponseTableMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    testId?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
  }

  export type StudentResponseTableMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    testId?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
  }

  export type StudentResponseTableSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    testId?: SortOrder
    questionId?: SortOrder
  }

  export type NotesTableCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    driveLink?: SortOrder
    uploadedAt?: SortOrder
    teacherId?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
    yearId?: SortOrder
  }

  export type NotesTableAvgOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
    yearId?: SortOrder
  }

  export type NotesTableMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    driveLink?: SortOrder
    uploadedAt?: SortOrder
    teacherId?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
    yearId?: SortOrder
  }

  export type NotesTableMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    driveLink?: SortOrder
    uploadedAt?: SortOrder
    teacherId?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
    yearId?: SortOrder
  }

  export type NotesTableSumOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    universityId?: SortOrder
    branchId?: SortOrder
    yearId?: SortOrder
  }

  export type BranchTableCreateNestedManyWithoutUniversityInput = {
    create?: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput> | BranchTableCreateWithoutUniversityInput[] | BranchTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: BranchTableCreateOrConnectWithoutUniversityInput | BranchTableCreateOrConnectWithoutUniversityInput[]
    createMany?: BranchTableCreateManyUniversityInputEnvelope
    connect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
  }

  export type StudentTableCreateNestedManyWithoutUniversityInput = {
    create?: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput> | StudentTableCreateWithoutUniversityInput[] | StudentTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutUniversityInput | StudentTableCreateOrConnectWithoutUniversityInput[]
    createMany?: StudentTableCreateManyUniversityInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TeacherTableCreateNestedManyWithoutUniversityInput = {
    create?: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput> | TeacherTableCreateWithoutUniversityInput[] | TeacherTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutUniversityInput | TeacherTableCreateOrConnectWithoutUniversityInput[]
    createMany?: TeacherTableCreateManyUniversityInputEnvelope
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
  }

  export type YearTableCreateNestedManyWithoutUniversityInput = {
    create?: XOR<YearTableCreateWithoutUniversityInput, YearTableUncheckedCreateWithoutUniversityInput> | YearTableCreateWithoutUniversityInput[] | YearTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: YearTableCreateOrConnectWithoutUniversityInput | YearTableCreateOrConnectWithoutUniversityInput[]
    createMany?: YearTableCreateManyUniversityInputEnvelope
    connect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
  }

  export type NotesTableCreateNestedManyWithoutUniversityInput = {
    create?: XOR<NotesTableCreateWithoutUniversityInput, NotesTableUncheckedCreateWithoutUniversityInput> | NotesTableCreateWithoutUniversityInput[] | NotesTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutUniversityInput | NotesTableCreateOrConnectWithoutUniversityInput[]
    createMany?: NotesTableCreateManyUniversityInputEnvelope
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
  }

  export type BranchTableUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput> | BranchTableCreateWithoutUniversityInput[] | BranchTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: BranchTableCreateOrConnectWithoutUniversityInput | BranchTableCreateOrConnectWithoutUniversityInput[]
    createMany?: BranchTableCreateManyUniversityInputEnvelope
    connect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
  }

  export type StudentTableUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput> | StudentTableCreateWithoutUniversityInput[] | StudentTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutUniversityInput | StudentTableCreateOrConnectWithoutUniversityInput[]
    createMany?: StudentTableCreateManyUniversityInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TeacherTableUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput> | TeacherTableCreateWithoutUniversityInput[] | TeacherTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutUniversityInput | TeacherTableCreateOrConnectWithoutUniversityInput[]
    createMany?: TeacherTableCreateManyUniversityInputEnvelope
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
  }

  export type YearTableUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<YearTableCreateWithoutUniversityInput, YearTableUncheckedCreateWithoutUniversityInput> | YearTableCreateWithoutUniversityInput[] | YearTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: YearTableCreateOrConnectWithoutUniversityInput | YearTableCreateOrConnectWithoutUniversityInput[]
    createMany?: YearTableCreateManyUniversityInputEnvelope
    connect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
  }

  export type NotesTableUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<NotesTableCreateWithoutUniversityInput, NotesTableUncheckedCreateWithoutUniversityInput> | NotesTableCreateWithoutUniversityInput[] | NotesTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutUniversityInput | NotesTableCreateOrConnectWithoutUniversityInput[]
    createMany?: NotesTableCreateManyUniversityInputEnvelope
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BranchTableUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput> | BranchTableCreateWithoutUniversityInput[] | BranchTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: BranchTableCreateOrConnectWithoutUniversityInput | BranchTableCreateOrConnectWithoutUniversityInput[]
    upsert?: BranchTableUpsertWithWhereUniqueWithoutUniversityInput | BranchTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: BranchTableCreateManyUniversityInputEnvelope
    set?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    disconnect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    delete?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    connect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    update?: BranchTableUpdateWithWhereUniqueWithoutUniversityInput | BranchTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: BranchTableUpdateManyWithWhereWithoutUniversityInput | BranchTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: BranchTableScalarWhereInput | BranchTableScalarWhereInput[]
  }

  export type StudentTableUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput> | StudentTableCreateWithoutUniversityInput[] | StudentTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutUniversityInput | StudentTableCreateOrConnectWithoutUniversityInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutUniversityInput | StudentTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: StudentTableCreateManyUniversityInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutUniversityInput | StudentTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutUniversityInput | StudentTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TeacherTableUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput> | TeacherTableCreateWithoutUniversityInput[] | TeacherTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutUniversityInput | TeacherTableCreateOrConnectWithoutUniversityInput[]
    upsert?: TeacherTableUpsertWithWhereUniqueWithoutUniversityInput | TeacherTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: TeacherTableCreateManyUniversityInputEnvelope
    set?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    disconnect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    delete?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    update?: TeacherTableUpdateWithWhereUniqueWithoutUniversityInput | TeacherTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: TeacherTableUpdateManyWithWhereWithoutUniversityInput | TeacherTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
  }

  export type YearTableUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<YearTableCreateWithoutUniversityInput, YearTableUncheckedCreateWithoutUniversityInput> | YearTableCreateWithoutUniversityInput[] | YearTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: YearTableCreateOrConnectWithoutUniversityInput | YearTableCreateOrConnectWithoutUniversityInput[]
    upsert?: YearTableUpsertWithWhereUniqueWithoutUniversityInput | YearTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: YearTableCreateManyUniversityInputEnvelope
    set?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    disconnect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    delete?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    connect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    update?: YearTableUpdateWithWhereUniqueWithoutUniversityInput | YearTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: YearTableUpdateManyWithWhereWithoutUniversityInput | YearTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: YearTableScalarWhereInput | YearTableScalarWhereInput[]
  }

  export type NotesTableUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<NotesTableCreateWithoutUniversityInput, NotesTableUncheckedCreateWithoutUniversityInput> | NotesTableCreateWithoutUniversityInput[] | NotesTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutUniversityInput | NotesTableCreateOrConnectWithoutUniversityInput[]
    upsert?: NotesTableUpsertWithWhereUniqueWithoutUniversityInput | NotesTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: NotesTableCreateManyUniversityInputEnvelope
    set?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    disconnect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    delete?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    update?: NotesTableUpdateWithWhereUniqueWithoutUniversityInput | NotesTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: NotesTableUpdateManyWithWhereWithoutUniversityInput | NotesTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: NotesTableScalarWhereInput | NotesTableScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BranchTableUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput> | BranchTableCreateWithoutUniversityInput[] | BranchTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: BranchTableCreateOrConnectWithoutUniversityInput | BranchTableCreateOrConnectWithoutUniversityInput[]
    upsert?: BranchTableUpsertWithWhereUniqueWithoutUniversityInput | BranchTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: BranchTableCreateManyUniversityInputEnvelope
    set?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    disconnect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    delete?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    connect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    update?: BranchTableUpdateWithWhereUniqueWithoutUniversityInput | BranchTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: BranchTableUpdateManyWithWhereWithoutUniversityInput | BranchTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: BranchTableScalarWhereInput | BranchTableScalarWhereInput[]
  }

  export type StudentTableUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput> | StudentTableCreateWithoutUniversityInput[] | StudentTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutUniversityInput | StudentTableCreateOrConnectWithoutUniversityInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutUniversityInput | StudentTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: StudentTableCreateManyUniversityInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutUniversityInput | StudentTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutUniversityInput | StudentTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TeacherTableUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput> | TeacherTableCreateWithoutUniversityInput[] | TeacherTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutUniversityInput | TeacherTableCreateOrConnectWithoutUniversityInput[]
    upsert?: TeacherTableUpsertWithWhereUniqueWithoutUniversityInput | TeacherTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: TeacherTableCreateManyUniversityInputEnvelope
    set?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    disconnect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    delete?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    update?: TeacherTableUpdateWithWhereUniqueWithoutUniversityInput | TeacherTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: TeacherTableUpdateManyWithWhereWithoutUniversityInput | TeacherTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
  }

  export type YearTableUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<YearTableCreateWithoutUniversityInput, YearTableUncheckedCreateWithoutUniversityInput> | YearTableCreateWithoutUniversityInput[] | YearTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: YearTableCreateOrConnectWithoutUniversityInput | YearTableCreateOrConnectWithoutUniversityInput[]
    upsert?: YearTableUpsertWithWhereUniqueWithoutUniversityInput | YearTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: YearTableCreateManyUniversityInputEnvelope
    set?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    disconnect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    delete?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    connect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    update?: YearTableUpdateWithWhereUniqueWithoutUniversityInput | YearTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: YearTableUpdateManyWithWhereWithoutUniversityInput | YearTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: YearTableScalarWhereInput | YearTableScalarWhereInput[]
  }

  export type NotesTableUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<NotesTableCreateWithoutUniversityInput, NotesTableUncheckedCreateWithoutUniversityInput> | NotesTableCreateWithoutUniversityInput[] | NotesTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutUniversityInput | NotesTableCreateOrConnectWithoutUniversityInput[]
    upsert?: NotesTableUpsertWithWhereUniqueWithoutUniversityInput | NotesTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: NotesTableCreateManyUniversityInputEnvelope
    set?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    disconnect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    delete?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    update?: NotesTableUpdateWithWhereUniqueWithoutUniversityInput | NotesTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: NotesTableUpdateManyWithWhereWithoutUniversityInput | NotesTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: NotesTableScalarWhereInput | NotesTableScalarWhereInput[]
  }

  export type UniversityTableCreateNestedOneWithoutBranchesInput = {
    create?: XOR<UniversityTableCreateWithoutBranchesInput, UniversityTableUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutBranchesInput
    connect?: UniversityTableWhereUniqueInput
  }

  export type StudentTableCreateNestedManyWithoutBranchInput = {
    create?: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput> | StudentTableCreateWithoutBranchInput[] | StudentTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutBranchInput | StudentTableCreateOrConnectWithoutBranchInput[]
    createMany?: StudentTableCreateManyBranchInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TeacherTableCreateNestedManyWithoutBranchInput = {
    create?: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput> | TeacherTableCreateWithoutBranchInput[] | TeacherTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutBranchInput | TeacherTableCreateOrConnectWithoutBranchInput[]
    createMany?: TeacherTableCreateManyBranchInputEnvelope
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
  }

  export type TestTableCreateNestedManyWithoutBranchInput = {
    create?: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput> | TestTableCreateWithoutBranchInput[] | TestTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutBranchInput | TestTableCreateOrConnectWithoutBranchInput[]
    createMany?: TestTableCreateManyBranchInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type YearTableCreateNestedManyWithoutBranchInput = {
    create?: XOR<YearTableCreateWithoutBranchInput, YearTableUncheckedCreateWithoutBranchInput> | YearTableCreateWithoutBranchInput[] | YearTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: YearTableCreateOrConnectWithoutBranchInput | YearTableCreateOrConnectWithoutBranchInput[]
    createMany?: YearTableCreateManyBranchInputEnvelope
    connect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
  }

  export type NotesTableCreateNestedManyWithoutBranchInput = {
    create?: XOR<NotesTableCreateWithoutBranchInput, NotesTableUncheckedCreateWithoutBranchInput> | NotesTableCreateWithoutBranchInput[] | NotesTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutBranchInput | NotesTableCreateOrConnectWithoutBranchInput[]
    createMany?: NotesTableCreateManyBranchInputEnvelope
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
  }

  export type StudentTableUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput> | StudentTableCreateWithoutBranchInput[] | StudentTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutBranchInput | StudentTableCreateOrConnectWithoutBranchInput[]
    createMany?: StudentTableCreateManyBranchInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TeacherTableUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput> | TeacherTableCreateWithoutBranchInput[] | TeacherTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutBranchInput | TeacherTableCreateOrConnectWithoutBranchInput[]
    createMany?: TeacherTableCreateManyBranchInputEnvelope
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
  }

  export type TestTableUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput> | TestTableCreateWithoutBranchInput[] | TestTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutBranchInput | TestTableCreateOrConnectWithoutBranchInput[]
    createMany?: TestTableCreateManyBranchInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type YearTableUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<YearTableCreateWithoutBranchInput, YearTableUncheckedCreateWithoutBranchInput> | YearTableCreateWithoutBranchInput[] | YearTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: YearTableCreateOrConnectWithoutBranchInput | YearTableCreateOrConnectWithoutBranchInput[]
    createMany?: YearTableCreateManyBranchInputEnvelope
    connect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
  }

  export type NotesTableUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<NotesTableCreateWithoutBranchInput, NotesTableUncheckedCreateWithoutBranchInput> | NotesTableCreateWithoutBranchInput[] | NotesTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutBranchInput | NotesTableCreateOrConnectWithoutBranchInput[]
    createMany?: NotesTableCreateManyBranchInputEnvelope
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
  }

  export type UniversityTableUpdateOneRequiredWithoutBranchesNestedInput = {
    create?: XOR<UniversityTableCreateWithoutBranchesInput, UniversityTableUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutBranchesInput
    upsert?: UniversityTableUpsertWithoutBranchesInput
    connect?: UniversityTableWhereUniqueInput
    update?: XOR<XOR<UniversityTableUpdateToOneWithWhereWithoutBranchesInput, UniversityTableUpdateWithoutBranchesInput>, UniversityTableUncheckedUpdateWithoutBranchesInput>
  }

  export type StudentTableUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput> | StudentTableCreateWithoutBranchInput[] | StudentTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutBranchInput | StudentTableCreateOrConnectWithoutBranchInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutBranchInput | StudentTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StudentTableCreateManyBranchInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutBranchInput | StudentTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutBranchInput | StudentTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TeacherTableUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput> | TeacherTableCreateWithoutBranchInput[] | TeacherTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutBranchInput | TeacherTableCreateOrConnectWithoutBranchInput[]
    upsert?: TeacherTableUpsertWithWhereUniqueWithoutBranchInput | TeacherTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TeacherTableCreateManyBranchInputEnvelope
    set?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    disconnect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    delete?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    update?: TeacherTableUpdateWithWhereUniqueWithoutBranchInput | TeacherTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TeacherTableUpdateManyWithWhereWithoutBranchInput | TeacherTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
  }

  export type TestTableUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput> | TestTableCreateWithoutBranchInput[] | TestTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutBranchInput | TestTableCreateOrConnectWithoutBranchInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutBranchInput | TestTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TestTableCreateManyBranchInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutBranchInput | TestTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutBranchInput | TestTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type YearTableUpdateManyWithoutBranchNestedInput = {
    create?: XOR<YearTableCreateWithoutBranchInput, YearTableUncheckedCreateWithoutBranchInput> | YearTableCreateWithoutBranchInput[] | YearTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: YearTableCreateOrConnectWithoutBranchInput | YearTableCreateOrConnectWithoutBranchInput[]
    upsert?: YearTableUpsertWithWhereUniqueWithoutBranchInput | YearTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: YearTableCreateManyBranchInputEnvelope
    set?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    disconnect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    delete?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    connect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    update?: YearTableUpdateWithWhereUniqueWithoutBranchInput | YearTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: YearTableUpdateManyWithWhereWithoutBranchInput | YearTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: YearTableScalarWhereInput | YearTableScalarWhereInput[]
  }

  export type NotesTableUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NotesTableCreateWithoutBranchInput, NotesTableUncheckedCreateWithoutBranchInput> | NotesTableCreateWithoutBranchInput[] | NotesTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutBranchInput | NotesTableCreateOrConnectWithoutBranchInput[]
    upsert?: NotesTableUpsertWithWhereUniqueWithoutBranchInput | NotesTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NotesTableCreateManyBranchInputEnvelope
    set?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    disconnect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    delete?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    update?: NotesTableUpdateWithWhereUniqueWithoutBranchInput | NotesTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NotesTableUpdateManyWithWhereWithoutBranchInput | NotesTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NotesTableScalarWhereInput | NotesTableScalarWhereInput[]
  }

  export type StudentTableUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput> | StudentTableCreateWithoutBranchInput[] | StudentTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutBranchInput | StudentTableCreateOrConnectWithoutBranchInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutBranchInput | StudentTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StudentTableCreateManyBranchInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutBranchInput | StudentTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutBranchInput | StudentTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TeacherTableUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput> | TeacherTableCreateWithoutBranchInput[] | TeacherTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutBranchInput | TeacherTableCreateOrConnectWithoutBranchInput[]
    upsert?: TeacherTableUpsertWithWhereUniqueWithoutBranchInput | TeacherTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TeacherTableCreateManyBranchInputEnvelope
    set?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    disconnect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    delete?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    update?: TeacherTableUpdateWithWhereUniqueWithoutBranchInput | TeacherTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TeacherTableUpdateManyWithWhereWithoutBranchInput | TeacherTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
  }

  export type TestTableUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput> | TestTableCreateWithoutBranchInput[] | TestTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutBranchInput | TestTableCreateOrConnectWithoutBranchInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutBranchInput | TestTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TestTableCreateManyBranchInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutBranchInput | TestTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutBranchInput | TestTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type YearTableUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<YearTableCreateWithoutBranchInput, YearTableUncheckedCreateWithoutBranchInput> | YearTableCreateWithoutBranchInput[] | YearTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: YearTableCreateOrConnectWithoutBranchInput | YearTableCreateOrConnectWithoutBranchInput[]
    upsert?: YearTableUpsertWithWhereUniqueWithoutBranchInput | YearTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: YearTableCreateManyBranchInputEnvelope
    set?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    disconnect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    delete?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    connect?: YearTableWhereUniqueInput | YearTableWhereUniqueInput[]
    update?: YearTableUpdateWithWhereUniqueWithoutBranchInput | YearTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: YearTableUpdateManyWithWhereWithoutBranchInput | YearTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: YearTableScalarWhereInput | YearTableScalarWhereInput[]
  }

  export type NotesTableUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NotesTableCreateWithoutBranchInput, NotesTableUncheckedCreateWithoutBranchInput> | NotesTableCreateWithoutBranchInput[] | NotesTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutBranchInput | NotesTableCreateOrConnectWithoutBranchInput[]
    upsert?: NotesTableUpsertWithWhereUniqueWithoutBranchInput | NotesTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NotesTableCreateManyBranchInputEnvelope
    set?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    disconnect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    delete?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    update?: NotesTableUpdateWithWhereUniqueWithoutBranchInput | NotesTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NotesTableUpdateManyWithWhereWithoutBranchInput | NotesTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NotesTableScalarWhereInput | NotesTableScalarWhereInput[]
  }

  export type UniversityTableCreateNestedOneWithoutYearsInput = {
    create?: XOR<UniversityTableCreateWithoutYearsInput, UniversityTableUncheckedCreateWithoutYearsInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutYearsInput
    connect?: UniversityTableWhereUniqueInput
  }

  export type BranchTableCreateNestedOneWithoutYearsInput = {
    create?: XOR<BranchTableCreateWithoutYearsInput, BranchTableUncheckedCreateWithoutYearsInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutYearsInput
    connect?: BranchTableWhereUniqueInput
  }

  export type StudentTableCreateNestedManyWithoutYearInput = {
    create?: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput> | StudentTableCreateWithoutYearInput[] | StudentTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutYearInput | StudentTableCreateOrConnectWithoutYearInput[]
    createMany?: StudentTableCreateManyYearInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TestTableCreateNestedManyWithoutYearInput = {
    create?: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput> | TestTableCreateWithoutYearInput[] | TestTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutYearInput | TestTableCreateOrConnectWithoutYearInput[]
    createMany?: TestTableCreateManyYearInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type NotesTableCreateNestedManyWithoutYearInput = {
    create?: XOR<NotesTableCreateWithoutYearInput, NotesTableUncheckedCreateWithoutYearInput> | NotesTableCreateWithoutYearInput[] | NotesTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutYearInput | NotesTableCreateOrConnectWithoutYearInput[]
    createMany?: NotesTableCreateManyYearInputEnvelope
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
  }

  export type StudentTableUncheckedCreateNestedManyWithoutYearInput = {
    create?: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput> | StudentTableCreateWithoutYearInput[] | StudentTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutYearInput | StudentTableCreateOrConnectWithoutYearInput[]
    createMany?: StudentTableCreateManyYearInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TestTableUncheckedCreateNestedManyWithoutYearInput = {
    create?: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput> | TestTableCreateWithoutYearInput[] | TestTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutYearInput | TestTableCreateOrConnectWithoutYearInput[]
    createMany?: TestTableCreateManyYearInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type NotesTableUncheckedCreateNestedManyWithoutYearInput = {
    create?: XOR<NotesTableCreateWithoutYearInput, NotesTableUncheckedCreateWithoutYearInput> | NotesTableCreateWithoutYearInput[] | NotesTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutYearInput | NotesTableCreateOrConnectWithoutYearInput[]
    createMany?: NotesTableCreateManyYearInputEnvelope
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
  }

  export type UniversityTableUpdateOneRequiredWithoutYearsNestedInput = {
    create?: XOR<UniversityTableCreateWithoutYearsInput, UniversityTableUncheckedCreateWithoutYearsInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutYearsInput
    upsert?: UniversityTableUpsertWithoutYearsInput
    connect?: UniversityTableWhereUniqueInput
    update?: XOR<XOR<UniversityTableUpdateToOneWithWhereWithoutYearsInput, UniversityTableUpdateWithoutYearsInput>, UniversityTableUncheckedUpdateWithoutYearsInput>
  }

  export type BranchTableUpdateOneRequiredWithoutYearsNestedInput = {
    create?: XOR<BranchTableCreateWithoutYearsInput, BranchTableUncheckedCreateWithoutYearsInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutYearsInput
    upsert?: BranchTableUpsertWithoutYearsInput
    connect?: BranchTableWhereUniqueInput
    update?: XOR<XOR<BranchTableUpdateToOneWithWhereWithoutYearsInput, BranchTableUpdateWithoutYearsInput>, BranchTableUncheckedUpdateWithoutYearsInput>
  }

  export type StudentTableUpdateManyWithoutYearNestedInput = {
    create?: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput> | StudentTableCreateWithoutYearInput[] | StudentTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutYearInput | StudentTableCreateOrConnectWithoutYearInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutYearInput | StudentTableUpsertWithWhereUniqueWithoutYearInput[]
    createMany?: StudentTableCreateManyYearInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutYearInput | StudentTableUpdateWithWhereUniqueWithoutYearInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutYearInput | StudentTableUpdateManyWithWhereWithoutYearInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TestTableUpdateManyWithoutYearNestedInput = {
    create?: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput> | TestTableCreateWithoutYearInput[] | TestTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutYearInput | TestTableCreateOrConnectWithoutYearInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutYearInput | TestTableUpsertWithWhereUniqueWithoutYearInput[]
    createMany?: TestTableCreateManyYearInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutYearInput | TestTableUpdateWithWhereUniqueWithoutYearInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutYearInput | TestTableUpdateManyWithWhereWithoutYearInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type NotesTableUpdateManyWithoutYearNestedInput = {
    create?: XOR<NotesTableCreateWithoutYearInput, NotesTableUncheckedCreateWithoutYearInput> | NotesTableCreateWithoutYearInput[] | NotesTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutYearInput | NotesTableCreateOrConnectWithoutYearInput[]
    upsert?: NotesTableUpsertWithWhereUniqueWithoutYearInput | NotesTableUpsertWithWhereUniqueWithoutYearInput[]
    createMany?: NotesTableCreateManyYearInputEnvelope
    set?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    disconnect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    delete?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    update?: NotesTableUpdateWithWhereUniqueWithoutYearInput | NotesTableUpdateWithWhereUniqueWithoutYearInput[]
    updateMany?: NotesTableUpdateManyWithWhereWithoutYearInput | NotesTableUpdateManyWithWhereWithoutYearInput[]
    deleteMany?: NotesTableScalarWhereInput | NotesTableScalarWhereInput[]
  }

  export type StudentTableUncheckedUpdateManyWithoutYearNestedInput = {
    create?: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput> | StudentTableCreateWithoutYearInput[] | StudentTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutYearInput | StudentTableCreateOrConnectWithoutYearInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutYearInput | StudentTableUpsertWithWhereUniqueWithoutYearInput[]
    createMany?: StudentTableCreateManyYearInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutYearInput | StudentTableUpdateWithWhereUniqueWithoutYearInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutYearInput | StudentTableUpdateManyWithWhereWithoutYearInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TestTableUncheckedUpdateManyWithoutYearNestedInput = {
    create?: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput> | TestTableCreateWithoutYearInput[] | TestTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutYearInput | TestTableCreateOrConnectWithoutYearInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutYearInput | TestTableUpsertWithWhereUniqueWithoutYearInput[]
    createMany?: TestTableCreateManyYearInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutYearInput | TestTableUpdateWithWhereUniqueWithoutYearInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutYearInput | TestTableUpdateManyWithWhereWithoutYearInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type NotesTableUncheckedUpdateManyWithoutYearNestedInput = {
    create?: XOR<NotesTableCreateWithoutYearInput, NotesTableUncheckedCreateWithoutYearInput> | NotesTableCreateWithoutYearInput[] | NotesTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutYearInput | NotesTableCreateOrConnectWithoutYearInput[]
    upsert?: NotesTableUpsertWithWhereUniqueWithoutYearInput | NotesTableUpsertWithWhereUniqueWithoutYearInput[]
    createMany?: NotesTableCreateManyYearInputEnvelope
    set?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    disconnect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    delete?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    update?: NotesTableUpdateWithWhereUniqueWithoutYearInput | NotesTableUpdateWithWhereUniqueWithoutYearInput[]
    updateMany?: NotesTableUpdateManyWithWhereWithoutYearInput | NotesTableUpdateManyWithWhereWithoutYearInput[]
    deleteMany?: NotesTableScalarWhereInput | NotesTableScalarWhereInput[]
  }

  export type BranchTableCreateNestedOneWithoutStudentsInput = {
    create?: XOR<BranchTableCreateWithoutStudentsInput, BranchTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutStudentsInput
    connect?: BranchTableWhereUniqueInput
  }

  export type UniversityTableCreateNestedOneWithoutStudentsInput = {
    create?: XOR<UniversityTableCreateWithoutStudentsInput, UniversityTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutStudentsInput
    connect?: UniversityTableWhereUniqueInput
  }

  export type YearTableCreateNestedOneWithoutStudentsInput = {
    create?: XOR<YearTableCreateWithoutStudentsInput, YearTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: YearTableCreateOrConnectWithoutStudentsInput
    connect?: YearTableWhereUniqueInput
  }

  export type ResultTableCreateNestedManyWithoutStudentInput = {
    create?: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput> | ResultTableCreateWithoutStudentInput[] | ResultTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutStudentInput | ResultTableCreateOrConnectWithoutStudentInput[]
    createMany?: ResultTableCreateManyStudentInputEnvelope
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
  }

  export type StudentResponseTableCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentResponseTableCreateWithoutStudentInput, StudentResponseTableUncheckedCreateWithoutStudentInput> | StudentResponseTableCreateWithoutStudentInput[] | StudentResponseTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutStudentInput | StudentResponseTableCreateOrConnectWithoutStudentInput[]
    createMany?: StudentResponseTableCreateManyStudentInputEnvelope
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
  }

  export type ResultTableUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput> | ResultTableCreateWithoutStudentInput[] | ResultTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutStudentInput | ResultTableCreateOrConnectWithoutStudentInput[]
    createMany?: ResultTableCreateManyStudentInputEnvelope
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
  }

  export type StudentResponseTableUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentResponseTableCreateWithoutStudentInput, StudentResponseTableUncheckedCreateWithoutStudentInput> | StudentResponseTableCreateWithoutStudentInput[] | StudentResponseTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutStudentInput | StudentResponseTableCreateOrConnectWithoutStudentInput[]
    createMany?: StudentResponseTableCreateManyStudentInputEnvelope
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
  }

  export type BranchTableUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<BranchTableCreateWithoutStudentsInput, BranchTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutStudentsInput
    upsert?: BranchTableUpsertWithoutStudentsInput
    connect?: BranchTableWhereUniqueInput
    update?: XOR<XOR<BranchTableUpdateToOneWithWhereWithoutStudentsInput, BranchTableUpdateWithoutStudentsInput>, BranchTableUncheckedUpdateWithoutStudentsInput>
  }

  export type UniversityTableUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<UniversityTableCreateWithoutStudentsInput, UniversityTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutStudentsInput
    upsert?: UniversityTableUpsertWithoutStudentsInput
    connect?: UniversityTableWhereUniqueInput
    update?: XOR<XOR<UniversityTableUpdateToOneWithWhereWithoutStudentsInput, UniversityTableUpdateWithoutStudentsInput>, UniversityTableUncheckedUpdateWithoutStudentsInput>
  }

  export type YearTableUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<YearTableCreateWithoutStudentsInput, YearTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: YearTableCreateOrConnectWithoutStudentsInput
    upsert?: YearTableUpsertWithoutStudentsInput
    connect?: YearTableWhereUniqueInput
    update?: XOR<XOR<YearTableUpdateToOneWithWhereWithoutStudentsInput, YearTableUpdateWithoutStudentsInput>, YearTableUncheckedUpdateWithoutStudentsInput>
  }

  export type ResultTableUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput> | ResultTableCreateWithoutStudentInput[] | ResultTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutStudentInput | ResultTableCreateOrConnectWithoutStudentInput[]
    upsert?: ResultTableUpsertWithWhereUniqueWithoutStudentInput | ResultTableUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ResultTableCreateManyStudentInputEnvelope
    set?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    disconnect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    delete?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    update?: ResultTableUpdateWithWhereUniqueWithoutStudentInput | ResultTableUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ResultTableUpdateManyWithWhereWithoutStudentInput | ResultTableUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
  }

  export type StudentResponseTableUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentResponseTableCreateWithoutStudentInput, StudentResponseTableUncheckedCreateWithoutStudentInput> | StudentResponseTableCreateWithoutStudentInput[] | StudentResponseTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutStudentInput | StudentResponseTableCreateOrConnectWithoutStudentInput[]
    upsert?: StudentResponseTableUpsertWithWhereUniqueWithoutStudentInput | StudentResponseTableUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentResponseTableCreateManyStudentInputEnvelope
    set?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    disconnect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    delete?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    update?: StudentResponseTableUpdateWithWhereUniqueWithoutStudentInput | StudentResponseTableUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentResponseTableUpdateManyWithWhereWithoutStudentInput | StudentResponseTableUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentResponseTableScalarWhereInput | StudentResponseTableScalarWhereInput[]
  }

  export type ResultTableUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput> | ResultTableCreateWithoutStudentInput[] | ResultTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutStudentInput | ResultTableCreateOrConnectWithoutStudentInput[]
    upsert?: ResultTableUpsertWithWhereUniqueWithoutStudentInput | ResultTableUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ResultTableCreateManyStudentInputEnvelope
    set?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    disconnect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    delete?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    update?: ResultTableUpdateWithWhereUniqueWithoutStudentInput | ResultTableUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ResultTableUpdateManyWithWhereWithoutStudentInput | ResultTableUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
  }

  export type StudentResponseTableUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentResponseTableCreateWithoutStudentInput, StudentResponseTableUncheckedCreateWithoutStudentInput> | StudentResponseTableCreateWithoutStudentInput[] | StudentResponseTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutStudentInput | StudentResponseTableCreateOrConnectWithoutStudentInput[]
    upsert?: StudentResponseTableUpsertWithWhereUniqueWithoutStudentInput | StudentResponseTableUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentResponseTableCreateManyStudentInputEnvelope
    set?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    disconnect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    delete?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    update?: StudentResponseTableUpdateWithWhereUniqueWithoutStudentInput | StudentResponseTableUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentResponseTableUpdateManyWithWhereWithoutStudentInput | StudentResponseTableUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentResponseTableScalarWhereInput | StudentResponseTableScalarWhereInput[]
  }

  export type BranchTableCreateNestedOneWithoutTeachersInput = {
    create?: XOR<BranchTableCreateWithoutTeachersInput, BranchTableUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutTeachersInput
    connect?: BranchTableWhereUniqueInput
  }

  export type UniversityTableCreateNestedOneWithoutTeachersInput = {
    create?: XOR<UniversityTableCreateWithoutTeachersInput, UniversityTableUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutTeachersInput
    connect?: UniversityTableWhereUniqueInput
  }

  export type TestTableCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput> | TestTableCreateWithoutTeacherInput[] | TestTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutTeacherInput | TestTableCreateOrConnectWithoutTeacherInput[]
    createMany?: TestTableCreateManyTeacherInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type NotesTableCreateNestedManyWithoutTeacherInput = {
    create?: XOR<NotesTableCreateWithoutTeacherInput, NotesTableUncheckedCreateWithoutTeacherInput> | NotesTableCreateWithoutTeacherInput[] | NotesTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutTeacherInput | NotesTableCreateOrConnectWithoutTeacherInput[]
    createMany?: NotesTableCreateManyTeacherInputEnvelope
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
  }

  export type TestTableUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput> | TestTableCreateWithoutTeacherInput[] | TestTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutTeacherInput | TestTableCreateOrConnectWithoutTeacherInput[]
    createMany?: TestTableCreateManyTeacherInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type NotesTableUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<NotesTableCreateWithoutTeacherInput, NotesTableUncheckedCreateWithoutTeacherInput> | NotesTableCreateWithoutTeacherInput[] | NotesTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutTeacherInput | NotesTableCreateOrConnectWithoutTeacherInput[]
    createMany?: NotesTableCreateManyTeacherInputEnvelope
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
  }

  export type BranchTableUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<BranchTableCreateWithoutTeachersInput, BranchTableUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutTeachersInput
    upsert?: BranchTableUpsertWithoutTeachersInput
    connect?: BranchTableWhereUniqueInput
    update?: XOR<XOR<BranchTableUpdateToOneWithWhereWithoutTeachersInput, BranchTableUpdateWithoutTeachersInput>, BranchTableUncheckedUpdateWithoutTeachersInput>
  }

  export type UniversityTableUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<UniversityTableCreateWithoutTeachersInput, UniversityTableUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutTeachersInput
    upsert?: UniversityTableUpsertWithoutTeachersInput
    connect?: UniversityTableWhereUniqueInput
    update?: XOR<XOR<UniversityTableUpdateToOneWithWhereWithoutTeachersInput, UniversityTableUpdateWithoutTeachersInput>, UniversityTableUncheckedUpdateWithoutTeachersInput>
  }

  export type TestTableUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput> | TestTableCreateWithoutTeacherInput[] | TestTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutTeacherInput | TestTableCreateOrConnectWithoutTeacherInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutTeacherInput | TestTableUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TestTableCreateManyTeacherInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutTeacherInput | TestTableUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutTeacherInput | TestTableUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type NotesTableUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<NotesTableCreateWithoutTeacherInput, NotesTableUncheckedCreateWithoutTeacherInput> | NotesTableCreateWithoutTeacherInput[] | NotesTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutTeacherInput | NotesTableCreateOrConnectWithoutTeacherInput[]
    upsert?: NotesTableUpsertWithWhereUniqueWithoutTeacherInput | NotesTableUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: NotesTableCreateManyTeacherInputEnvelope
    set?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    disconnect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    delete?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    update?: NotesTableUpdateWithWhereUniqueWithoutTeacherInput | NotesTableUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: NotesTableUpdateManyWithWhereWithoutTeacherInput | NotesTableUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: NotesTableScalarWhereInput | NotesTableScalarWhereInput[]
  }

  export type TestTableUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput> | TestTableCreateWithoutTeacherInput[] | TestTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutTeacherInput | TestTableCreateOrConnectWithoutTeacherInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutTeacherInput | TestTableUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TestTableCreateManyTeacherInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutTeacherInput | TestTableUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutTeacherInput | TestTableUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type NotesTableUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<NotesTableCreateWithoutTeacherInput, NotesTableUncheckedCreateWithoutTeacherInput> | NotesTableCreateWithoutTeacherInput[] | NotesTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: NotesTableCreateOrConnectWithoutTeacherInput | NotesTableCreateOrConnectWithoutTeacherInput[]
    upsert?: NotesTableUpsertWithWhereUniqueWithoutTeacherInput | NotesTableUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: NotesTableCreateManyTeacherInputEnvelope
    set?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    disconnect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    delete?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    connect?: NotesTableWhereUniqueInput | NotesTableWhereUniqueInput[]
    update?: NotesTableUpdateWithWhereUniqueWithoutTeacherInput | NotesTableUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: NotesTableUpdateManyWithWhereWithoutTeacherInput | NotesTableUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: NotesTableScalarWhereInput | NotesTableScalarWhereInput[]
  }

  export type TeacherTableCreateNestedOneWithoutTestsInput = {
    create?: XOR<TeacherTableCreateWithoutTestsInput, TeacherTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: TeacherTableCreateOrConnectWithoutTestsInput
    connect?: TeacherTableWhereUniqueInput
  }

  export type BranchTableCreateNestedOneWithoutTestsInput = {
    create?: XOR<BranchTableCreateWithoutTestsInput, BranchTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutTestsInput
    connect?: BranchTableWhereUniqueInput
  }

  export type YearTableCreateNestedOneWithoutTestsInput = {
    create?: XOR<YearTableCreateWithoutTestsInput, YearTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: YearTableCreateOrConnectWithoutTestsInput
    connect?: YearTableWhereUniqueInput
  }

  export type QuestionsTableCreateNestedManyWithoutTestInput = {
    create?: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput> | QuestionsTableCreateWithoutTestInput[] | QuestionsTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: QuestionsTableCreateOrConnectWithoutTestInput | QuestionsTableCreateOrConnectWithoutTestInput[]
    createMany?: QuestionsTableCreateManyTestInputEnvelope
    connect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
  }

  export type ResultTableCreateNestedManyWithoutTestInput = {
    create?: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput> | ResultTableCreateWithoutTestInput[] | ResultTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutTestInput | ResultTableCreateOrConnectWithoutTestInput[]
    createMany?: ResultTableCreateManyTestInputEnvelope
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
  }

  export type StudentResponseTableCreateNestedManyWithoutTestInput = {
    create?: XOR<StudentResponseTableCreateWithoutTestInput, StudentResponseTableUncheckedCreateWithoutTestInput> | StudentResponseTableCreateWithoutTestInput[] | StudentResponseTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutTestInput | StudentResponseTableCreateOrConnectWithoutTestInput[]
    createMany?: StudentResponseTableCreateManyTestInputEnvelope
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
  }

  export type QuestionsTableUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput> | QuestionsTableCreateWithoutTestInput[] | QuestionsTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: QuestionsTableCreateOrConnectWithoutTestInput | QuestionsTableCreateOrConnectWithoutTestInput[]
    createMany?: QuestionsTableCreateManyTestInputEnvelope
    connect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
  }

  export type ResultTableUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput> | ResultTableCreateWithoutTestInput[] | ResultTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutTestInput | ResultTableCreateOrConnectWithoutTestInput[]
    createMany?: ResultTableCreateManyTestInputEnvelope
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
  }

  export type StudentResponseTableUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<StudentResponseTableCreateWithoutTestInput, StudentResponseTableUncheckedCreateWithoutTestInput> | StudentResponseTableCreateWithoutTestInput[] | StudentResponseTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutTestInput | StudentResponseTableCreateOrConnectWithoutTestInput[]
    createMany?: StudentResponseTableCreateManyTestInputEnvelope
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TeacherTableUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<TeacherTableCreateWithoutTestsInput, TeacherTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: TeacherTableCreateOrConnectWithoutTestsInput
    upsert?: TeacherTableUpsertWithoutTestsInput
    connect?: TeacherTableWhereUniqueInput
    update?: XOR<XOR<TeacherTableUpdateToOneWithWhereWithoutTestsInput, TeacherTableUpdateWithoutTestsInput>, TeacherTableUncheckedUpdateWithoutTestsInput>
  }

  export type BranchTableUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<BranchTableCreateWithoutTestsInput, BranchTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutTestsInput
    upsert?: BranchTableUpsertWithoutTestsInput
    connect?: BranchTableWhereUniqueInput
    update?: XOR<XOR<BranchTableUpdateToOneWithWhereWithoutTestsInput, BranchTableUpdateWithoutTestsInput>, BranchTableUncheckedUpdateWithoutTestsInput>
  }

  export type YearTableUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<YearTableCreateWithoutTestsInput, YearTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: YearTableCreateOrConnectWithoutTestsInput
    upsert?: YearTableUpsertWithoutTestsInput
    connect?: YearTableWhereUniqueInput
    update?: XOR<XOR<YearTableUpdateToOneWithWhereWithoutTestsInput, YearTableUpdateWithoutTestsInput>, YearTableUncheckedUpdateWithoutTestsInput>
  }

  export type QuestionsTableUpdateManyWithoutTestNestedInput = {
    create?: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput> | QuestionsTableCreateWithoutTestInput[] | QuestionsTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: QuestionsTableCreateOrConnectWithoutTestInput | QuestionsTableCreateOrConnectWithoutTestInput[]
    upsert?: QuestionsTableUpsertWithWhereUniqueWithoutTestInput | QuestionsTableUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: QuestionsTableCreateManyTestInputEnvelope
    set?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    disconnect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    delete?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    connect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    update?: QuestionsTableUpdateWithWhereUniqueWithoutTestInput | QuestionsTableUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: QuestionsTableUpdateManyWithWhereWithoutTestInput | QuestionsTableUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: QuestionsTableScalarWhereInput | QuestionsTableScalarWhereInput[]
  }

  export type ResultTableUpdateManyWithoutTestNestedInput = {
    create?: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput> | ResultTableCreateWithoutTestInput[] | ResultTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutTestInput | ResultTableCreateOrConnectWithoutTestInput[]
    upsert?: ResultTableUpsertWithWhereUniqueWithoutTestInput | ResultTableUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: ResultTableCreateManyTestInputEnvelope
    set?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    disconnect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    delete?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    update?: ResultTableUpdateWithWhereUniqueWithoutTestInput | ResultTableUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: ResultTableUpdateManyWithWhereWithoutTestInput | ResultTableUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
  }

  export type StudentResponseTableUpdateManyWithoutTestNestedInput = {
    create?: XOR<StudentResponseTableCreateWithoutTestInput, StudentResponseTableUncheckedCreateWithoutTestInput> | StudentResponseTableCreateWithoutTestInput[] | StudentResponseTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutTestInput | StudentResponseTableCreateOrConnectWithoutTestInput[]
    upsert?: StudentResponseTableUpsertWithWhereUniqueWithoutTestInput | StudentResponseTableUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: StudentResponseTableCreateManyTestInputEnvelope
    set?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    disconnect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    delete?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    update?: StudentResponseTableUpdateWithWhereUniqueWithoutTestInput | StudentResponseTableUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: StudentResponseTableUpdateManyWithWhereWithoutTestInput | StudentResponseTableUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: StudentResponseTableScalarWhereInput | StudentResponseTableScalarWhereInput[]
  }

  export type QuestionsTableUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput> | QuestionsTableCreateWithoutTestInput[] | QuestionsTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: QuestionsTableCreateOrConnectWithoutTestInput | QuestionsTableCreateOrConnectWithoutTestInput[]
    upsert?: QuestionsTableUpsertWithWhereUniqueWithoutTestInput | QuestionsTableUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: QuestionsTableCreateManyTestInputEnvelope
    set?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    disconnect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    delete?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    connect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    update?: QuestionsTableUpdateWithWhereUniqueWithoutTestInput | QuestionsTableUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: QuestionsTableUpdateManyWithWhereWithoutTestInput | QuestionsTableUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: QuestionsTableScalarWhereInput | QuestionsTableScalarWhereInput[]
  }

  export type ResultTableUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput> | ResultTableCreateWithoutTestInput[] | ResultTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutTestInput | ResultTableCreateOrConnectWithoutTestInput[]
    upsert?: ResultTableUpsertWithWhereUniqueWithoutTestInput | ResultTableUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: ResultTableCreateManyTestInputEnvelope
    set?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    disconnect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    delete?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    update?: ResultTableUpdateWithWhereUniqueWithoutTestInput | ResultTableUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: ResultTableUpdateManyWithWhereWithoutTestInput | ResultTableUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
  }

  export type StudentResponseTableUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<StudentResponseTableCreateWithoutTestInput, StudentResponseTableUncheckedCreateWithoutTestInput> | StudentResponseTableCreateWithoutTestInput[] | StudentResponseTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutTestInput | StudentResponseTableCreateOrConnectWithoutTestInput[]
    upsert?: StudentResponseTableUpsertWithWhereUniqueWithoutTestInput | StudentResponseTableUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: StudentResponseTableCreateManyTestInputEnvelope
    set?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    disconnect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    delete?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    update?: StudentResponseTableUpdateWithWhereUniqueWithoutTestInput | StudentResponseTableUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: StudentResponseTableUpdateManyWithWhereWithoutTestInput | StudentResponseTableUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: StudentResponseTableScalarWhereInput | StudentResponseTableScalarWhereInput[]
  }

  export type TestTableCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<TestTableCreateWithoutQuestionsInput, TestTableUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: TestTableCreateOrConnectWithoutQuestionsInput
    connect?: TestTableWhereUniqueInput
  }

  export type StudentResponseTableCreateNestedManyWithoutQuestionInput = {
    create?: XOR<StudentResponseTableCreateWithoutQuestionInput, StudentResponseTableUncheckedCreateWithoutQuestionInput> | StudentResponseTableCreateWithoutQuestionInput[] | StudentResponseTableUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutQuestionInput | StudentResponseTableCreateOrConnectWithoutQuestionInput[]
    createMany?: StudentResponseTableCreateManyQuestionInputEnvelope
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
  }

  export type StudentResponseTableUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<StudentResponseTableCreateWithoutQuestionInput, StudentResponseTableUncheckedCreateWithoutQuestionInput> | StudentResponseTableCreateWithoutQuestionInput[] | StudentResponseTableUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutQuestionInput | StudentResponseTableCreateOrConnectWithoutQuestionInput[]
    createMany?: StudentResponseTableCreateManyQuestionInputEnvelope
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
  }

  export type TestTableUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<TestTableCreateWithoutQuestionsInput, TestTableUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: TestTableCreateOrConnectWithoutQuestionsInput
    upsert?: TestTableUpsertWithoutQuestionsInput
    connect?: TestTableWhereUniqueInput
    update?: XOR<XOR<TestTableUpdateToOneWithWhereWithoutQuestionsInput, TestTableUpdateWithoutQuestionsInput>, TestTableUncheckedUpdateWithoutQuestionsInput>
  }

  export type StudentResponseTableUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<StudentResponseTableCreateWithoutQuestionInput, StudentResponseTableUncheckedCreateWithoutQuestionInput> | StudentResponseTableCreateWithoutQuestionInput[] | StudentResponseTableUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutQuestionInput | StudentResponseTableCreateOrConnectWithoutQuestionInput[]
    upsert?: StudentResponseTableUpsertWithWhereUniqueWithoutQuestionInput | StudentResponseTableUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: StudentResponseTableCreateManyQuestionInputEnvelope
    set?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    disconnect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    delete?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    update?: StudentResponseTableUpdateWithWhereUniqueWithoutQuestionInput | StudentResponseTableUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: StudentResponseTableUpdateManyWithWhereWithoutQuestionInput | StudentResponseTableUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: StudentResponseTableScalarWhereInput | StudentResponseTableScalarWhereInput[]
  }

  export type StudentResponseTableUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<StudentResponseTableCreateWithoutQuestionInput, StudentResponseTableUncheckedCreateWithoutQuestionInput> | StudentResponseTableCreateWithoutQuestionInput[] | StudentResponseTableUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: StudentResponseTableCreateOrConnectWithoutQuestionInput | StudentResponseTableCreateOrConnectWithoutQuestionInput[]
    upsert?: StudentResponseTableUpsertWithWhereUniqueWithoutQuestionInput | StudentResponseTableUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: StudentResponseTableCreateManyQuestionInputEnvelope
    set?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    disconnect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    delete?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    connect?: StudentResponseTableWhereUniqueInput | StudentResponseTableWhereUniqueInput[]
    update?: StudentResponseTableUpdateWithWhereUniqueWithoutQuestionInput | StudentResponseTableUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: StudentResponseTableUpdateManyWithWhereWithoutQuestionInput | StudentResponseTableUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: StudentResponseTableScalarWhereInput | StudentResponseTableScalarWhereInput[]
  }

  export type TestTableCreateNestedOneWithoutResultsInput = {
    create?: XOR<TestTableCreateWithoutResultsInput, TestTableUncheckedCreateWithoutResultsInput>
    connectOrCreate?: TestTableCreateOrConnectWithoutResultsInput
    connect?: TestTableWhereUniqueInput
  }

  export type StudentTableCreateNestedOneWithoutResultsInput = {
    create?: XOR<StudentTableCreateWithoutResultsInput, StudentTableUncheckedCreateWithoutResultsInput>
    connectOrCreate?: StudentTableCreateOrConnectWithoutResultsInput
    connect?: StudentTableWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TestTableUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<TestTableCreateWithoutResultsInput, TestTableUncheckedCreateWithoutResultsInput>
    connectOrCreate?: TestTableCreateOrConnectWithoutResultsInput
    upsert?: TestTableUpsertWithoutResultsInput
    connect?: TestTableWhereUniqueInput
    update?: XOR<XOR<TestTableUpdateToOneWithWhereWithoutResultsInput, TestTableUpdateWithoutResultsInput>, TestTableUncheckedUpdateWithoutResultsInput>
  }

  export type StudentTableUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<StudentTableCreateWithoutResultsInput, StudentTableUncheckedCreateWithoutResultsInput>
    connectOrCreate?: StudentTableCreateOrConnectWithoutResultsInput
    upsert?: StudentTableUpsertWithoutResultsInput
    connect?: StudentTableWhereUniqueInput
    update?: XOR<XOR<StudentTableUpdateToOneWithWhereWithoutResultsInput, StudentTableUpdateWithoutResultsInput>, StudentTableUncheckedUpdateWithoutResultsInput>
  }

  export type StudentTableCreateNestedOneWithoutResponsesInput = {
    create?: XOR<StudentTableCreateWithoutResponsesInput, StudentTableUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: StudentTableCreateOrConnectWithoutResponsesInput
    connect?: StudentTableWhereUniqueInput
  }

  export type TestTableCreateNestedOneWithoutResponsesInput = {
    create?: XOR<TestTableCreateWithoutResponsesInput, TestTableUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: TestTableCreateOrConnectWithoutResponsesInput
    connect?: TestTableWhereUniqueInput
  }

  export type QuestionsTableCreateNestedOneWithoutResponsesInput = {
    create?: XOR<QuestionsTableCreateWithoutResponsesInput, QuestionsTableUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuestionsTableCreateOrConnectWithoutResponsesInput
    connect?: QuestionsTableWhereUniqueInput
  }

  export type StudentTableUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<StudentTableCreateWithoutResponsesInput, StudentTableUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: StudentTableCreateOrConnectWithoutResponsesInput
    upsert?: StudentTableUpsertWithoutResponsesInput
    connect?: StudentTableWhereUniqueInput
    update?: XOR<XOR<StudentTableUpdateToOneWithWhereWithoutResponsesInput, StudentTableUpdateWithoutResponsesInput>, StudentTableUncheckedUpdateWithoutResponsesInput>
  }

  export type TestTableUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<TestTableCreateWithoutResponsesInput, TestTableUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: TestTableCreateOrConnectWithoutResponsesInput
    upsert?: TestTableUpsertWithoutResponsesInput
    connect?: TestTableWhereUniqueInput
    update?: XOR<XOR<TestTableUpdateToOneWithWhereWithoutResponsesInput, TestTableUpdateWithoutResponsesInput>, TestTableUncheckedUpdateWithoutResponsesInput>
  }

  export type QuestionsTableUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<QuestionsTableCreateWithoutResponsesInput, QuestionsTableUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuestionsTableCreateOrConnectWithoutResponsesInput
    upsert?: QuestionsTableUpsertWithoutResponsesInput
    connect?: QuestionsTableWhereUniqueInput
    update?: XOR<XOR<QuestionsTableUpdateToOneWithWhereWithoutResponsesInput, QuestionsTableUpdateWithoutResponsesInput>, QuestionsTableUncheckedUpdateWithoutResponsesInput>
  }

  export type TeacherTableCreateNestedOneWithoutNotesInput = {
    create?: XOR<TeacherTableCreateWithoutNotesInput, TeacherTableUncheckedCreateWithoutNotesInput>
    connectOrCreate?: TeacherTableCreateOrConnectWithoutNotesInput
    connect?: TeacherTableWhereUniqueInput
  }

  export type UniversityTableCreateNestedOneWithoutNotesInput = {
    create?: XOR<UniversityTableCreateWithoutNotesInput, UniversityTableUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutNotesInput
    connect?: UniversityTableWhereUniqueInput
  }

  export type BranchTableCreateNestedOneWithoutNotesInput = {
    create?: XOR<BranchTableCreateWithoutNotesInput, BranchTableUncheckedCreateWithoutNotesInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutNotesInput
    connect?: BranchTableWhereUniqueInput
  }

  export type YearTableCreateNestedOneWithoutNotesInput = {
    create?: XOR<YearTableCreateWithoutNotesInput, YearTableUncheckedCreateWithoutNotesInput>
    connectOrCreate?: YearTableCreateOrConnectWithoutNotesInput
    connect?: YearTableWhereUniqueInput
  }

  export type TeacherTableUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<TeacherTableCreateWithoutNotesInput, TeacherTableUncheckedCreateWithoutNotesInput>
    connectOrCreate?: TeacherTableCreateOrConnectWithoutNotesInput
    upsert?: TeacherTableUpsertWithoutNotesInput
    connect?: TeacherTableWhereUniqueInput
    update?: XOR<XOR<TeacherTableUpdateToOneWithWhereWithoutNotesInput, TeacherTableUpdateWithoutNotesInput>, TeacherTableUncheckedUpdateWithoutNotesInput>
  }

  export type UniversityTableUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<UniversityTableCreateWithoutNotesInput, UniversityTableUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutNotesInput
    upsert?: UniversityTableUpsertWithoutNotesInput
    connect?: UniversityTableWhereUniqueInput
    update?: XOR<XOR<UniversityTableUpdateToOneWithWhereWithoutNotesInput, UniversityTableUpdateWithoutNotesInput>, UniversityTableUncheckedUpdateWithoutNotesInput>
  }

  export type BranchTableUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<BranchTableCreateWithoutNotesInput, BranchTableUncheckedCreateWithoutNotesInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutNotesInput
    upsert?: BranchTableUpsertWithoutNotesInput
    connect?: BranchTableWhereUniqueInput
    update?: XOR<XOR<BranchTableUpdateToOneWithWhereWithoutNotesInput, BranchTableUpdateWithoutNotesInput>, BranchTableUncheckedUpdateWithoutNotesInput>
  }

  export type YearTableUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<YearTableCreateWithoutNotesInput, YearTableUncheckedCreateWithoutNotesInput>
    connectOrCreate?: YearTableCreateOrConnectWithoutNotesInput
    upsert?: YearTableUpsertWithoutNotesInput
    connect?: YearTableWhereUniqueInput
    update?: XOR<XOR<YearTableUpdateToOneWithWhereWithoutNotesInput, YearTableUpdateWithoutNotesInput>, YearTableUncheckedUpdateWithoutNotesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BranchTableCreateWithoutUniversityInput = {
    Branchcode: string
    Branchname: string
    students?: StudentTableCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableCreateNestedManyWithoutBranchInput
    tests?: TestTableCreateNestedManyWithoutBranchInput
    years?: YearTableCreateNestedManyWithoutBranchInput
    notes?: NotesTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateWithoutUniversityInput = {
    id?: number
    Branchcode: string
    Branchname: string
    students?: StudentTableUncheckedCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutBranchInput
    tests?: TestTableUncheckedCreateNestedManyWithoutBranchInput
    years?: YearTableUncheckedCreateNestedManyWithoutBranchInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableCreateOrConnectWithoutUniversityInput = {
    where: BranchTableWhereUniqueInput
    create: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput>
  }

  export type BranchTableCreateManyUniversityInputEnvelope = {
    data: BranchTableCreateManyUniversityInput | BranchTableCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type StudentTableCreateWithoutUniversityInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branch: BranchTableCreateNestedOneWithoutStudentsInput
    year: YearTableCreateNestedOneWithoutStudentsInput
    results?: ResultTableCreateNestedManyWithoutStudentInput
    responses?: StudentResponseTableCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUncheckedCreateWithoutUniversityInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    yearId: number
    results?: ResultTableUncheckedCreateNestedManyWithoutStudentInput
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentTableCreateOrConnectWithoutUniversityInput = {
    where: StudentTableWhereUniqueInput
    create: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput>
  }

  export type StudentTableCreateManyUniversityInputEnvelope = {
    data: StudentTableCreateManyUniversityInput | StudentTableCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type TeacherTableCreateWithoutUniversityInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    branch: BranchTableCreateNestedOneWithoutTeachersInput
    tests?: TestTableCreateNestedManyWithoutTeacherInput
    notes?: NotesTableCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableUncheckedCreateWithoutUniversityInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
    tests?: TestTableUncheckedCreateNestedManyWithoutTeacherInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableCreateOrConnectWithoutUniversityInput = {
    where: TeacherTableWhereUniqueInput
    create: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput>
  }

  export type TeacherTableCreateManyUniversityInputEnvelope = {
    data: TeacherTableCreateManyUniversityInput | TeacherTableCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type YearTableCreateWithoutUniversityInput = {
    name: string
    year: number
    branch: BranchTableCreateNestedOneWithoutYearsInput
    students?: StudentTableCreateNestedManyWithoutYearInput
    tests?: TestTableCreateNestedManyWithoutYearInput
    notes?: NotesTableCreateNestedManyWithoutYearInput
  }

  export type YearTableUncheckedCreateWithoutUniversityInput = {
    id?: number
    name: string
    year: number
    branchId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutYearInput
    tests?: TestTableUncheckedCreateNestedManyWithoutYearInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutYearInput
  }

  export type YearTableCreateOrConnectWithoutUniversityInput = {
    where: YearTableWhereUniqueInput
    create: XOR<YearTableCreateWithoutUniversityInput, YearTableUncheckedCreateWithoutUniversityInput>
  }

  export type YearTableCreateManyUniversityInputEnvelope = {
    data: YearTableCreateManyUniversityInput | YearTableCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type NotesTableCreateWithoutUniversityInput = {
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacher: TeacherTableCreateNestedOneWithoutNotesInput
    branch: BranchTableCreateNestedOneWithoutNotesInput
    year: YearTableCreateNestedOneWithoutNotesInput
  }

  export type NotesTableUncheckedCreateWithoutUniversityInput = {
    id?: number
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacherId: number
    branchId: number
    yearId: number
  }

  export type NotesTableCreateOrConnectWithoutUniversityInput = {
    where: NotesTableWhereUniqueInput
    create: XOR<NotesTableCreateWithoutUniversityInput, NotesTableUncheckedCreateWithoutUniversityInput>
  }

  export type NotesTableCreateManyUniversityInputEnvelope = {
    data: NotesTableCreateManyUniversityInput | NotesTableCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type BranchTableUpsertWithWhereUniqueWithoutUniversityInput = {
    where: BranchTableWhereUniqueInput
    update: XOR<BranchTableUpdateWithoutUniversityInput, BranchTableUncheckedUpdateWithoutUniversityInput>
    create: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput>
  }

  export type BranchTableUpdateWithWhereUniqueWithoutUniversityInput = {
    where: BranchTableWhereUniqueInput
    data: XOR<BranchTableUpdateWithoutUniversityInput, BranchTableUncheckedUpdateWithoutUniversityInput>
  }

  export type BranchTableUpdateManyWithWhereWithoutUniversityInput = {
    where: BranchTableScalarWhereInput
    data: XOR<BranchTableUpdateManyMutationInput, BranchTableUncheckedUpdateManyWithoutUniversityInput>
  }

  export type BranchTableScalarWhereInput = {
    AND?: BranchTableScalarWhereInput | BranchTableScalarWhereInput[]
    OR?: BranchTableScalarWhereInput[]
    NOT?: BranchTableScalarWhereInput | BranchTableScalarWhereInput[]
    id?: IntFilter<"BranchTable"> | number
    Branchcode?: StringFilter<"BranchTable"> | string
    Branchname?: StringFilter<"BranchTable"> | string
    universityId?: IntFilter<"BranchTable"> | number
  }

  export type StudentTableUpsertWithWhereUniqueWithoutUniversityInput = {
    where: StudentTableWhereUniqueInput
    update: XOR<StudentTableUpdateWithoutUniversityInput, StudentTableUncheckedUpdateWithoutUniversityInput>
    create: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput>
  }

  export type StudentTableUpdateWithWhereUniqueWithoutUniversityInput = {
    where: StudentTableWhereUniqueInput
    data: XOR<StudentTableUpdateWithoutUniversityInput, StudentTableUncheckedUpdateWithoutUniversityInput>
  }

  export type StudentTableUpdateManyWithWhereWithoutUniversityInput = {
    where: StudentTableScalarWhereInput
    data: XOR<StudentTableUpdateManyMutationInput, StudentTableUncheckedUpdateManyWithoutUniversityInput>
  }

  export type StudentTableScalarWhereInput = {
    AND?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
    OR?: StudentTableScalarWhereInput[]
    NOT?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
    id?: IntFilter<"StudentTable"> | number
    firstname?: StringFilter<"StudentTable"> | string
    lastname?: StringFilter<"StudentTable"> | string
    email?: StringFilter<"StudentTable"> | string
    password?: StringFilter<"StudentTable"> | string
    PRN?: StringFilter<"StudentTable"> | string
    branchId?: IntFilter<"StudentTable"> | number
    universityId?: IntFilter<"StudentTable"> | number
    yearId?: IntFilter<"StudentTable"> | number
  }

  export type TeacherTableUpsertWithWhereUniqueWithoutUniversityInput = {
    where: TeacherTableWhereUniqueInput
    update: XOR<TeacherTableUpdateWithoutUniversityInput, TeacherTableUncheckedUpdateWithoutUniversityInput>
    create: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput>
  }

  export type TeacherTableUpdateWithWhereUniqueWithoutUniversityInput = {
    where: TeacherTableWhereUniqueInput
    data: XOR<TeacherTableUpdateWithoutUniversityInput, TeacherTableUncheckedUpdateWithoutUniversityInput>
  }

  export type TeacherTableUpdateManyWithWhereWithoutUniversityInput = {
    where: TeacherTableScalarWhereInput
    data: XOR<TeacherTableUpdateManyMutationInput, TeacherTableUncheckedUpdateManyWithoutUniversityInput>
  }

  export type TeacherTableScalarWhereInput = {
    AND?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
    OR?: TeacherTableScalarWhereInput[]
    NOT?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
    id?: IntFilter<"TeacherTable"> | number
    firstname?: StringFilter<"TeacherTable"> | string
    lastname?: StringFilter<"TeacherTable"> | string
    email?: StringFilter<"TeacherTable"> | string
    password?: StringFilter<"TeacherTable"> | string
    branchId?: IntFilter<"TeacherTable"> | number
    universityId?: IntFilter<"TeacherTable"> | number
  }

  export type YearTableUpsertWithWhereUniqueWithoutUniversityInput = {
    where: YearTableWhereUniqueInput
    update: XOR<YearTableUpdateWithoutUniversityInput, YearTableUncheckedUpdateWithoutUniversityInput>
    create: XOR<YearTableCreateWithoutUniversityInput, YearTableUncheckedCreateWithoutUniversityInput>
  }

  export type YearTableUpdateWithWhereUniqueWithoutUniversityInput = {
    where: YearTableWhereUniqueInput
    data: XOR<YearTableUpdateWithoutUniversityInput, YearTableUncheckedUpdateWithoutUniversityInput>
  }

  export type YearTableUpdateManyWithWhereWithoutUniversityInput = {
    where: YearTableScalarWhereInput
    data: XOR<YearTableUpdateManyMutationInput, YearTableUncheckedUpdateManyWithoutUniversityInput>
  }

  export type YearTableScalarWhereInput = {
    AND?: YearTableScalarWhereInput | YearTableScalarWhereInput[]
    OR?: YearTableScalarWhereInput[]
    NOT?: YearTableScalarWhereInput | YearTableScalarWhereInput[]
    id?: IntFilter<"YearTable"> | number
    name?: StringFilter<"YearTable"> | string
    year?: IntFilter<"YearTable"> | number
    universityId?: IntFilter<"YearTable"> | number
    branchId?: IntFilter<"YearTable"> | number
  }

  export type NotesTableUpsertWithWhereUniqueWithoutUniversityInput = {
    where: NotesTableWhereUniqueInput
    update: XOR<NotesTableUpdateWithoutUniversityInput, NotesTableUncheckedUpdateWithoutUniversityInput>
    create: XOR<NotesTableCreateWithoutUniversityInput, NotesTableUncheckedCreateWithoutUniversityInput>
  }

  export type NotesTableUpdateWithWhereUniqueWithoutUniversityInput = {
    where: NotesTableWhereUniqueInput
    data: XOR<NotesTableUpdateWithoutUniversityInput, NotesTableUncheckedUpdateWithoutUniversityInput>
  }

  export type NotesTableUpdateManyWithWhereWithoutUniversityInput = {
    where: NotesTableScalarWhereInput
    data: XOR<NotesTableUpdateManyMutationInput, NotesTableUncheckedUpdateManyWithoutUniversityInput>
  }

  export type NotesTableScalarWhereInput = {
    AND?: NotesTableScalarWhereInput | NotesTableScalarWhereInput[]
    OR?: NotesTableScalarWhereInput[]
    NOT?: NotesTableScalarWhereInput | NotesTableScalarWhereInput[]
    id?: IntFilter<"NotesTable"> | number
    title?: StringFilter<"NotesTable"> | string
    description?: StringFilter<"NotesTable"> | string
    driveLink?: StringFilter<"NotesTable"> | string
    uploadedAt?: DateTimeFilter<"NotesTable"> | Date | string
    teacherId?: IntFilter<"NotesTable"> | number
    universityId?: IntFilter<"NotesTable"> | number
    branchId?: IntFilter<"NotesTable"> | number
    yearId?: IntFilter<"NotesTable"> | number
  }

  export type UniversityTableCreateWithoutBranchesInput = {
    name: string
    address: string
    students?: StudentTableCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableCreateNestedManyWithoutUniversityInput
    years?: YearTableCreateNestedManyWithoutUniversityInput
    notes?: NotesTableCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUncheckedCreateWithoutBranchesInput = {
    id?: number
    name: string
    address: string
    students?: StudentTableUncheckedCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutUniversityInput
    years?: YearTableUncheckedCreateNestedManyWithoutUniversityInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableCreateOrConnectWithoutBranchesInput = {
    where: UniversityTableWhereUniqueInput
    create: XOR<UniversityTableCreateWithoutBranchesInput, UniversityTableUncheckedCreateWithoutBranchesInput>
  }

  export type StudentTableCreateWithoutBranchInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    university: UniversityTableCreateNestedOneWithoutStudentsInput
    year: YearTableCreateNestedOneWithoutStudentsInput
    results?: ResultTableCreateNestedManyWithoutStudentInput
    responses?: StudentResponseTableCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUncheckedCreateWithoutBranchInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    universityId: number
    yearId: number
    results?: ResultTableUncheckedCreateNestedManyWithoutStudentInput
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentTableCreateOrConnectWithoutBranchInput = {
    where: StudentTableWhereUniqueInput
    create: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput>
  }

  export type StudentTableCreateManyBranchInputEnvelope = {
    data: StudentTableCreateManyBranchInput | StudentTableCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type TeacherTableCreateWithoutBranchInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    university: UniversityTableCreateNestedOneWithoutTeachersInput
    tests?: TestTableCreateNestedManyWithoutTeacherInput
    notes?: NotesTableCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableUncheckedCreateWithoutBranchInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    universityId: number
    tests?: TestTableUncheckedCreateNestedManyWithoutTeacherInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableCreateOrConnectWithoutBranchInput = {
    where: TeacherTableWhereUniqueInput
    create: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput>
  }

  export type TeacherTableCreateManyBranchInputEnvelope = {
    data: TeacherTableCreateManyBranchInput | TeacherTableCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type TestTableCreateWithoutBranchInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    teacher: TeacherTableCreateNestedOneWithoutTestsInput
    year: YearTableCreateNestedOneWithoutTestsInput
    questions?: QuestionsTableCreateNestedManyWithoutTestInput
    results?: ResultTableCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateWithoutBranchInput = {
    id?: number
    title: string
    teacherID: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    questions?: QuestionsTableUncheckedCreateNestedManyWithoutTestInput
    results?: ResultTableUncheckedCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableCreateOrConnectWithoutBranchInput = {
    where: TestTableWhereUniqueInput
    create: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput>
  }

  export type TestTableCreateManyBranchInputEnvelope = {
    data: TestTableCreateManyBranchInput | TestTableCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type YearTableCreateWithoutBranchInput = {
    name: string
    year: number
    university: UniversityTableCreateNestedOneWithoutYearsInput
    students?: StudentTableCreateNestedManyWithoutYearInput
    tests?: TestTableCreateNestedManyWithoutYearInput
    notes?: NotesTableCreateNestedManyWithoutYearInput
  }

  export type YearTableUncheckedCreateWithoutBranchInput = {
    id?: number
    name: string
    year: number
    universityId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutYearInput
    tests?: TestTableUncheckedCreateNestedManyWithoutYearInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutYearInput
  }

  export type YearTableCreateOrConnectWithoutBranchInput = {
    where: YearTableWhereUniqueInput
    create: XOR<YearTableCreateWithoutBranchInput, YearTableUncheckedCreateWithoutBranchInput>
  }

  export type YearTableCreateManyBranchInputEnvelope = {
    data: YearTableCreateManyBranchInput | YearTableCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type NotesTableCreateWithoutBranchInput = {
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacher: TeacherTableCreateNestedOneWithoutNotesInput
    university: UniversityTableCreateNestedOneWithoutNotesInput
    year: YearTableCreateNestedOneWithoutNotesInput
  }

  export type NotesTableUncheckedCreateWithoutBranchInput = {
    id?: number
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacherId: number
    universityId: number
    yearId: number
  }

  export type NotesTableCreateOrConnectWithoutBranchInput = {
    where: NotesTableWhereUniqueInput
    create: XOR<NotesTableCreateWithoutBranchInput, NotesTableUncheckedCreateWithoutBranchInput>
  }

  export type NotesTableCreateManyBranchInputEnvelope = {
    data: NotesTableCreateManyBranchInput | NotesTableCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UniversityTableUpsertWithoutBranchesInput = {
    update: XOR<UniversityTableUpdateWithoutBranchesInput, UniversityTableUncheckedUpdateWithoutBranchesInput>
    create: XOR<UniversityTableCreateWithoutBranchesInput, UniversityTableUncheckedCreateWithoutBranchesInput>
    where?: UniversityTableWhereInput
  }

  export type UniversityTableUpdateToOneWithWhereWithoutBranchesInput = {
    where?: UniversityTableWhereInput
    data: XOR<UniversityTableUpdateWithoutBranchesInput, UniversityTableUncheckedUpdateWithoutBranchesInput>
  }

  export type UniversityTableUpdateWithoutBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    students?: StudentTableUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUpdateManyWithoutUniversityNestedInput
    years?: YearTableUpdateManyWithoutUniversityNestedInput
    notes?: NotesTableUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableUncheckedUpdateWithoutBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    students?: StudentTableUncheckedUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutUniversityNestedInput
    years?: YearTableUncheckedUpdateManyWithoutUniversityNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type StudentTableUpsertWithWhereUniqueWithoutBranchInput = {
    where: StudentTableWhereUniqueInput
    update: XOR<StudentTableUpdateWithoutBranchInput, StudentTableUncheckedUpdateWithoutBranchInput>
    create: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput>
  }

  export type StudentTableUpdateWithWhereUniqueWithoutBranchInput = {
    where: StudentTableWhereUniqueInput
    data: XOR<StudentTableUpdateWithoutBranchInput, StudentTableUncheckedUpdateWithoutBranchInput>
  }

  export type StudentTableUpdateManyWithWhereWithoutBranchInput = {
    where: StudentTableScalarWhereInput
    data: XOR<StudentTableUpdateManyMutationInput, StudentTableUncheckedUpdateManyWithoutBranchInput>
  }

  export type TeacherTableUpsertWithWhereUniqueWithoutBranchInput = {
    where: TeacherTableWhereUniqueInput
    update: XOR<TeacherTableUpdateWithoutBranchInput, TeacherTableUncheckedUpdateWithoutBranchInput>
    create: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput>
  }

  export type TeacherTableUpdateWithWhereUniqueWithoutBranchInput = {
    where: TeacherTableWhereUniqueInput
    data: XOR<TeacherTableUpdateWithoutBranchInput, TeacherTableUncheckedUpdateWithoutBranchInput>
  }

  export type TeacherTableUpdateManyWithWhereWithoutBranchInput = {
    where: TeacherTableScalarWhereInput
    data: XOR<TeacherTableUpdateManyMutationInput, TeacherTableUncheckedUpdateManyWithoutBranchInput>
  }

  export type TestTableUpsertWithWhereUniqueWithoutBranchInput = {
    where: TestTableWhereUniqueInput
    update: XOR<TestTableUpdateWithoutBranchInput, TestTableUncheckedUpdateWithoutBranchInput>
    create: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput>
  }

  export type TestTableUpdateWithWhereUniqueWithoutBranchInput = {
    where: TestTableWhereUniqueInput
    data: XOR<TestTableUpdateWithoutBranchInput, TestTableUncheckedUpdateWithoutBranchInput>
  }

  export type TestTableUpdateManyWithWhereWithoutBranchInput = {
    where: TestTableScalarWhereInput
    data: XOR<TestTableUpdateManyMutationInput, TestTableUncheckedUpdateManyWithoutBranchInput>
  }

  export type TestTableScalarWhereInput = {
    AND?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
    OR?: TestTableScalarWhereInput[]
    NOT?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
    id?: IntFilter<"TestTable"> | number
    title?: StringFilter<"TestTable"> | string
    teacherID?: IntFilter<"TestTable"> | number
    branchId?: IntFilter<"TestTable"> | number
    subject?: StringFilter<"TestTable"> | string
    yearId?: IntFilter<"TestTable"> | number
    totalmarks?: IntFilter<"TestTable"> | number
    duration?: IntFilter<"TestTable"> | number
    scheduledDate?: DateTimeFilter<"TestTable"> | Date | string
  }

  export type YearTableUpsertWithWhereUniqueWithoutBranchInput = {
    where: YearTableWhereUniqueInput
    update: XOR<YearTableUpdateWithoutBranchInput, YearTableUncheckedUpdateWithoutBranchInput>
    create: XOR<YearTableCreateWithoutBranchInput, YearTableUncheckedCreateWithoutBranchInput>
  }

  export type YearTableUpdateWithWhereUniqueWithoutBranchInput = {
    where: YearTableWhereUniqueInput
    data: XOR<YearTableUpdateWithoutBranchInput, YearTableUncheckedUpdateWithoutBranchInput>
  }

  export type YearTableUpdateManyWithWhereWithoutBranchInput = {
    where: YearTableScalarWhereInput
    data: XOR<YearTableUpdateManyMutationInput, YearTableUncheckedUpdateManyWithoutBranchInput>
  }

  export type NotesTableUpsertWithWhereUniqueWithoutBranchInput = {
    where: NotesTableWhereUniqueInput
    update: XOR<NotesTableUpdateWithoutBranchInput, NotesTableUncheckedUpdateWithoutBranchInput>
    create: XOR<NotesTableCreateWithoutBranchInput, NotesTableUncheckedCreateWithoutBranchInput>
  }

  export type NotesTableUpdateWithWhereUniqueWithoutBranchInput = {
    where: NotesTableWhereUniqueInput
    data: XOR<NotesTableUpdateWithoutBranchInput, NotesTableUncheckedUpdateWithoutBranchInput>
  }

  export type NotesTableUpdateManyWithWhereWithoutBranchInput = {
    where: NotesTableScalarWhereInput
    data: XOR<NotesTableUpdateManyMutationInput, NotesTableUncheckedUpdateManyWithoutBranchInput>
  }

  export type UniversityTableCreateWithoutYearsInput = {
    name: string
    address: string
    branches?: BranchTableCreateNestedManyWithoutUniversityInput
    students?: StudentTableCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableCreateNestedManyWithoutUniversityInput
    notes?: NotesTableCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUncheckedCreateWithoutYearsInput = {
    id?: number
    name: string
    address: string
    branches?: BranchTableUncheckedCreateNestedManyWithoutUniversityInput
    students?: StudentTableUncheckedCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutUniversityInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableCreateOrConnectWithoutYearsInput = {
    where: UniversityTableWhereUniqueInput
    create: XOR<UniversityTableCreateWithoutYearsInput, UniversityTableUncheckedCreateWithoutYearsInput>
  }

  export type BranchTableCreateWithoutYearsInput = {
    Branchcode: string
    Branchname: string
    university: UniversityTableCreateNestedOneWithoutBranchesInput
    students?: StudentTableCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableCreateNestedManyWithoutBranchInput
    tests?: TestTableCreateNestedManyWithoutBranchInput
    notes?: NotesTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateWithoutYearsInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutBranchInput
    tests?: TestTableUncheckedCreateNestedManyWithoutBranchInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableCreateOrConnectWithoutYearsInput = {
    where: BranchTableWhereUniqueInput
    create: XOR<BranchTableCreateWithoutYearsInput, BranchTableUncheckedCreateWithoutYearsInput>
  }

  export type StudentTableCreateWithoutYearInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branch: BranchTableCreateNestedOneWithoutStudentsInput
    university: UniversityTableCreateNestedOneWithoutStudentsInput
    results?: ResultTableCreateNestedManyWithoutStudentInput
    responses?: StudentResponseTableCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUncheckedCreateWithoutYearInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
    results?: ResultTableUncheckedCreateNestedManyWithoutStudentInput
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentTableCreateOrConnectWithoutYearInput = {
    where: StudentTableWhereUniqueInput
    create: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput>
  }

  export type StudentTableCreateManyYearInputEnvelope = {
    data: StudentTableCreateManyYearInput | StudentTableCreateManyYearInput[]
    skipDuplicates?: boolean
  }

  export type TestTableCreateWithoutYearInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    teacher: TeacherTableCreateNestedOneWithoutTestsInput
    branch: BranchTableCreateNestedOneWithoutTestsInput
    questions?: QuestionsTableCreateNestedManyWithoutTestInput
    results?: ResultTableCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateWithoutYearInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    questions?: QuestionsTableUncheckedCreateNestedManyWithoutTestInput
    results?: ResultTableUncheckedCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableCreateOrConnectWithoutYearInput = {
    where: TestTableWhereUniqueInput
    create: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput>
  }

  export type TestTableCreateManyYearInputEnvelope = {
    data: TestTableCreateManyYearInput | TestTableCreateManyYearInput[]
    skipDuplicates?: boolean
  }

  export type NotesTableCreateWithoutYearInput = {
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacher: TeacherTableCreateNestedOneWithoutNotesInput
    university: UniversityTableCreateNestedOneWithoutNotesInput
    branch: BranchTableCreateNestedOneWithoutNotesInput
  }

  export type NotesTableUncheckedCreateWithoutYearInput = {
    id?: number
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacherId: number
    universityId: number
    branchId: number
  }

  export type NotesTableCreateOrConnectWithoutYearInput = {
    where: NotesTableWhereUniqueInput
    create: XOR<NotesTableCreateWithoutYearInput, NotesTableUncheckedCreateWithoutYearInput>
  }

  export type NotesTableCreateManyYearInputEnvelope = {
    data: NotesTableCreateManyYearInput | NotesTableCreateManyYearInput[]
    skipDuplicates?: boolean
  }

  export type UniversityTableUpsertWithoutYearsInput = {
    update: XOR<UniversityTableUpdateWithoutYearsInput, UniversityTableUncheckedUpdateWithoutYearsInput>
    create: XOR<UniversityTableCreateWithoutYearsInput, UniversityTableUncheckedCreateWithoutYearsInput>
    where?: UniversityTableWhereInput
  }

  export type UniversityTableUpdateToOneWithWhereWithoutYearsInput = {
    where?: UniversityTableWhereInput
    data: XOR<UniversityTableUpdateWithoutYearsInput, UniversityTableUncheckedUpdateWithoutYearsInput>
  }

  export type UniversityTableUpdateWithoutYearsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUpdateManyWithoutUniversityNestedInput
    notes?: NotesTableUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableUncheckedUpdateWithoutYearsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUncheckedUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUncheckedUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutUniversityNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type BranchTableUpsertWithoutYearsInput = {
    update: XOR<BranchTableUpdateWithoutYearsInput, BranchTableUncheckedUpdateWithoutYearsInput>
    create: XOR<BranchTableCreateWithoutYearsInput, BranchTableUncheckedCreateWithoutYearsInput>
    where?: BranchTableWhereInput
  }

  export type BranchTableUpdateToOneWithWhereWithoutYearsInput = {
    where?: BranchTableWhereInput
    data: XOR<BranchTableUpdateWithoutYearsInput, BranchTableUncheckedUpdateWithoutYearsInput>
  }

  export type BranchTableUpdateWithoutYearsInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutBranchesNestedInput
    students?: StudentTableUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUpdateManyWithoutBranchNestedInput
    tests?: TestTableUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateWithoutYearsInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutBranchNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type StudentTableUpsertWithWhereUniqueWithoutYearInput = {
    where: StudentTableWhereUniqueInput
    update: XOR<StudentTableUpdateWithoutYearInput, StudentTableUncheckedUpdateWithoutYearInput>
    create: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput>
  }

  export type StudentTableUpdateWithWhereUniqueWithoutYearInput = {
    where: StudentTableWhereUniqueInput
    data: XOR<StudentTableUpdateWithoutYearInput, StudentTableUncheckedUpdateWithoutYearInput>
  }

  export type StudentTableUpdateManyWithWhereWithoutYearInput = {
    where: StudentTableScalarWhereInput
    data: XOR<StudentTableUpdateManyMutationInput, StudentTableUncheckedUpdateManyWithoutYearInput>
  }

  export type TestTableUpsertWithWhereUniqueWithoutYearInput = {
    where: TestTableWhereUniqueInput
    update: XOR<TestTableUpdateWithoutYearInput, TestTableUncheckedUpdateWithoutYearInput>
    create: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput>
  }

  export type TestTableUpdateWithWhereUniqueWithoutYearInput = {
    where: TestTableWhereUniqueInput
    data: XOR<TestTableUpdateWithoutYearInput, TestTableUncheckedUpdateWithoutYearInput>
  }

  export type TestTableUpdateManyWithWhereWithoutYearInput = {
    where: TestTableScalarWhereInput
    data: XOR<TestTableUpdateManyMutationInput, TestTableUncheckedUpdateManyWithoutYearInput>
  }

  export type NotesTableUpsertWithWhereUniqueWithoutYearInput = {
    where: NotesTableWhereUniqueInput
    update: XOR<NotesTableUpdateWithoutYearInput, NotesTableUncheckedUpdateWithoutYearInput>
    create: XOR<NotesTableCreateWithoutYearInput, NotesTableUncheckedCreateWithoutYearInput>
  }

  export type NotesTableUpdateWithWhereUniqueWithoutYearInput = {
    where: NotesTableWhereUniqueInput
    data: XOR<NotesTableUpdateWithoutYearInput, NotesTableUncheckedUpdateWithoutYearInput>
  }

  export type NotesTableUpdateManyWithWhereWithoutYearInput = {
    where: NotesTableScalarWhereInput
    data: XOR<NotesTableUpdateManyMutationInput, NotesTableUncheckedUpdateManyWithoutYearInput>
  }

  export type BranchTableCreateWithoutStudentsInput = {
    Branchcode: string
    Branchname: string
    university: UniversityTableCreateNestedOneWithoutBranchesInput
    teachers?: TeacherTableCreateNestedManyWithoutBranchInput
    tests?: TestTableCreateNestedManyWithoutBranchInput
    years?: YearTableCreateNestedManyWithoutBranchInput
    notes?: NotesTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateWithoutStudentsInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutBranchInput
    tests?: TestTableUncheckedCreateNestedManyWithoutBranchInput
    years?: YearTableUncheckedCreateNestedManyWithoutBranchInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableCreateOrConnectWithoutStudentsInput = {
    where: BranchTableWhereUniqueInput
    create: XOR<BranchTableCreateWithoutStudentsInput, BranchTableUncheckedCreateWithoutStudentsInput>
  }

  export type UniversityTableCreateWithoutStudentsInput = {
    name: string
    address: string
    branches?: BranchTableCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableCreateNestedManyWithoutUniversityInput
    years?: YearTableCreateNestedManyWithoutUniversityInput
    notes?: NotesTableCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUncheckedCreateWithoutStudentsInput = {
    id?: number
    name: string
    address: string
    branches?: BranchTableUncheckedCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutUniversityInput
    years?: YearTableUncheckedCreateNestedManyWithoutUniversityInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableCreateOrConnectWithoutStudentsInput = {
    where: UniversityTableWhereUniqueInput
    create: XOR<UniversityTableCreateWithoutStudentsInput, UniversityTableUncheckedCreateWithoutStudentsInput>
  }

  export type YearTableCreateWithoutStudentsInput = {
    name: string
    year: number
    university: UniversityTableCreateNestedOneWithoutYearsInput
    branch: BranchTableCreateNestedOneWithoutYearsInput
    tests?: TestTableCreateNestedManyWithoutYearInput
    notes?: NotesTableCreateNestedManyWithoutYearInput
  }

  export type YearTableUncheckedCreateWithoutStudentsInput = {
    id?: number
    name: string
    year: number
    universityId: number
    branchId: number
    tests?: TestTableUncheckedCreateNestedManyWithoutYearInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutYearInput
  }

  export type YearTableCreateOrConnectWithoutStudentsInput = {
    where: YearTableWhereUniqueInput
    create: XOR<YearTableCreateWithoutStudentsInput, YearTableUncheckedCreateWithoutStudentsInput>
  }

  export type ResultTableCreateWithoutStudentInput = {
    totalmarks: number
    scoredmarks: number
    cheated?: boolean
    tabSwitchCount?: number
    fullScreenExits?: number
    maxFaceCount?: number
    test: TestTableCreateNestedOneWithoutResultsInput
  }

  export type ResultTableUncheckedCreateWithoutStudentInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    cheated?: boolean
    testId: number
    tabSwitchCount?: number
    fullScreenExits?: number
    maxFaceCount?: number
  }

  export type ResultTableCreateOrConnectWithoutStudentInput = {
    where: ResultTableWhereUniqueInput
    create: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput>
  }

  export type ResultTableCreateManyStudentInputEnvelope = {
    data: ResultTableCreateManyStudentInput | ResultTableCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentResponseTableCreateWithoutStudentInput = {
    selectedOption: string
    isCorrect: boolean
    test: TestTableCreateNestedOneWithoutResponsesInput
    question: QuestionsTableCreateNestedOneWithoutResponsesInput
  }

  export type StudentResponseTableUncheckedCreateWithoutStudentInput = {
    id?: number
    testId: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type StudentResponseTableCreateOrConnectWithoutStudentInput = {
    where: StudentResponseTableWhereUniqueInput
    create: XOR<StudentResponseTableCreateWithoutStudentInput, StudentResponseTableUncheckedCreateWithoutStudentInput>
  }

  export type StudentResponseTableCreateManyStudentInputEnvelope = {
    data: StudentResponseTableCreateManyStudentInput | StudentResponseTableCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type BranchTableUpsertWithoutStudentsInput = {
    update: XOR<BranchTableUpdateWithoutStudentsInput, BranchTableUncheckedUpdateWithoutStudentsInput>
    create: XOR<BranchTableCreateWithoutStudentsInput, BranchTableUncheckedCreateWithoutStudentsInput>
    where?: BranchTableWhereInput
  }

  export type BranchTableUpdateToOneWithWhereWithoutStudentsInput = {
    where?: BranchTableWhereInput
    data: XOR<BranchTableUpdateWithoutStudentsInput, BranchTableUncheckedUpdateWithoutStudentsInput>
  }

  export type BranchTableUpdateWithoutStudentsInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutBranchesNestedInput
    teachers?: TeacherTableUpdateManyWithoutBranchNestedInput
    tests?: TestTableUpdateManyWithoutBranchNestedInput
    years?: YearTableUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    teachers?: TeacherTableUncheckedUpdateManyWithoutBranchNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutBranchNestedInput
    years?: YearTableUncheckedUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UniversityTableUpsertWithoutStudentsInput = {
    update: XOR<UniversityTableUpdateWithoutStudentsInput, UniversityTableUncheckedUpdateWithoutStudentsInput>
    create: XOR<UniversityTableCreateWithoutStudentsInput, UniversityTableUncheckedCreateWithoutStudentsInput>
    where?: UniversityTableWhereInput
  }

  export type UniversityTableUpdateToOneWithWhereWithoutStudentsInput = {
    where?: UniversityTableWhereInput
    data: XOR<UniversityTableUpdateWithoutStudentsInput, UniversityTableUncheckedUpdateWithoutStudentsInput>
  }

  export type UniversityTableUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUpdateManyWithoutUniversityNestedInput
    years?: YearTableUpdateManyWithoutUniversityNestedInput
    notes?: NotesTableUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUncheckedUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutUniversityNestedInput
    years?: YearTableUncheckedUpdateManyWithoutUniversityNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type YearTableUpsertWithoutStudentsInput = {
    update: XOR<YearTableUpdateWithoutStudentsInput, YearTableUncheckedUpdateWithoutStudentsInput>
    create: XOR<YearTableCreateWithoutStudentsInput, YearTableUncheckedCreateWithoutStudentsInput>
    where?: YearTableWhereInput
  }

  export type YearTableUpdateToOneWithWhereWithoutStudentsInput = {
    where?: YearTableWhereInput
    data: XOR<YearTableUpdateWithoutStudentsInput, YearTableUncheckedUpdateWithoutStudentsInput>
  }

  export type YearTableUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    university?: UniversityTableUpdateOneRequiredWithoutYearsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutYearsNestedInput
    tests?: TestTableUpdateManyWithoutYearNestedInput
    notes?: NotesTableUpdateManyWithoutYearNestedInput
  }

  export type YearTableUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    tests?: TestTableUncheckedUpdateManyWithoutYearNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutYearNestedInput
  }

  export type ResultTableUpsertWithWhereUniqueWithoutStudentInput = {
    where: ResultTableWhereUniqueInput
    update: XOR<ResultTableUpdateWithoutStudentInput, ResultTableUncheckedUpdateWithoutStudentInput>
    create: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput>
  }

  export type ResultTableUpdateWithWhereUniqueWithoutStudentInput = {
    where: ResultTableWhereUniqueInput
    data: XOR<ResultTableUpdateWithoutStudentInput, ResultTableUncheckedUpdateWithoutStudentInput>
  }

  export type ResultTableUpdateManyWithWhereWithoutStudentInput = {
    where: ResultTableScalarWhereInput
    data: XOR<ResultTableUpdateManyMutationInput, ResultTableUncheckedUpdateManyWithoutStudentInput>
  }

  export type ResultTableScalarWhereInput = {
    AND?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
    OR?: ResultTableScalarWhereInput[]
    NOT?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
    id?: IntFilter<"ResultTable"> | number
    totalmarks?: IntFilter<"ResultTable"> | number
    scoredmarks?: IntFilter<"ResultTable"> | number
    cheated?: BoolFilter<"ResultTable"> | boolean
    testId?: IntFilter<"ResultTable"> | number
    studentId?: IntFilter<"ResultTable"> | number
    tabSwitchCount?: IntFilter<"ResultTable"> | number
    fullScreenExits?: IntFilter<"ResultTable"> | number
    maxFaceCount?: IntFilter<"ResultTable"> | number
  }

  export type StudentResponseTableUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentResponseTableWhereUniqueInput
    update: XOR<StudentResponseTableUpdateWithoutStudentInput, StudentResponseTableUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentResponseTableCreateWithoutStudentInput, StudentResponseTableUncheckedCreateWithoutStudentInput>
  }

  export type StudentResponseTableUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentResponseTableWhereUniqueInput
    data: XOR<StudentResponseTableUpdateWithoutStudentInput, StudentResponseTableUncheckedUpdateWithoutStudentInput>
  }

  export type StudentResponseTableUpdateManyWithWhereWithoutStudentInput = {
    where: StudentResponseTableScalarWhereInput
    data: XOR<StudentResponseTableUpdateManyMutationInput, StudentResponseTableUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentResponseTableScalarWhereInput = {
    AND?: StudentResponseTableScalarWhereInput | StudentResponseTableScalarWhereInput[]
    OR?: StudentResponseTableScalarWhereInput[]
    NOT?: StudentResponseTableScalarWhereInput | StudentResponseTableScalarWhereInput[]
    id?: IntFilter<"StudentResponseTable"> | number
    studentId?: IntFilter<"StudentResponseTable"> | number
    testId?: IntFilter<"StudentResponseTable"> | number
    questionId?: IntFilter<"StudentResponseTable"> | number
    selectedOption?: StringFilter<"StudentResponseTable"> | string
    isCorrect?: BoolFilter<"StudentResponseTable"> | boolean
  }

  export type BranchTableCreateWithoutTeachersInput = {
    Branchcode: string
    Branchname: string
    university: UniversityTableCreateNestedOneWithoutBranchesInput
    students?: StudentTableCreateNestedManyWithoutBranchInput
    tests?: TestTableCreateNestedManyWithoutBranchInput
    years?: YearTableCreateNestedManyWithoutBranchInput
    notes?: NotesTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateWithoutTeachersInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutBranchInput
    tests?: TestTableUncheckedCreateNestedManyWithoutBranchInput
    years?: YearTableUncheckedCreateNestedManyWithoutBranchInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableCreateOrConnectWithoutTeachersInput = {
    where: BranchTableWhereUniqueInput
    create: XOR<BranchTableCreateWithoutTeachersInput, BranchTableUncheckedCreateWithoutTeachersInput>
  }

  export type UniversityTableCreateWithoutTeachersInput = {
    name: string
    address: string
    branches?: BranchTableCreateNestedManyWithoutUniversityInput
    students?: StudentTableCreateNestedManyWithoutUniversityInput
    years?: YearTableCreateNestedManyWithoutUniversityInput
    notes?: NotesTableCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUncheckedCreateWithoutTeachersInput = {
    id?: number
    name: string
    address: string
    branches?: BranchTableUncheckedCreateNestedManyWithoutUniversityInput
    students?: StudentTableUncheckedCreateNestedManyWithoutUniversityInput
    years?: YearTableUncheckedCreateNestedManyWithoutUniversityInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableCreateOrConnectWithoutTeachersInput = {
    where: UniversityTableWhereUniqueInput
    create: XOR<UniversityTableCreateWithoutTeachersInput, UniversityTableUncheckedCreateWithoutTeachersInput>
  }

  export type TestTableCreateWithoutTeacherInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    branch: BranchTableCreateNestedOneWithoutTestsInput
    year: YearTableCreateNestedOneWithoutTestsInput
    questions?: QuestionsTableCreateNestedManyWithoutTestInput
    results?: ResultTableCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateWithoutTeacherInput = {
    id?: number
    title: string
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    questions?: QuestionsTableUncheckedCreateNestedManyWithoutTestInput
    results?: ResultTableUncheckedCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableCreateOrConnectWithoutTeacherInput = {
    where: TestTableWhereUniqueInput
    create: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput>
  }

  export type TestTableCreateManyTeacherInputEnvelope = {
    data: TestTableCreateManyTeacherInput | TestTableCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type NotesTableCreateWithoutTeacherInput = {
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    university: UniversityTableCreateNestedOneWithoutNotesInput
    branch: BranchTableCreateNestedOneWithoutNotesInput
    year: YearTableCreateNestedOneWithoutNotesInput
  }

  export type NotesTableUncheckedCreateWithoutTeacherInput = {
    id?: number
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    universityId: number
    branchId: number
    yearId: number
  }

  export type NotesTableCreateOrConnectWithoutTeacherInput = {
    where: NotesTableWhereUniqueInput
    create: XOR<NotesTableCreateWithoutTeacherInput, NotesTableUncheckedCreateWithoutTeacherInput>
  }

  export type NotesTableCreateManyTeacherInputEnvelope = {
    data: NotesTableCreateManyTeacherInput | NotesTableCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type BranchTableUpsertWithoutTeachersInput = {
    update: XOR<BranchTableUpdateWithoutTeachersInput, BranchTableUncheckedUpdateWithoutTeachersInput>
    create: XOR<BranchTableCreateWithoutTeachersInput, BranchTableUncheckedCreateWithoutTeachersInput>
    where?: BranchTableWhereInput
  }

  export type BranchTableUpdateToOneWithWhereWithoutTeachersInput = {
    where?: BranchTableWhereInput
    data: XOR<BranchTableUpdateWithoutTeachersInput, BranchTableUncheckedUpdateWithoutTeachersInput>
  }

  export type BranchTableUpdateWithoutTeachersInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutBranchesNestedInput
    students?: StudentTableUpdateManyWithoutBranchNestedInput
    tests?: TestTableUpdateManyWithoutBranchNestedInput
    years?: YearTableUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutBranchNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutBranchNestedInput
    years?: YearTableUncheckedUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UniversityTableUpsertWithoutTeachersInput = {
    update: XOR<UniversityTableUpdateWithoutTeachersInput, UniversityTableUncheckedUpdateWithoutTeachersInput>
    create: XOR<UniversityTableCreateWithoutTeachersInput, UniversityTableUncheckedCreateWithoutTeachersInput>
    where?: UniversityTableWhereInput
  }

  export type UniversityTableUpdateToOneWithWhereWithoutTeachersInput = {
    where?: UniversityTableWhereInput
    data: XOR<UniversityTableUpdateWithoutTeachersInput, UniversityTableUncheckedUpdateWithoutTeachersInput>
  }

  export type UniversityTableUpdateWithoutTeachersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUpdateManyWithoutUniversityNestedInput
    years?: YearTableUpdateManyWithoutUniversityNestedInput
    notes?: NotesTableUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUncheckedUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUncheckedUpdateManyWithoutUniversityNestedInput
    years?: YearTableUncheckedUpdateManyWithoutUniversityNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type TestTableUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TestTableWhereUniqueInput
    update: XOR<TestTableUpdateWithoutTeacherInput, TestTableUncheckedUpdateWithoutTeacherInput>
    create: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput>
  }

  export type TestTableUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TestTableWhereUniqueInput
    data: XOR<TestTableUpdateWithoutTeacherInput, TestTableUncheckedUpdateWithoutTeacherInput>
  }

  export type TestTableUpdateManyWithWhereWithoutTeacherInput = {
    where: TestTableScalarWhereInput
    data: XOR<TestTableUpdateManyMutationInput, TestTableUncheckedUpdateManyWithoutTeacherInput>
  }

  export type NotesTableUpsertWithWhereUniqueWithoutTeacherInput = {
    where: NotesTableWhereUniqueInput
    update: XOR<NotesTableUpdateWithoutTeacherInput, NotesTableUncheckedUpdateWithoutTeacherInput>
    create: XOR<NotesTableCreateWithoutTeacherInput, NotesTableUncheckedCreateWithoutTeacherInput>
  }

  export type NotesTableUpdateWithWhereUniqueWithoutTeacherInput = {
    where: NotesTableWhereUniqueInput
    data: XOR<NotesTableUpdateWithoutTeacherInput, NotesTableUncheckedUpdateWithoutTeacherInput>
  }

  export type NotesTableUpdateManyWithWhereWithoutTeacherInput = {
    where: NotesTableScalarWhereInput
    data: XOR<NotesTableUpdateManyMutationInput, NotesTableUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherTableCreateWithoutTestsInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    branch: BranchTableCreateNestedOneWithoutTeachersInput
    university: UniversityTableCreateNestedOneWithoutTeachersInput
    notes?: NotesTableCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableUncheckedCreateWithoutTestsInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
    universityId: number
    notes?: NotesTableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableCreateOrConnectWithoutTestsInput = {
    where: TeacherTableWhereUniqueInput
    create: XOR<TeacherTableCreateWithoutTestsInput, TeacherTableUncheckedCreateWithoutTestsInput>
  }

  export type BranchTableCreateWithoutTestsInput = {
    Branchcode: string
    Branchname: string
    university: UniversityTableCreateNestedOneWithoutBranchesInput
    students?: StudentTableCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableCreateNestedManyWithoutBranchInput
    years?: YearTableCreateNestedManyWithoutBranchInput
    notes?: NotesTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateWithoutTestsInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutBranchInput
    years?: YearTableUncheckedCreateNestedManyWithoutBranchInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableCreateOrConnectWithoutTestsInput = {
    where: BranchTableWhereUniqueInput
    create: XOR<BranchTableCreateWithoutTestsInput, BranchTableUncheckedCreateWithoutTestsInput>
  }

  export type YearTableCreateWithoutTestsInput = {
    name: string
    year: number
    university: UniversityTableCreateNestedOneWithoutYearsInput
    branch: BranchTableCreateNestedOneWithoutYearsInput
    students?: StudentTableCreateNestedManyWithoutYearInput
    notes?: NotesTableCreateNestedManyWithoutYearInput
  }

  export type YearTableUncheckedCreateWithoutTestsInput = {
    id?: number
    name: string
    year: number
    universityId: number
    branchId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutYearInput
    notes?: NotesTableUncheckedCreateNestedManyWithoutYearInput
  }

  export type YearTableCreateOrConnectWithoutTestsInput = {
    where: YearTableWhereUniqueInput
    create: XOR<YearTableCreateWithoutTestsInput, YearTableUncheckedCreateWithoutTestsInput>
  }

  export type QuestionsTableCreateWithoutTestInput = {
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    responses?: StudentResponseTableCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsTableUncheckedCreateWithoutTestInput = {
    id?: number
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsTableCreateOrConnectWithoutTestInput = {
    where: QuestionsTableWhereUniqueInput
    create: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput>
  }

  export type QuestionsTableCreateManyTestInputEnvelope = {
    data: QuestionsTableCreateManyTestInput | QuestionsTableCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type ResultTableCreateWithoutTestInput = {
    totalmarks: number
    scoredmarks: number
    cheated?: boolean
    tabSwitchCount?: number
    fullScreenExits?: number
    maxFaceCount?: number
    student: StudentTableCreateNestedOneWithoutResultsInput
  }

  export type ResultTableUncheckedCreateWithoutTestInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    cheated?: boolean
    studentId: number
    tabSwitchCount?: number
    fullScreenExits?: number
    maxFaceCount?: number
  }

  export type ResultTableCreateOrConnectWithoutTestInput = {
    where: ResultTableWhereUniqueInput
    create: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput>
  }

  export type ResultTableCreateManyTestInputEnvelope = {
    data: ResultTableCreateManyTestInput | ResultTableCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type StudentResponseTableCreateWithoutTestInput = {
    selectedOption: string
    isCorrect: boolean
    student: StudentTableCreateNestedOneWithoutResponsesInput
    question: QuestionsTableCreateNestedOneWithoutResponsesInput
  }

  export type StudentResponseTableUncheckedCreateWithoutTestInput = {
    id?: number
    studentId: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type StudentResponseTableCreateOrConnectWithoutTestInput = {
    where: StudentResponseTableWhereUniqueInput
    create: XOR<StudentResponseTableCreateWithoutTestInput, StudentResponseTableUncheckedCreateWithoutTestInput>
  }

  export type StudentResponseTableCreateManyTestInputEnvelope = {
    data: StudentResponseTableCreateManyTestInput | StudentResponseTableCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type TeacherTableUpsertWithoutTestsInput = {
    update: XOR<TeacherTableUpdateWithoutTestsInput, TeacherTableUncheckedUpdateWithoutTestsInput>
    create: XOR<TeacherTableCreateWithoutTestsInput, TeacherTableUncheckedCreateWithoutTestsInput>
    where?: TeacherTableWhereInput
  }

  export type TeacherTableUpdateToOneWithWhereWithoutTestsInput = {
    where?: TeacherTableWhereInput
    data: XOR<TeacherTableUpdateWithoutTestsInput, TeacherTableUncheckedUpdateWithoutTestsInput>
  }

  export type TeacherTableUpdateWithoutTestsInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutTeachersNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutTeachersNestedInput
    notes?: NotesTableUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateWithoutTestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    notes?: NotesTableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type BranchTableUpsertWithoutTestsInput = {
    update: XOR<BranchTableUpdateWithoutTestsInput, BranchTableUncheckedUpdateWithoutTestsInput>
    create: XOR<BranchTableCreateWithoutTestsInput, BranchTableUncheckedCreateWithoutTestsInput>
    where?: BranchTableWhereInput
  }

  export type BranchTableUpdateToOneWithWhereWithoutTestsInput = {
    where?: BranchTableWhereInput
    data: XOR<BranchTableUpdateWithoutTestsInput, BranchTableUncheckedUpdateWithoutTestsInput>
  }

  export type BranchTableUpdateWithoutTestsInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutBranchesNestedInput
    students?: StudentTableUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUpdateManyWithoutBranchNestedInput
    years?: YearTableUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateWithoutTestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutBranchNestedInput
    years?: YearTableUncheckedUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type YearTableUpsertWithoutTestsInput = {
    update: XOR<YearTableUpdateWithoutTestsInput, YearTableUncheckedUpdateWithoutTestsInput>
    create: XOR<YearTableCreateWithoutTestsInput, YearTableUncheckedCreateWithoutTestsInput>
    where?: YearTableWhereInput
  }

  export type YearTableUpdateToOneWithWhereWithoutTestsInput = {
    where?: YearTableWhereInput
    data: XOR<YearTableUpdateWithoutTestsInput, YearTableUncheckedUpdateWithoutTestsInput>
  }

  export type YearTableUpdateWithoutTestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    university?: UniversityTableUpdateOneRequiredWithoutYearsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutYearsNestedInput
    students?: StudentTableUpdateManyWithoutYearNestedInput
    notes?: NotesTableUpdateManyWithoutYearNestedInput
  }

  export type YearTableUncheckedUpdateWithoutTestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutYearNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutYearNestedInput
  }

  export type QuestionsTableUpsertWithWhereUniqueWithoutTestInput = {
    where: QuestionsTableWhereUniqueInput
    update: XOR<QuestionsTableUpdateWithoutTestInput, QuestionsTableUncheckedUpdateWithoutTestInput>
    create: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput>
  }

  export type QuestionsTableUpdateWithWhereUniqueWithoutTestInput = {
    where: QuestionsTableWhereUniqueInput
    data: XOR<QuestionsTableUpdateWithoutTestInput, QuestionsTableUncheckedUpdateWithoutTestInput>
  }

  export type QuestionsTableUpdateManyWithWhereWithoutTestInput = {
    where: QuestionsTableScalarWhereInput
    data: XOR<QuestionsTableUpdateManyMutationInput, QuestionsTableUncheckedUpdateManyWithoutTestInput>
  }

  export type QuestionsTableScalarWhereInput = {
    AND?: QuestionsTableScalarWhereInput | QuestionsTableScalarWhereInput[]
    OR?: QuestionsTableScalarWhereInput[]
    NOT?: QuestionsTableScalarWhereInput | QuestionsTableScalarWhereInput[]
    id?: IntFilter<"QuestionsTable"> | number
    queText?: StringFilter<"QuestionsTable"> | string
    optionA?: StringFilter<"QuestionsTable"> | string
    optionB?: StringFilter<"QuestionsTable"> | string
    optionC?: StringFilter<"QuestionsTable"> | string
    optionD?: StringFilter<"QuestionsTable"> | string
    correctOption?: StringFilter<"QuestionsTable"> | string
    maxMark?: IntFilter<"QuestionsTable"> | number
    testId?: IntFilter<"QuestionsTable"> | number
  }

  export type ResultTableUpsertWithWhereUniqueWithoutTestInput = {
    where: ResultTableWhereUniqueInput
    update: XOR<ResultTableUpdateWithoutTestInput, ResultTableUncheckedUpdateWithoutTestInput>
    create: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput>
  }

  export type ResultTableUpdateWithWhereUniqueWithoutTestInput = {
    where: ResultTableWhereUniqueInput
    data: XOR<ResultTableUpdateWithoutTestInput, ResultTableUncheckedUpdateWithoutTestInput>
  }

  export type ResultTableUpdateManyWithWhereWithoutTestInput = {
    where: ResultTableScalarWhereInput
    data: XOR<ResultTableUpdateManyMutationInput, ResultTableUncheckedUpdateManyWithoutTestInput>
  }

  export type StudentResponseTableUpsertWithWhereUniqueWithoutTestInput = {
    where: StudentResponseTableWhereUniqueInput
    update: XOR<StudentResponseTableUpdateWithoutTestInput, StudentResponseTableUncheckedUpdateWithoutTestInput>
    create: XOR<StudentResponseTableCreateWithoutTestInput, StudentResponseTableUncheckedCreateWithoutTestInput>
  }

  export type StudentResponseTableUpdateWithWhereUniqueWithoutTestInput = {
    where: StudentResponseTableWhereUniqueInput
    data: XOR<StudentResponseTableUpdateWithoutTestInput, StudentResponseTableUncheckedUpdateWithoutTestInput>
  }

  export type StudentResponseTableUpdateManyWithWhereWithoutTestInput = {
    where: StudentResponseTableScalarWhereInput
    data: XOR<StudentResponseTableUpdateManyMutationInput, StudentResponseTableUncheckedUpdateManyWithoutTestInput>
  }

  export type TestTableCreateWithoutQuestionsInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    teacher: TeacherTableCreateNestedOneWithoutTestsInput
    branch: BranchTableCreateNestedOneWithoutTestsInput
    year: YearTableCreateNestedOneWithoutTestsInput
    results?: ResultTableCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateWithoutQuestionsInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    results?: ResultTableUncheckedCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableCreateOrConnectWithoutQuestionsInput = {
    where: TestTableWhereUniqueInput
    create: XOR<TestTableCreateWithoutQuestionsInput, TestTableUncheckedCreateWithoutQuestionsInput>
  }

  export type StudentResponseTableCreateWithoutQuestionInput = {
    selectedOption: string
    isCorrect: boolean
    student: StudentTableCreateNestedOneWithoutResponsesInput
    test: TestTableCreateNestedOneWithoutResponsesInput
  }

  export type StudentResponseTableUncheckedCreateWithoutQuestionInput = {
    id?: number
    studentId: number
    testId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type StudentResponseTableCreateOrConnectWithoutQuestionInput = {
    where: StudentResponseTableWhereUniqueInput
    create: XOR<StudentResponseTableCreateWithoutQuestionInput, StudentResponseTableUncheckedCreateWithoutQuestionInput>
  }

  export type StudentResponseTableCreateManyQuestionInputEnvelope = {
    data: StudentResponseTableCreateManyQuestionInput | StudentResponseTableCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type TestTableUpsertWithoutQuestionsInput = {
    update: XOR<TestTableUpdateWithoutQuestionsInput, TestTableUncheckedUpdateWithoutQuestionsInput>
    create: XOR<TestTableCreateWithoutQuestionsInput, TestTableUncheckedCreateWithoutQuestionsInput>
    where?: TestTableWhereInput
  }

  export type TestTableUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: TestTableWhereInput
    data: XOR<TestTableUpdateWithoutQuestionsInput, TestTableUncheckedUpdateWithoutQuestionsInput>
  }

  export type TestTableUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutTestsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutTestsNestedInput
    year?: YearTableUpdateOneRequiredWithoutTestsNestedInput
    results?: ResultTableUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ResultTableUncheckedUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type StudentResponseTableUpsertWithWhereUniqueWithoutQuestionInput = {
    where: StudentResponseTableWhereUniqueInput
    update: XOR<StudentResponseTableUpdateWithoutQuestionInput, StudentResponseTableUncheckedUpdateWithoutQuestionInput>
    create: XOR<StudentResponseTableCreateWithoutQuestionInput, StudentResponseTableUncheckedCreateWithoutQuestionInput>
  }

  export type StudentResponseTableUpdateWithWhereUniqueWithoutQuestionInput = {
    where: StudentResponseTableWhereUniqueInput
    data: XOR<StudentResponseTableUpdateWithoutQuestionInput, StudentResponseTableUncheckedUpdateWithoutQuestionInput>
  }

  export type StudentResponseTableUpdateManyWithWhereWithoutQuestionInput = {
    where: StudentResponseTableScalarWhereInput
    data: XOR<StudentResponseTableUpdateManyMutationInput, StudentResponseTableUncheckedUpdateManyWithoutQuestionInput>
  }

  export type TestTableCreateWithoutResultsInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    teacher: TeacherTableCreateNestedOneWithoutTestsInput
    branch: BranchTableCreateNestedOneWithoutTestsInput
    year: YearTableCreateNestedOneWithoutTestsInput
    questions?: QuestionsTableCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateWithoutResultsInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    questions?: QuestionsTableUncheckedCreateNestedManyWithoutTestInput
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableCreateOrConnectWithoutResultsInput = {
    where: TestTableWhereUniqueInput
    create: XOR<TestTableCreateWithoutResultsInput, TestTableUncheckedCreateWithoutResultsInput>
  }

  export type StudentTableCreateWithoutResultsInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branch: BranchTableCreateNestedOneWithoutStudentsInput
    university: UniversityTableCreateNestedOneWithoutStudentsInput
    year: YearTableCreateNestedOneWithoutStudentsInput
    responses?: StudentResponseTableCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUncheckedCreateWithoutResultsInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
    yearId: number
    responses?: StudentResponseTableUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentTableCreateOrConnectWithoutResultsInput = {
    where: StudentTableWhereUniqueInput
    create: XOR<StudentTableCreateWithoutResultsInput, StudentTableUncheckedCreateWithoutResultsInput>
  }

  export type TestTableUpsertWithoutResultsInput = {
    update: XOR<TestTableUpdateWithoutResultsInput, TestTableUncheckedUpdateWithoutResultsInput>
    create: XOR<TestTableCreateWithoutResultsInput, TestTableUncheckedCreateWithoutResultsInput>
    where?: TestTableWhereInput
  }

  export type TestTableUpdateToOneWithWhereWithoutResultsInput = {
    where?: TestTableWhereInput
    data: XOR<TestTableUpdateWithoutResultsInput, TestTableUncheckedUpdateWithoutResultsInput>
  }

  export type TestTableUpdateWithoutResultsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutTestsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutTestsNestedInput
    year?: YearTableUpdateOneRequiredWithoutTestsNestedInput
    questions?: QuestionsTableUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateWithoutResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionsTableUncheckedUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type StudentTableUpsertWithoutResultsInput = {
    update: XOR<StudentTableUpdateWithoutResultsInput, StudentTableUncheckedUpdateWithoutResultsInput>
    create: XOR<StudentTableCreateWithoutResultsInput, StudentTableUncheckedCreateWithoutResultsInput>
    where?: StudentTableWhereInput
  }

  export type StudentTableUpdateToOneWithWhereWithoutResultsInput = {
    where?: StudentTableWhereInput
    data: XOR<StudentTableUpdateWithoutResultsInput, StudentTableUncheckedUpdateWithoutResultsInput>
  }

  export type StudentTableUpdateWithoutResultsInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutStudentsNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutStudentsNestedInput
    year?: YearTableUpdateOneRequiredWithoutStudentsNestedInput
    responses?: StudentResponseTableUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateWithoutResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
    responses?: StudentResponseTableUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableCreateWithoutResponsesInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branch: BranchTableCreateNestedOneWithoutStudentsInput
    university: UniversityTableCreateNestedOneWithoutStudentsInput
    year: YearTableCreateNestedOneWithoutStudentsInput
    results?: ResultTableCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUncheckedCreateWithoutResponsesInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
    yearId: number
    results?: ResultTableUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentTableCreateOrConnectWithoutResponsesInput = {
    where: StudentTableWhereUniqueInput
    create: XOR<StudentTableCreateWithoutResponsesInput, StudentTableUncheckedCreateWithoutResponsesInput>
  }

  export type TestTableCreateWithoutResponsesInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    teacher: TeacherTableCreateNestedOneWithoutTestsInput
    branch: BranchTableCreateNestedOneWithoutTestsInput
    year: YearTableCreateNestedOneWithoutTestsInput
    questions?: QuestionsTableCreateNestedManyWithoutTestInput
    results?: ResultTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateWithoutResponsesInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    questions?: QuestionsTableUncheckedCreateNestedManyWithoutTestInput
    results?: ResultTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableCreateOrConnectWithoutResponsesInput = {
    where: TestTableWhereUniqueInput
    create: XOR<TestTableCreateWithoutResponsesInput, TestTableUncheckedCreateWithoutResponsesInput>
  }

  export type QuestionsTableCreateWithoutResponsesInput = {
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    test: TestTableCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionsTableUncheckedCreateWithoutResponsesInput = {
    id?: number
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    testId: number
  }

  export type QuestionsTableCreateOrConnectWithoutResponsesInput = {
    where: QuestionsTableWhereUniqueInput
    create: XOR<QuestionsTableCreateWithoutResponsesInput, QuestionsTableUncheckedCreateWithoutResponsesInput>
  }

  export type StudentTableUpsertWithoutResponsesInput = {
    update: XOR<StudentTableUpdateWithoutResponsesInput, StudentTableUncheckedUpdateWithoutResponsesInput>
    create: XOR<StudentTableCreateWithoutResponsesInput, StudentTableUncheckedCreateWithoutResponsesInput>
    where?: StudentTableWhereInput
  }

  export type StudentTableUpdateToOneWithWhereWithoutResponsesInput = {
    where?: StudentTableWhereInput
    data: XOR<StudentTableUpdateWithoutResponsesInput, StudentTableUncheckedUpdateWithoutResponsesInput>
  }

  export type StudentTableUpdateWithoutResponsesInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutStudentsNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutStudentsNestedInput
    year?: YearTableUpdateOneRequiredWithoutStudentsNestedInput
    results?: ResultTableUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateWithoutResponsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
    results?: ResultTableUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TestTableUpsertWithoutResponsesInput = {
    update: XOR<TestTableUpdateWithoutResponsesInput, TestTableUncheckedUpdateWithoutResponsesInput>
    create: XOR<TestTableCreateWithoutResponsesInput, TestTableUncheckedCreateWithoutResponsesInput>
    where?: TestTableWhereInput
  }

  export type TestTableUpdateToOneWithWhereWithoutResponsesInput = {
    where?: TestTableWhereInput
    data: XOR<TestTableUpdateWithoutResponsesInput, TestTableUncheckedUpdateWithoutResponsesInput>
  }

  export type TestTableUpdateWithoutResponsesInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutTestsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutTestsNestedInput
    year?: YearTableUpdateOneRequiredWithoutTestsNestedInput
    questions?: QuestionsTableUpdateManyWithoutTestNestedInput
    results?: ResultTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateWithoutResponsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionsTableUncheckedUpdateManyWithoutTestNestedInput
    results?: ResultTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type QuestionsTableUpsertWithoutResponsesInput = {
    update: XOR<QuestionsTableUpdateWithoutResponsesInput, QuestionsTableUncheckedUpdateWithoutResponsesInput>
    create: XOR<QuestionsTableCreateWithoutResponsesInput, QuestionsTableUncheckedCreateWithoutResponsesInput>
    where?: QuestionsTableWhereInput
  }

  export type QuestionsTableUpdateToOneWithWhereWithoutResponsesInput = {
    where?: QuestionsTableWhereInput
    data: XOR<QuestionsTableUpdateWithoutResponsesInput, QuestionsTableUncheckedUpdateWithoutResponsesInput>
  }

  export type QuestionsTableUpdateWithoutResponsesInput = {
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
    test?: TestTableUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionsTableUncheckedUpdateWithoutResponsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherTableCreateWithoutNotesInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    branch: BranchTableCreateNestedOneWithoutTeachersInput
    university: UniversityTableCreateNestedOneWithoutTeachersInput
    tests?: TestTableCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableUncheckedCreateWithoutNotesInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
    universityId: number
    tests?: TestTableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableCreateOrConnectWithoutNotesInput = {
    where: TeacherTableWhereUniqueInput
    create: XOR<TeacherTableCreateWithoutNotesInput, TeacherTableUncheckedCreateWithoutNotesInput>
  }

  export type UniversityTableCreateWithoutNotesInput = {
    name: string
    address: string
    branches?: BranchTableCreateNestedManyWithoutUniversityInput
    students?: StudentTableCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableCreateNestedManyWithoutUniversityInput
    years?: YearTableCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUncheckedCreateWithoutNotesInput = {
    id?: number
    name: string
    address: string
    branches?: BranchTableUncheckedCreateNestedManyWithoutUniversityInput
    students?: StudentTableUncheckedCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutUniversityInput
    years?: YearTableUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableCreateOrConnectWithoutNotesInput = {
    where: UniversityTableWhereUniqueInput
    create: XOR<UniversityTableCreateWithoutNotesInput, UniversityTableUncheckedCreateWithoutNotesInput>
  }

  export type BranchTableCreateWithoutNotesInput = {
    Branchcode: string
    Branchname: string
    university: UniversityTableCreateNestedOneWithoutBranchesInput
    students?: StudentTableCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableCreateNestedManyWithoutBranchInput
    tests?: TestTableCreateNestedManyWithoutBranchInput
    years?: YearTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateWithoutNotesInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutBranchInput
    tests?: TestTableUncheckedCreateNestedManyWithoutBranchInput
    years?: YearTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableCreateOrConnectWithoutNotesInput = {
    where: BranchTableWhereUniqueInput
    create: XOR<BranchTableCreateWithoutNotesInput, BranchTableUncheckedCreateWithoutNotesInput>
  }

  export type YearTableCreateWithoutNotesInput = {
    name: string
    year: number
    university: UniversityTableCreateNestedOneWithoutYearsInput
    branch: BranchTableCreateNestedOneWithoutYearsInput
    students?: StudentTableCreateNestedManyWithoutYearInput
    tests?: TestTableCreateNestedManyWithoutYearInput
  }

  export type YearTableUncheckedCreateWithoutNotesInput = {
    id?: number
    name: string
    year: number
    universityId: number
    branchId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutYearInput
    tests?: TestTableUncheckedCreateNestedManyWithoutYearInput
  }

  export type YearTableCreateOrConnectWithoutNotesInput = {
    where: YearTableWhereUniqueInput
    create: XOR<YearTableCreateWithoutNotesInput, YearTableUncheckedCreateWithoutNotesInput>
  }

  export type TeacherTableUpsertWithoutNotesInput = {
    update: XOR<TeacherTableUpdateWithoutNotesInput, TeacherTableUncheckedUpdateWithoutNotesInput>
    create: XOR<TeacherTableCreateWithoutNotesInput, TeacherTableUncheckedCreateWithoutNotesInput>
    where?: TeacherTableWhereInput
  }

  export type TeacherTableUpdateToOneWithWhereWithoutNotesInput = {
    where?: TeacherTableWhereInput
    data: XOR<TeacherTableUpdateWithoutNotesInput, TeacherTableUncheckedUpdateWithoutNotesInput>
  }

  export type TeacherTableUpdateWithoutNotesInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutTeachersNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutTeachersNestedInput
    tests?: TestTableUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    tests?: TestTableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type UniversityTableUpsertWithoutNotesInput = {
    update: XOR<UniversityTableUpdateWithoutNotesInput, UniversityTableUncheckedUpdateWithoutNotesInput>
    create: XOR<UniversityTableCreateWithoutNotesInput, UniversityTableUncheckedCreateWithoutNotesInput>
    where?: UniversityTableWhereInput
  }

  export type UniversityTableUpdateToOneWithWhereWithoutNotesInput = {
    where?: UniversityTableWhereInput
    data: XOR<UniversityTableUpdateWithoutNotesInput, UniversityTableUncheckedUpdateWithoutNotesInput>
  }

  export type UniversityTableUpdateWithoutNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUpdateManyWithoutUniversityNestedInput
    years?: YearTableUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUncheckedUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUncheckedUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutUniversityNestedInput
    years?: YearTableUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type BranchTableUpsertWithoutNotesInput = {
    update: XOR<BranchTableUpdateWithoutNotesInput, BranchTableUncheckedUpdateWithoutNotesInput>
    create: XOR<BranchTableCreateWithoutNotesInput, BranchTableUncheckedCreateWithoutNotesInput>
    where?: BranchTableWhereInput
  }

  export type BranchTableUpdateToOneWithWhereWithoutNotesInput = {
    where?: BranchTableWhereInput
    data: XOR<BranchTableUpdateWithoutNotesInput, BranchTableUncheckedUpdateWithoutNotesInput>
  }

  export type BranchTableUpdateWithoutNotesInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutBranchesNestedInput
    students?: StudentTableUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUpdateManyWithoutBranchNestedInput
    tests?: TestTableUpdateManyWithoutBranchNestedInput
    years?: YearTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutBranchNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutBranchNestedInput
    years?: YearTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type YearTableUpsertWithoutNotesInput = {
    update: XOR<YearTableUpdateWithoutNotesInput, YearTableUncheckedUpdateWithoutNotesInput>
    create: XOR<YearTableCreateWithoutNotesInput, YearTableUncheckedCreateWithoutNotesInput>
    where?: YearTableWhereInput
  }

  export type YearTableUpdateToOneWithWhereWithoutNotesInput = {
    where?: YearTableWhereInput
    data: XOR<YearTableUpdateWithoutNotesInput, YearTableUncheckedUpdateWithoutNotesInput>
  }

  export type YearTableUpdateWithoutNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    university?: UniversityTableUpdateOneRequiredWithoutYearsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutYearsNestedInput
    students?: StudentTableUpdateManyWithoutYearNestedInput
    tests?: TestTableUpdateManyWithoutYearNestedInput
  }

  export type YearTableUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutYearNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutYearNestedInput
  }

  export type BranchTableCreateManyUniversityInput = {
    id?: number
    Branchcode: string
    Branchname: string
  }

  export type StudentTableCreateManyUniversityInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    yearId: number
  }

  export type TeacherTableCreateManyUniversityInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
  }

  export type YearTableCreateManyUniversityInput = {
    id?: number
    name: string
    year: number
    branchId: number
  }

  export type NotesTableCreateManyUniversityInput = {
    id?: number
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacherId: number
    branchId: number
    yearId: number
  }

  export type BranchTableUpdateWithoutUniversityInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    students?: StudentTableUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUpdateManyWithoutBranchNestedInput
    tests?: TestTableUpdateManyWithoutBranchNestedInput
    years?: YearTableUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    students?: StudentTableUncheckedUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutBranchNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutBranchNestedInput
    years?: YearTableUncheckedUpdateManyWithoutBranchNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateManyWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTableUpdateWithoutUniversityInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutStudentsNestedInput
    year?: YearTableUpdateOneRequiredWithoutStudentsNestedInput
    results?: ResultTableUpdateManyWithoutStudentNestedInput
    responses?: StudentResponseTableUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
    results?: ResultTableUncheckedUpdateManyWithoutStudentNestedInput
    responses?: StudentResponseTableUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateManyWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherTableUpdateWithoutUniversityInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutTeachersNestedInput
    tests?: TestTableUpdateManyWithoutTeacherNestedInput
    notes?: NotesTableUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    tests?: TestTableUncheckedUpdateManyWithoutTeacherNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateManyWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type YearTableUpdateWithoutUniversityInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    branch?: BranchTableUpdateOneRequiredWithoutYearsNestedInput
    students?: StudentTableUpdateManyWithoutYearNestedInput
    tests?: TestTableUpdateManyWithoutYearNestedInput
    notes?: NotesTableUpdateManyWithoutYearNestedInput
  }

  export type YearTableUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutYearNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutYearNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutYearNestedInput
  }

  export type YearTableUncheckedUpdateManyWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NotesTableUpdateWithoutUniversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutNotesNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutNotesNestedInput
    year?: YearTableUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesTableUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type NotesTableUncheckedUpdateManyWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentTableCreateManyBranchInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    universityId: number
    yearId: number
  }

  export type TeacherTableCreateManyBranchInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    universityId: number
  }

  export type TestTableCreateManyBranchInput = {
    id?: number
    title: string
    teacherID: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
  }

  export type YearTableCreateManyBranchInput = {
    id?: number
    name: string
    year: number
    universityId: number
  }

  export type NotesTableCreateManyBranchInput = {
    id?: number
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacherId: number
    universityId: number
    yearId: number
  }

  export type StudentTableUpdateWithoutBranchInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutStudentsNestedInput
    year?: YearTableUpdateOneRequiredWithoutStudentsNestedInput
    results?: ResultTableUpdateManyWithoutStudentNestedInput
    responses?: StudentResponseTableUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
    results?: ResultTableUncheckedUpdateManyWithoutStudentNestedInput
    responses?: StudentResponseTableUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherTableUpdateWithoutBranchInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutTeachersNestedInput
    tests?: TestTableUpdateManyWithoutTeacherNestedInput
    notes?: NotesTableUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    tests?: TestTableUncheckedUpdateManyWithoutTeacherNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type TestTableUpdateWithoutBranchInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutTestsNestedInput
    year?: YearTableUpdateOneRequiredWithoutTestsNestedInput
    questions?: QuestionsTableUpdateManyWithoutTestNestedInput
    results?: ResultTableUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionsTableUncheckedUpdateManyWithoutTestNestedInput
    results?: ResultTableUncheckedUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearTableUpdateWithoutBranchInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    university?: UniversityTableUpdateOneRequiredWithoutYearsNestedInput
    students?: StudentTableUpdateManyWithoutYearNestedInput
    tests?: TestTableUpdateManyWithoutYearNestedInput
    notes?: NotesTableUpdateManyWithoutYearNestedInput
  }

  export type YearTableUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutYearNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutYearNestedInput
    notes?: NotesTableUncheckedUpdateManyWithoutYearNestedInput
  }

  export type YearTableUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type NotesTableUpdateWithoutBranchInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutNotesNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutNotesNestedInput
    year?: YearTableUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesTableUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type NotesTableUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentTableCreateManyYearInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
  }

  export type TestTableCreateManyYearInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
  }

  export type NotesTableCreateManyYearInput = {
    id?: number
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    teacherId: number
    universityId: number
    branchId: number
  }

  export type StudentTableUpdateWithoutYearInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutStudentsNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutStudentsNestedInput
    results?: ResultTableUpdateManyWithoutStudentNestedInput
    responses?: StudentResponseTableUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateWithoutYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    results?: ResultTableUncheckedUpdateManyWithoutStudentNestedInput
    responses?: StudentResponseTableUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateManyWithoutYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type TestTableUpdateWithoutYearInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutTestsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutTestsNestedInput
    questions?: QuestionsTableUpdateManyWithoutTestNestedInput
    results?: ResultTableUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateWithoutYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionsTableUncheckedUpdateManyWithoutTestNestedInput
    results?: ResultTableUncheckedUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateManyWithoutYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotesTableUpdateWithoutYearInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutNotesNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutNotesNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesTableUncheckedUpdateWithoutYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NotesTableUncheckedUpdateManyWithoutYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableCreateManyStudentInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    cheated?: boolean
    testId: number
    tabSwitchCount?: number
    fullScreenExits?: number
    maxFaceCount?: number
  }

  export type StudentResponseTableCreateManyStudentInput = {
    id?: number
    testId: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type ResultTableUpdateWithoutStudentInput = {
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    cheated?: BoolFieldUpdateOperationsInput | boolean
    tabSwitchCount?: IntFieldUpdateOperationsInput | number
    fullScreenExits?: IntFieldUpdateOperationsInput | number
    maxFaceCount?: IntFieldUpdateOperationsInput | number
    test?: TestTableUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ResultTableUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    cheated?: BoolFieldUpdateOperationsInput | boolean
    testId?: IntFieldUpdateOperationsInput | number
    tabSwitchCount?: IntFieldUpdateOperationsInput | number
    fullScreenExits?: IntFieldUpdateOperationsInput | number
    maxFaceCount?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    cheated?: BoolFieldUpdateOperationsInput | boolean
    testId?: IntFieldUpdateOperationsInput | number
    tabSwitchCount?: IntFieldUpdateOperationsInput | number
    fullScreenExits?: IntFieldUpdateOperationsInput | number
    maxFaceCount?: IntFieldUpdateOperationsInput | number
  }

  export type StudentResponseTableUpdateWithoutStudentInput = {
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    test?: TestTableUpdateOneRequiredWithoutResponsesNestedInput
    question?: QuestionsTableUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type StudentResponseTableUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentResponseTableUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestTableCreateManyTeacherInput = {
    id?: number
    title: string
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
  }

  export type NotesTableCreateManyTeacherInput = {
    id?: number
    title: string
    description: string
    driveLink: string
    uploadedAt?: Date | string
    universityId: number
    branchId: number
    yearId: number
  }

  export type TestTableUpdateWithoutTeacherInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchTableUpdateOneRequiredWithoutTestsNestedInput
    year?: YearTableUpdateOneRequiredWithoutTestsNestedInput
    questions?: QuestionsTableUpdateManyWithoutTestNestedInput
    results?: ResultTableUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionsTableUncheckedUpdateManyWithoutTestNestedInput
    results?: ResultTableUncheckedUpdateManyWithoutTestNestedInput
    responses?: StudentResponseTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotesTableUpdateWithoutTeacherInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    university?: UniversityTableUpdateOneRequiredWithoutNotesNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutNotesNestedInput
    year?: YearTableUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesTableUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type NotesTableUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    driveLink?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionsTableCreateManyTestInput = {
    id?: number
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
  }

  export type ResultTableCreateManyTestInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    cheated?: boolean
    studentId: number
    tabSwitchCount?: number
    fullScreenExits?: number
    maxFaceCount?: number
  }

  export type StudentResponseTableCreateManyTestInput = {
    id?: number
    studentId: number
    questionId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type QuestionsTableUpdateWithoutTestInput = {
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
    responses?: StudentResponseTableUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsTableUncheckedUpdateWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
    responses?: StudentResponseTableUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsTableUncheckedUpdateManyWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableUpdateWithoutTestInput = {
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    cheated?: BoolFieldUpdateOperationsInput | boolean
    tabSwitchCount?: IntFieldUpdateOperationsInput | number
    fullScreenExits?: IntFieldUpdateOperationsInput | number
    maxFaceCount?: IntFieldUpdateOperationsInput | number
    student?: StudentTableUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ResultTableUncheckedUpdateWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    cheated?: BoolFieldUpdateOperationsInput | boolean
    studentId?: IntFieldUpdateOperationsInput | number
    tabSwitchCount?: IntFieldUpdateOperationsInput | number
    fullScreenExits?: IntFieldUpdateOperationsInput | number
    maxFaceCount?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableUncheckedUpdateManyWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    cheated?: BoolFieldUpdateOperationsInput | boolean
    studentId?: IntFieldUpdateOperationsInput | number
    tabSwitchCount?: IntFieldUpdateOperationsInput | number
    fullScreenExits?: IntFieldUpdateOperationsInput | number
    maxFaceCount?: IntFieldUpdateOperationsInput | number
  }

  export type StudentResponseTableUpdateWithoutTestInput = {
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentTableUpdateOneRequiredWithoutResponsesNestedInput
    question?: QuestionsTableUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type StudentResponseTableUncheckedUpdateWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentResponseTableUncheckedUpdateManyWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentResponseTableCreateManyQuestionInput = {
    id?: number
    studentId: number
    testId: number
    selectedOption: string
    isCorrect: boolean
  }

  export type StudentResponseTableUpdateWithoutQuestionInput = {
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentTableUpdateOneRequiredWithoutResponsesNestedInput
    test?: TestTableUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type StudentResponseTableUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentResponseTableUncheckedUpdateManyWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UniversityTableCountOutputTypeDefaultArgs instead
     */
    export type UniversityTableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UniversityTableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchTableCountOutputTypeDefaultArgs instead
     */
    export type BranchTableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchTableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use YearTableCountOutputTypeDefaultArgs instead
     */
    export type YearTableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = YearTableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentTableCountOutputTypeDefaultArgs instead
     */
    export type StudentTableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentTableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherTableCountOutputTypeDefaultArgs instead
     */
    export type TeacherTableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherTableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestTableCountOutputTypeDefaultArgs instead
     */
    export type TestTableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestTableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionsTableCountOutputTypeDefaultArgs instead
     */
    export type QuestionsTableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionsTableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UniversityTableDefaultArgs instead
     */
    export type UniversityTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UniversityTableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchTableDefaultArgs instead
     */
    export type BranchTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchTableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use YearTableDefaultArgs instead
     */
    export type YearTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = YearTableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentTableDefaultArgs instead
     */
    export type StudentTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentTableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherTableDefaultArgs instead
     */
    export type TeacherTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherTableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestTableDefaultArgs instead
     */
    export type TestTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestTableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionsTableDefaultArgs instead
     */
    export type QuestionsTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionsTableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResultTableDefaultArgs instead
     */
    export type ResultTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResultTableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentResponseTableDefaultArgs instead
     */
    export type StudentResponseTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentResponseTableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotesTableDefaultArgs instead
     */
    export type NotesTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotesTableDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}