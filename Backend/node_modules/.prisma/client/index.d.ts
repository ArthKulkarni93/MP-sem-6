
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UniversityTable
 * 
 */
export type UniversityTable = $Result.DefaultSelection<Prisma.$UniversityTablePayload>
/**
 * Model BranchTable
 * 
 */
export type BranchTable = $Result.DefaultSelection<Prisma.$BranchTablePayload>
/**
 * Model YearTable
 * 
 */
export type YearTable = $Result.DefaultSelection<Prisma.$YearTablePayload>
/**
 * Model StudentTable
 * 
 */
export type StudentTable = $Result.DefaultSelection<Prisma.$StudentTablePayload>
/**
 * Model TeacherTable
 * 
 */
export type TeacherTable = $Result.DefaultSelection<Prisma.$TeacherTablePayload>
/**
 * Model TestTable
 * 
 */
export type TestTable = $Result.DefaultSelection<Prisma.$TestTablePayload>
/**
 * Model QuestionsTable
 * 
 */
export type QuestionsTable = $Result.DefaultSelection<Prisma.$QuestionsTablePayload>
/**
 * Model ResultTable
 * 
 */
export type ResultTable = $Result.DefaultSelection<Prisma.$ResultTablePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UniversityTables
 * const universityTables = await prisma.universityTable.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UniversityTables
   * const universityTables = await prisma.universityTable.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.universityTable`: Exposes CRUD operations for the **UniversityTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UniversityTables
    * const universityTables = await prisma.universityTable.findMany()
    * ```
    */
  get universityTable(): Prisma.UniversityTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branchTable`: Exposes CRUD operations for the **BranchTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BranchTables
    * const branchTables = await prisma.branchTable.findMany()
    * ```
    */
  get branchTable(): Prisma.BranchTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.yearTable`: Exposes CRUD operations for the **YearTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YearTables
    * const yearTables = await prisma.yearTable.findMany()
    * ```
    */
  get yearTable(): Prisma.YearTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentTable`: Exposes CRUD operations for the **StudentTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentTables
    * const studentTables = await prisma.studentTable.findMany()
    * ```
    */
  get studentTable(): Prisma.StudentTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacherTable`: Exposes CRUD operations for the **TeacherTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherTables
    * const teacherTables = await prisma.teacherTable.findMany()
    * ```
    */
  get teacherTable(): Prisma.TeacherTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testTable`: Exposes CRUD operations for the **TestTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestTables
    * const testTables = await prisma.testTable.findMany()
    * ```
    */
  get testTable(): Prisma.TestTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionsTable`: Exposes CRUD operations for the **QuestionsTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsTables
    * const questionsTables = await prisma.questionsTable.findMany()
    * ```
    */
  get questionsTable(): Prisma.QuestionsTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resultTable`: Exposes CRUD operations for the **ResultTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResultTables
    * const resultTables = await prisma.resultTable.findMany()
    * ```
    */
  get resultTable(): Prisma.ResultTableDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UniversityTable: 'UniversityTable',
    BranchTable: 'BranchTable',
    YearTable: 'YearTable',
    StudentTable: 'StudentTable',
    TeacherTable: 'TeacherTable',
    TestTable: 'TestTable',
    QuestionsTable: 'QuestionsTable',
    ResultTable: 'ResultTable'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "universityTable" | "branchTable" | "yearTable" | "studentTable" | "teacherTable" | "testTable" | "questionsTable" | "resultTable"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UniversityTable: {
        payload: Prisma.$UniversityTablePayload<ExtArgs>
        fields: Prisma.UniversityTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UniversityTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UniversityTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          findFirst: {
            args: Prisma.UniversityTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UniversityTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          findMany: {
            args: Prisma.UniversityTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>[]
          }
          create: {
            args: Prisma.UniversityTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          createMany: {
            args: Prisma.UniversityTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UniversityTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>[]
          }
          delete: {
            args: Prisma.UniversityTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          update: {
            args: Prisma.UniversityTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          deleteMany: {
            args: Prisma.UniversityTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UniversityTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UniversityTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>[]
          }
          upsert: {
            args: Prisma.UniversityTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityTablePayload>
          }
          aggregate: {
            args: Prisma.UniversityTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUniversityTable>
          }
          groupBy: {
            args: Prisma.UniversityTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<UniversityTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.UniversityTableCountArgs<ExtArgs>
            result: $Utils.Optional<UniversityTableCountAggregateOutputType> | number
          }
        }
      }
      BranchTable: {
        payload: Prisma.$BranchTablePayload<ExtArgs>
        fields: Prisma.BranchTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          findFirst: {
            args: Prisma.BranchTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          findMany: {
            args: Prisma.BranchTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>[]
          }
          create: {
            args: Prisma.BranchTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          createMany: {
            args: Prisma.BranchTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>[]
          }
          delete: {
            args: Prisma.BranchTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          update: {
            args: Prisma.BranchTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          deleteMany: {
            args: Prisma.BranchTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BranchTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>[]
          }
          upsert: {
            args: Prisma.BranchTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchTablePayload>
          }
          aggregate: {
            args: Prisma.BranchTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranchTable>
          }
          groupBy: {
            args: Prisma.BranchTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchTableCountArgs<ExtArgs>
            result: $Utils.Optional<BranchTableCountAggregateOutputType> | number
          }
        }
      }
      YearTable: {
        payload: Prisma.$YearTablePayload<ExtArgs>
        fields: Prisma.YearTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YearTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YearTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          findFirst: {
            args: Prisma.YearTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YearTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          findMany: {
            args: Prisma.YearTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>[]
          }
          create: {
            args: Prisma.YearTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          createMany: {
            args: Prisma.YearTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.YearTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>[]
          }
          delete: {
            args: Prisma.YearTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          update: {
            args: Prisma.YearTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          deleteMany: {
            args: Prisma.YearTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YearTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.YearTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>[]
          }
          upsert: {
            args: Prisma.YearTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearTablePayload>
          }
          aggregate: {
            args: Prisma.YearTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYearTable>
          }
          groupBy: {
            args: Prisma.YearTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<YearTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.YearTableCountArgs<ExtArgs>
            result: $Utils.Optional<YearTableCountAggregateOutputType> | number
          }
        }
      }
      StudentTable: {
        payload: Prisma.$StudentTablePayload<ExtArgs>
        fields: Prisma.StudentTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          findFirst: {
            args: Prisma.StudentTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          findMany: {
            args: Prisma.StudentTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>[]
          }
          create: {
            args: Prisma.StudentTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          createMany: {
            args: Prisma.StudentTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>[]
          }
          delete: {
            args: Prisma.StudentTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          update: {
            args: Prisma.StudentTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          deleteMany: {
            args: Prisma.StudentTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>[]
          }
          upsert: {
            args: Prisma.StudentTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTablePayload>
          }
          aggregate: {
            args: Prisma.StudentTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentTable>
          }
          groupBy: {
            args: Prisma.StudentTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentTableCountArgs<ExtArgs>
            result: $Utils.Optional<StudentTableCountAggregateOutputType> | number
          }
        }
      }
      TeacherTable: {
        payload: Prisma.$TeacherTablePayload<ExtArgs>
        fields: Prisma.TeacherTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          findFirst: {
            args: Prisma.TeacherTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          findMany: {
            args: Prisma.TeacherTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>[]
          }
          create: {
            args: Prisma.TeacherTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          createMany: {
            args: Prisma.TeacherTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>[]
          }
          delete: {
            args: Prisma.TeacherTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          update: {
            args: Prisma.TeacherTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          deleteMany: {
            args: Prisma.TeacherTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>[]
          }
          upsert: {
            args: Prisma.TeacherTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherTablePayload>
          }
          aggregate: {
            args: Prisma.TeacherTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherTable>
          }
          groupBy: {
            args: Prisma.TeacherTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherTableCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherTableCountAggregateOutputType> | number
          }
        }
      }
      TestTable: {
        payload: Prisma.$TestTablePayload<ExtArgs>
        fields: Prisma.TestTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          findFirst: {
            args: Prisma.TestTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          findMany: {
            args: Prisma.TestTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>[]
          }
          create: {
            args: Prisma.TestTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          createMany: {
            args: Prisma.TestTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>[]
          }
          delete: {
            args: Prisma.TestTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          update: {
            args: Prisma.TestTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          deleteMany: {
            args: Prisma.TestTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>[]
          }
          upsert: {
            args: Prisma.TestTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTablePayload>
          }
          aggregate: {
            args: Prisma.TestTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestTable>
          }
          groupBy: {
            args: Prisma.TestTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestTableCountArgs<ExtArgs>
            result: $Utils.Optional<TestTableCountAggregateOutputType> | number
          }
        }
      }
      QuestionsTable: {
        payload: Prisma.$QuestionsTablePayload<ExtArgs>
        fields: Prisma.QuestionsTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionsTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionsTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          findFirst: {
            args: Prisma.QuestionsTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionsTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          findMany: {
            args: Prisma.QuestionsTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>[]
          }
          create: {
            args: Prisma.QuestionsTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          createMany: {
            args: Prisma.QuestionsTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionsTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>[]
          }
          delete: {
            args: Prisma.QuestionsTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          update: {
            args: Prisma.QuestionsTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          deleteMany: {
            args: Prisma.QuestionsTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionsTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionsTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>[]
          }
          upsert: {
            args: Prisma.QuestionsTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsTablePayload>
          }
          aggregate: {
            args: Prisma.QuestionsTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionsTable>
          }
          groupBy: {
            args: Prisma.QuestionsTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionsTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionsTableCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionsTableCountAggregateOutputType> | number
          }
        }
      }
      ResultTable: {
        payload: Prisma.$ResultTablePayload<ExtArgs>
        fields: Prisma.ResultTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResultTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResultTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          findFirst: {
            args: Prisma.ResultTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResultTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          findMany: {
            args: Prisma.ResultTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>[]
          }
          create: {
            args: Prisma.ResultTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          createMany: {
            args: Prisma.ResultTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResultTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>[]
          }
          delete: {
            args: Prisma.ResultTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          update: {
            args: Prisma.ResultTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          deleteMany: {
            args: Prisma.ResultTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResultTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResultTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>[]
          }
          upsert: {
            args: Prisma.ResultTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultTablePayload>
          }
          aggregate: {
            args: Prisma.ResultTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResultTable>
          }
          groupBy: {
            args: Prisma.ResultTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResultTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResultTableCountArgs<ExtArgs>
            result: $Utils.Optional<ResultTableCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    universityTable?: UniversityTableOmit
    branchTable?: BranchTableOmit
    yearTable?: YearTableOmit
    studentTable?: StudentTableOmit
    teacherTable?: TeacherTableOmit
    testTable?: TestTableOmit
    questionsTable?: QuestionsTableOmit
    resultTable?: ResultTableOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UniversityTableCountOutputType
   */

  export type UniversityTableCountOutputType = {
    branches: number
    students: number
    teachers: number
  }

  export type UniversityTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | UniversityTableCountOutputTypeCountBranchesArgs
    students?: boolean | UniversityTableCountOutputTypeCountStudentsArgs
    teachers?: boolean | UniversityTableCountOutputTypeCountTeachersArgs
  }

  // Custom InputTypes
  /**
   * UniversityTableCountOutputType without action
   */
  export type UniversityTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTableCountOutputType
     */
    select?: UniversityTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UniversityTableCountOutputType without action
   */
  export type UniversityTableCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchTableWhereInput
  }

  /**
   * UniversityTableCountOutputType without action
   */
  export type UniversityTableCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTableWhereInput
  }

  /**
   * UniversityTableCountOutputType without action
   */
  export type UniversityTableCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherTableWhereInput
  }


  /**
   * Count Type BranchTableCountOutputType
   */

  export type BranchTableCountOutputType = {
    students: number
    teachers: number
    tests: number
  }

  export type BranchTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | BranchTableCountOutputTypeCountStudentsArgs
    teachers?: boolean | BranchTableCountOutputTypeCountTeachersArgs
    tests?: boolean | BranchTableCountOutputTypeCountTestsArgs
  }

  // Custom InputTypes
  /**
   * BranchTableCountOutputType without action
   */
  export type BranchTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTableCountOutputType
     */
    select?: BranchTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchTableCountOutputType without action
   */
  export type BranchTableCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTableWhereInput
  }

  /**
   * BranchTableCountOutputType without action
   */
  export type BranchTableCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherTableWhereInput
  }

  /**
   * BranchTableCountOutputType without action
   */
  export type BranchTableCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTableWhereInput
  }


  /**
   * Count Type YearTableCountOutputType
   */

  export type YearTableCountOutputType = {
    students: number
    tests: number
  }

  export type YearTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | YearTableCountOutputTypeCountStudentsArgs
    tests?: boolean | YearTableCountOutputTypeCountTestsArgs
  }

  // Custom InputTypes
  /**
   * YearTableCountOutputType without action
   */
  export type YearTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTableCountOutputType
     */
    select?: YearTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * YearTableCountOutputType without action
   */
  export type YearTableCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTableWhereInput
  }

  /**
   * YearTableCountOutputType without action
   */
  export type YearTableCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTableWhereInput
  }


  /**
   * Count Type StudentTableCountOutputType
   */

  export type StudentTableCountOutputType = {
    results: number
  }

  export type StudentTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | StudentTableCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * StudentTableCountOutputType without action
   */
  export type StudentTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTableCountOutputType
     */
    select?: StudentTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentTableCountOutputType without action
   */
  export type StudentTableCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultTableWhereInput
  }


  /**
   * Count Type TeacherTableCountOutputType
   */

  export type TeacherTableCountOutputType = {
    tests: number
  }

  export type TeacherTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tests?: boolean | TeacherTableCountOutputTypeCountTestsArgs
  }

  // Custom InputTypes
  /**
   * TeacherTableCountOutputType without action
   */
  export type TeacherTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTableCountOutputType
     */
    select?: TeacherTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherTableCountOutputType without action
   */
  export type TeacherTableCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTableWhereInput
  }


  /**
   * Count Type TestTableCountOutputType
   */

  export type TestTableCountOutputType = {
    questions: number
    results: number
  }

  export type TestTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | TestTableCountOutputTypeCountQuestionsArgs
    results?: boolean | TestTableCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * TestTableCountOutputType without action
   */
  export type TestTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTableCountOutputType
     */
    select?: TestTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestTableCountOutputType without action
   */
  export type TestTableCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsTableWhereInput
  }

  /**
   * TestTableCountOutputType without action
   */
  export type TestTableCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultTableWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UniversityTable
   */

  export type AggregateUniversityTable = {
    _count: UniversityTableCountAggregateOutputType | null
    _avg: UniversityTableAvgAggregateOutputType | null
    _sum: UniversityTableSumAggregateOutputType | null
    _min: UniversityTableMinAggregateOutputType | null
    _max: UniversityTableMaxAggregateOutputType | null
  }

  export type UniversityTableAvgAggregateOutputType = {
    id: number | null
  }

  export type UniversityTableSumAggregateOutputType = {
    id: number | null
  }

  export type UniversityTableMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
  }

  export type UniversityTableMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
  }

  export type UniversityTableCountAggregateOutputType = {
    id: number
    name: number
    address: number
    _all: number
  }


  export type UniversityTableAvgAggregateInputType = {
    id?: true
  }

  export type UniversityTableSumAggregateInputType = {
    id?: true
  }

  export type UniversityTableMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
  }

  export type UniversityTableMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
  }

  export type UniversityTableCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    _all?: true
  }

  export type UniversityTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UniversityTable to aggregate.
     */
    where?: UniversityTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityTables to fetch.
     */
    orderBy?: UniversityTableOrderByWithRelationInput | UniversityTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UniversityTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UniversityTables
    **/
    _count?: true | UniversityTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UniversityTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UniversityTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UniversityTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UniversityTableMaxAggregateInputType
  }

  export type GetUniversityTableAggregateType<T extends UniversityTableAggregateArgs> = {
        [P in keyof T & keyof AggregateUniversityTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniversityTable[P]>
      : GetScalarType<T[P], AggregateUniversityTable[P]>
  }




  export type UniversityTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UniversityTableWhereInput
    orderBy?: UniversityTableOrderByWithAggregationInput | UniversityTableOrderByWithAggregationInput[]
    by: UniversityTableScalarFieldEnum[] | UniversityTableScalarFieldEnum
    having?: UniversityTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UniversityTableCountAggregateInputType | true
    _avg?: UniversityTableAvgAggregateInputType
    _sum?: UniversityTableSumAggregateInputType
    _min?: UniversityTableMinAggregateInputType
    _max?: UniversityTableMaxAggregateInputType
  }

  export type UniversityTableGroupByOutputType = {
    id: number
    name: string
    address: string
    _count: UniversityTableCountAggregateOutputType | null
    _avg: UniversityTableAvgAggregateOutputType | null
    _sum: UniversityTableSumAggregateOutputType | null
    _min: UniversityTableMinAggregateOutputType | null
    _max: UniversityTableMaxAggregateOutputType | null
  }

  type GetUniversityTableGroupByPayload<T extends UniversityTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UniversityTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UniversityTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UniversityTableGroupByOutputType[P]>
            : GetScalarType<T[P], UniversityTableGroupByOutputType[P]>
        }
      >
    >


  export type UniversityTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    branches?: boolean | UniversityTable$branchesArgs<ExtArgs>
    students?: boolean | UniversityTable$studentsArgs<ExtArgs>
    teachers?: boolean | UniversityTable$teachersArgs<ExtArgs>
    _count?: boolean | UniversityTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["universityTable"]>

  export type UniversityTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
  }, ExtArgs["result"]["universityTable"]>

  export type UniversityTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
  }, ExtArgs["result"]["universityTable"]>

  export type UniversityTableSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
  }

  export type UniversityTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address", ExtArgs["result"]["universityTable"]>
  export type UniversityTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | UniversityTable$branchesArgs<ExtArgs>
    students?: boolean | UniversityTable$studentsArgs<ExtArgs>
    teachers?: boolean | UniversityTable$teachersArgs<ExtArgs>
    _count?: boolean | UniversityTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UniversityTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UniversityTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UniversityTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UniversityTable"
    objects: {
      branches: Prisma.$BranchTablePayload<ExtArgs>[]
      students: Prisma.$StudentTablePayload<ExtArgs>[]
      teachers: Prisma.$TeacherTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string
    }, ExtArgs["result"]["universityTable"]>
    composites: {}
  }

  type UniversityTableGetPayload<S extends boolean | null | undefined | UniversityTableDefaultArgs> = $Result.GetResult<Prisma.$UniversityTablePayload, S>

  type UniversityTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UniversityTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UniversityTableCountAggregateInputType | true
    }

  export interface UniversityTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UniversityTable'], meta: { name: 'UniversityTable' } }
    /**
     * Find zero or one UniversityTable that matches the filter.
     * @param {UniversityTableFindUniqueArgs} args - Arguments to find a UniversityTable
     * @example
     * // Get one UniversityTable
     * const universityTable = await prisma.universityTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UniversityTableFindUniqueArgs>(args: SelectSubset<T, UniversityTableFindUniqueArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UniversityTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UniversityTableFindUniqueOrThrowArgs} args - Arguments to find a UniversityTable
     * @example
     * // Get one UniversityTable
     * const universityTable = await prisma.universityTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UniversityTableFindUniqueOrThrowArgs>(args: SelectSubset<T, UniversityTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UniversityTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableFindFirstArgs} args - Arguments to find a UniversityTable
     * @example
     * // Get one UniversityTable
     * const universityTable = await prisma.universityTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UniversityTableFindFirstArgs>(args?: SelectSubset<T, UniversityTableFindFirstArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UniversityTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableFindFirstOrThrowArgs} args - Arguments to find a UniversityTable
     * @example
     * // Get one UniversityTable
     * const universityTable = await prisma.universityTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UniversityTableFindFirstOrThrowArgs>(args?: SelectSubset<T, UniversityTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UniversityTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UniversityTables
     * const universityTables = await prisma.universityTable.findMany()
     * 
     * // Get first 10 UniversityTables
     * const universityTables = await prisma.universityTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const universityTableWithIdOnly = await prisma.universityTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UniversityTableFindManyArgs>(args?: SelectSubset<T, UniversityTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UniversityTable.
     * @param {UniversityTableCreateArgs} args - Arguments to create a UniversityTable.
     * @example
     * // Create one UniversityTable
     * const UniversityTable = await prisma.universityTable.create({
     *   data: {
     *     // ... data to create a UniversityTable
     *   }
     * })
     * 
     */
    create<T extends UniversityTableCreateArgs>(args: SelectSubset<T, UniversityTableCreateArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UniversityTables.
     * @param {UniversityTableCreateManyArgs} args - Arguments to create many UniversityTables.
     * @example
     * // Create many UniversityTables
     * const universityTable = await prisma.universityTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UniversityTableCreateManyArgs>(args?: SelectSubset<T, UniversityTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UniversityTables and returns the data saved in the database.
     * @param {UniversityTableCreateManyAndReturnArgs} args - Arguments to create many UniversityTables.
     * @example
     * // Create many UniversityTables
     * const universityTable = await prisma.universityTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UniversityTables and only return the `id`
     * const universityTableWithIdOnly = await prisma.universityTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UniversityTableCreateManyAndReturnArgs>(args?: SelectSubset<T, UniversityTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UniversityTable.
     * @param {UniversityTableDeleteArgs} args - Arguments to delete one UniversityTable.
     * @example
     * // Delete one UniversityTable
     * const UniversityTable = await prisma.universityTable.delete({
     *   where: {
     *     // ... filter to delete one UniversityTable
     *   }
     * })
     * 
     */
    delete<T extends UniversityTableDeleteArgs>(args: SelectSubset<T, UniversityTableDeleteArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UniversityTable.
     * @param {UniversityTableUpdateArgs} args - Arguments to update one UniversityTable.
     * @example
     * // Update one UniversityTable
     * const universityTable = await prisma.universityTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UniversityTableUpdateArgs>(args: SelectSubset<T, UniversityTableUpdateArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UniversityTables.
     * @param {UniversityTableDeleteManyArgs} args - Arguments to filter UniversityTables to delete.
     * @example
     * // Delete a few UniversityTables
     * const { count } = await prisma.universityTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UniversityTableDeleteManyArgs>(args?: SelectSubset<T, UniversityTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UniversityTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UniversityTables
     * const universityTable = await prisma.universityTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UniversityTableUpdateManyArgs>(args: SelectSubset<T, UniversityTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UniversityTables and returns the data updated in the database.
     * @param {UniversityTableUpdateManyAndReturnArgs} args - Arguments to update many UniversityTables.
     * @example
     * // Update many UniversityTables
     * const universityTable = await prisma.universityTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UniversityTables and only return the `id`
     * const universityTableWithIdOnly = await prisma.universityTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UniversityTableUpdateManyAndReturnArgs>(args: SelectSubset<T, UniversityTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UniversityTable.
     * @param {UniversityTableUpsertArgs} args - Arguments to update or create a UniversityTable.
     * @example
     * // Update or create a UniversityTable
     * const universityTable = await prisma.universityTable.upsert({
     *   create: {
     *     // ... data to create a UniversityTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UniversityTable we want to update
     *   }
     * })
     */
    upsert<T extends UniversityTableUpsertArgs>(args: SelectSubset<T, UniversityTableUpsertArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UniversityTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableCountArgs} args - Arguments to filter UniversityTables to count.
     * @example
     * // Count the number of UniversityTables
     * const count = await prisma.universityTable.count({
     *   where: {
     *     // ... the filter for the UniversityTables we want to count
     *   }
     * })
    **/
    count<T extends UniversityTableCountArgs>(
      args?: Subset<T, UniversityTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UniversityTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UniversityTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UniversityTableAggregateArgs>(args: Subset<T, UniversityTableAggregateArgs>): Prisma.PrismaPromise<GetUniversityTableAggregateType<T>>

    /**
     * Group by UniversityTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UniversityTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UniversityTableGroupByArgs['orderBy'] }
        : { orderBy?: UniversityTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UniversityTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniversityTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UniversityTable model
   */
  readonly fields: UniversityTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UniversityTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UniversityTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branches<T extends UniversityTable$branchesArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTable$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    students<T extends UniversityTable$studentsArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTable$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    teachers<T extends UniversityTable$teachersArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTable$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UniversityTable model
   */ 
  interface UniversityTableFieldRefs {
    readonly id: FieldRef<"UniversityTable", 'Int'>
    readonly name: FieldRef<"UniversityTable", 'String'>
    readonly address: FieldRef<"UniversityTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UniversityTable findUnique
   */
  export type UniversityTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter, which UniversityTable to fetch.
     */
    where: UniversityTableWhereUniqueInput
  }

  /**
   * UniversityTable findUniqueOrThrow
   */
  export type UniversityTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter, which UniversityTable to fetch.
     */
    where: UniversityTableWhereUniqueInput
  }

  /**
   * UniversityTable findFirst
   */
  export type UniversityTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter, which UniversityTable to fetch.
     */
    where?: UniversityTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityTables to fetch.
     */
    orderBy?: UniversityTableOrderByWithRelationInput | UniversityTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniversityTables.
     */
    cursor?: UniversityTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniversityTables.
     */
    distinct?: UniversityTableScalarFieldEnum | UniversityTableScalarFieldEnum[]
  }

  /**
   * UniversityTable findFirstOrThrow
   */
  export type UniversityTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter, which UniversityTable to fetch.
     */
    where?: UniversityTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityTables to fetch.
     */
    orderBy?: UniversityTableOrderByWithRelationInput | UniversityTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniversityTables.
     */
    cursor?: UniversityTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniversityTables.
     */
    distinct?: UniversityTableScalarFieldEnum | UniversityTableScalarFieldEnum[]
  }

  /**
   * UniversityTable findMany
   */
  export type UniversityTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter, which UniversityTables to fetch.
     */
    where?: UniversityTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityTables to fetch.
     */
    orderBy?: UniversityTableOrderByWithRelationInput | UniversityTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UniversityTables.
     */
    cursor?: UniversityTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityTables.
     */
    skip?: number
    distinct?: UniversityTableScalarFieldEnum | UniversityTableScalarFieldEnum[]
  }

  /**
   * UniversityTable create
   */
  export type UniversityTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * The data needed to create a UniversityTable.
     */
    data: XOR<UniversityTableCreateInput, UniversityTableUncheckedCreateInput>
  }

  /**
   * UniversityTable createMany
   */
  export type UniversityTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UniversityTables.
     */
    data: UniversityTableCreateManyInput | UniversityTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UniversityTable createManyAndReturn
   */
  export type UniversityTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * The data used to create many UniversityTables.
     */
    data: UniversityTableCreateManyInput | UniversityTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UniversityTable update
   */
  export type UniversityTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * The data needed to update a UniversityTable.
     */
    data: XOR<UniversityTableUpdateInput, UniversityTableUncheckedUpdateInput>
    /**
     * Choose, which UniversityTable to update.
     */
    where: UniversityTableWhereUniqueInput
  }

  /**
   * UniversityTable updateMany
   */
  export type UniversityTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UniversityTables.
     */
    data: XOR<UniversityTableUpdateManyMutationInput, UniversityTableUncheckedUpdateManyInput>
    /**
     * Filter which UniversityTables to update
     */
    where?: UniversityTableWhereInput
  }

  /**
   * UniversityTable updateManyAndReturn
   */
  export type UniversityTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * The data used to update UniversityTables.
     */
    data: XOR<UniversityTableUpdateManyMutationInput, UniversityTableUncheckedUpdateManyInput>
    /**
     * Filter which UniversityTables to update
     */
    where?: UniversityTableWhereInput
  }

  /**
   * UniversityTable upsert
   */
  export type UniversityTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * The filter to search for the UniversityTable to update in case it exists.
     */
    where: UniversityTableWhereUniqueInput
    /**
     * In case the UniversityTable found by the `where` argument doesn't exist, create a new UniversityTable with this data.
     */
    create: XOR<UniversityTableCreateInput, UniversityTableUncheckedCreateInput>
    /**
     * In case the UniversityTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UniversityTableUpdateInput, UniversityTableUncheckedUpdateInput>
  }

  /**
   * UniversityTable delete
   */
  export type UniversityTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityTableInclude<ExtArgs> | null
    /**
     * Filter which UniversityTable to delete.
     */
    where: UniversityTableWhereUniqueInput
  }

  /**
   * UniversityTable deleteMany
   */
  export type UniversityTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UniversityTables to delete
     */
    where?: UniversityTableWhereInput
  }

  /**
   * UniversityTable.branches
   */
  export type UniversityTable$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableInclude<ExtArgs> | null
    where?: BranchTableWhereInput
    orderBy?: BranchTableOrderByWithRelationInput | BranchTableOrderByWithRelationInput[]
    cursor?: BranchTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchTableScalarFieldEnum | BranchTableScalarFieldEnum[]
  }

  /**
   * UniversityTable.students
   */
  export type UniversityTable$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    where?: StudentTableWhereInput
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    cursor?: StudentTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }

  /**
   * UniversityTable.teachers
   */
  export type UniversityTable$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
    where?: TeacherTableWhereInput
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    cursor?: TeacherTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherTableScalarFieldEnum | TeacherTableScalarFieldEnum[]
  }

  /**
   * UniversityTable without action
   */
  export type UniversityTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityTable
     */
    select?: UniversityTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityTable
     */
    omit?: UniversityTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityTableInclude<ExtArgs> | null
  }


  /**
   * Model BranchTable
   */

  export type AggregateBranchTable = {
    _count: BranchTableCountAggregateOutputType | null
    _avg: BranchTableAvgAggregateOutputType | null
    _sum: BranchTableSumAggregateOutputType | null
    _min: BranchTableMinAggregateOutputType | null
    _max: BranchTableMaxAggregateOutputType | null
  }

  export type BranchTableAvgAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type BranchTableSumAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type BranchTableMinAggregateOutputType = {
    id: number | null
    Branchcode: string | null
    Branchname: string | null
    universityId: number | null
  }

  export type BranchTableMaxAggregateOutputType = {
    id: number | null
    Branchcode: string | null
    Branchname: string | null
    universityId: number | null
  }

  export type BranchTableCountAggregateOutputType = {
    id: number
    Branchcode: number
    Branchname: number
    universityId: number
    _all: number
  }


  export type BranchTableAvgAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type BranchTableSumAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type BranchTableMinAggregateInputType = {
    id?: true
    Branchcode?: true
    Branchname?: true
    universityId?: true
  }

  export type BranchTableMaxAggregateInputType = {
    id?: true
    Branchcode?: true
    Branchname?: true
    universityId?: true
  }

  export type BranchTableCountAggregateInputType = {
    id?: true
    Branchcode?: true
    Branchname?: true
    universityId?: true
    _all?: true
  }

  export type BranchTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchTable to aggregate.
     */
    where?: BranchTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchTables to fetch.
     */
    orderBy?: BranchTableOrderByWithRelationInput | BranchTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BranchTables
    **/
    _count?: true | BranchTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchTableMaxAggregateInputType
  }

  export type GetBranchTableAggregateType<T extends BranchTableAggregateArgs> = {
        [P in keyof T & keyof AggregateBranchTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranchTable[P]>
      : GetScalarType<T[P], AggregateBranchTable[P]>
  }




  export type BranchTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchTableWhereInput
    orderBy?: BranchTableOrderByWithAggregationInput | BranchTableOrderByWithAggregationInput[]
    by: BranchTableScalarFieldEnum[] | BranchTableScalarFieldEnum
    having?: BranchTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchTableCountAggregateInputType | true
    _avg?: BranchTableAvgAggregateInputType
    _sum?: BranchTableSumAggregateInputType
    _min?: BranchTableMinAggregateInputType
    _max?: BranchTableMaxAggregateInputType
  }

  export type BranchTableGroupByOutputType = {
    id: number
    Branchcode: string
    Branchname: string
    universityId: number
    _count: BranchTableCountAggregateOutputType | null
    _avg: BranchTableAvgAggregateOutputType | null
    _sum: BranchTableSumAggregateOutputType | null
    _min: BranchTableMinAggregateOutputType | null
    _max: BranchTableMaxAggregateOutputType | null
  }

  type GetBranchTableGroupByPayload<T extends BranchTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchTableGroupByOutputType[P]>
            : GetScalarType<T[P], BranchTableGroupByOutputType[P]>
        }
      >
    >


  export type BranchTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Branchcode?: boolean
    Branchname?: boolean
    universityId?: boolean
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    students?: boolean | BranchTable$studentsArgs<ExtArgs>
    teachers?: boolean | BranchTable$teachersArgs<ExtArgs>
    tests?: boolean | BranchTable$testsArgs<ExtArgs>
    _count?: boolean | BranchTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchTable"]>

  export type BranchTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Branchcode?: boolean
    Branchname?: boolean
    universityId?: boolean
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchTable"]>

  export type BranchTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Branchcode?: boolean
    Branchname?: boolean
    universityId?: boolean
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchTable"]>

  export type BranchTableSelectScalar = {
    id?: boolean
    Branchcode?: boolean
    Branchname?: boolean
    universityId?: boolean
  }

  export type BranchTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Branchcode" | "Branchname" | "universityId", ExtArgs["result"]["branchTable"]>
  export type BranchTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    students?: boolean | BranchTable$studentsArgs<ExtArgs>
    teachers?: boolean | BranchTable$teachersArgs<ExtArgs>
    tests?: boolean | BranchTable$testsArgs<ExtArgs>
    _count?: boolean | BranchTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
  }
  export type BranchTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
  }

  export type $BranchTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BranchTable"
    objects: {
      university: Prisma.$UniversityTablePayload<ExtArgs>
      students: Prisma.$StudentTablePayload<ExtArgs>[]
      teachers: Prisma.$TeacherTablePayload<ExtArgs>[]
      tests: Prisma.$TestTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      Branchcode: string
      Branchname: string
      universityId: number
    }, ExtArgs["result"]["branchTable"]>
    composites: {}
  }

  type BranchTableGetPayload<S extends boolean | null | undefined | BranchTableDefaultArgs> = $Result.GetResult<Prisma.$BranchTablePayload, S>

  type BranchTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchTableCountAggregateInputType | true
    }

  export interface BranchTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BranchTable'], meta: { name: 'BranchTable' } }
    /**
     * Find zero or one BranchTable that matches the filter.
     * @param {BranchTableFindUniqueArgs} args - Arguments to find a BranchTable
     * @example
     * // Get one BranchTable
     * const branchTable = await prisma.branchTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchTableFindUniqueArgs>(args: SelectSubset<T, BranchTableFindUniqueArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BranchTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchTableFindUniqueOrThrowArgs} args - Arguments to find a BranchTable
     * @example
     * // Get one BranchTable
     * const branchTable = await prisma.branchTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchTableFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BranchTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableFindFirstArgs} args - Arguments to find a BranchTable
     * @example
     * // Get one BranchTable
     * const branchTable = await prisma.branchTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchTableFindFirstArgs>(args?: SelectSubset<T, BranchTableFindFirstArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BranchTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableFindFirstOrThrowArgs} args - Arguments to find a BranchTable
     * @example
     * // Get one BranchTable
     * const branchTable = await prisma.branchTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchTableFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BranchTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BranchTables
     * const branchTables = await prisma.branchTable.findMany()
     * 
     * // Get first 10 BranchTables
     * const branchTables = await prisma.branchTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchTableWithIdOnly = await prisma.branchTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchTableFindManyArgs>(args?: SelectSubset<T, BranchTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BranchTable.
     * @param {BranchTableCreateArgs} args - Arguments to create a BranchTable.
     * @example
     * // Create one BranchTable
     * const BranchTable = await prisma.branchTable.create({
     *   data: {
     *     // ... data to create a BranchTable
     *   }
     * })
     * 
     */
    create<T extends BranchTableCreateArgs>(args: SelectSubset<T, BranchTableCreateArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BranchTables.
     * @param {BranchTableCreateManyArgs} args - Arguments to create many BranchTables.
     * @example
     * // Create many BranchTables
     * const branchTable = await prisma.branchTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchTableCreateManyArgs>(args?: SelectSubset<T, BranchTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BranchTables and returns the data saved in the database.
     * @param {BranchTableCreateManyAndReturnArgs} args - Arguments to create many BranchTables.
     * @example
     * // Create many BranchTables
     * const branchTable = await prisma.branchTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BranchTables and only return the `id`
     * const branchTableWithIdOnly = await prisma.branchTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchTableCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a BranchTable.
     * @param {BranchTableDeleteArgs} args - Arguments to delete one BranchTable.
     * @example
     * // Delete one BranchTable
     * const BranchTable = await prisma.branchTable.delete({
     *   where: {
     *     // ... filter to delete one BranchTable
     *   }
     * })
     * 
     */
    delete<T extends BranchTableDeleteArgs>(args: SelectSubset<T, BranchTableDeleteArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BranchTable.
     * @param {BranchTableUpdateArgs} args - Arguments to update one BranchTable.
     * @example
     * // Update one BranchTable
     * const branchTable = await prisma.branchTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchTableUpdateArgs>(args: SelectSubset<T, BranchTableUpdateArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BranchTables.
     * @param {BranchTableDeleteManyArgs} args - Arguments to filter BranchTables to delete.
     * @example
     * // Delete a few BranchTables
     * const { count } = await prisma.branchTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchTableDeleteManyArgs>(args?: SelectSubset<T, BranchTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BranchTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BranchTables
     * const branchTable = await prisma.branchTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchTableUpdateManyArgs>(args: SelectSubset<T, BranchTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BranchTables and returns the data updated in the database.
     * @param {BranchTableUpdateManyAndReturnArgs} args - Arguments to update many BranchTables.
     * @example
     * // Update many BranchTables
     * const branchTable = await prisma.branchTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BranchTables and only return the `id`
     * const branchTableWithIdOnly = await prisma.branchTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BranchTableUpdateManyAndReturnArgs>(args: SelectSubset<T, BranchTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one BranchTable.
     * @param {BranchTableUpsertArgs} args - Arguments to update or create a BranchTable.
     * @example
     * // Update or create a BranchTable
     * const branchTable = await prisma.branchTable.upsert({
     *   create: {
     *     // ... data to create a BranchTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BranchTable we want to update
     *   }
     * })
     */
    upsert<T extends BranchTableUpsertArgs>(args: SelectSubset<T, BranchTableUpsertArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BranchTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableCountArgs} args - Arguments to filter BranchTables to count.
     * @example
     * // Count the number of BranchTables
     * const count = await prisma.branchTable.count({
     *   where: {
     *     // ... the filter for the BranchTables we want to count
     *   }
     * })
    **/
    count<T extends BranchTableCountArgs>(
      args?: Subset<T, BranchTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BranchTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchTableAggregateArgs>(args: Subset<T, BranchTableAggregateArgs>): Prisma.PrismaPromise<GetBranchTableAggregateType<T>>

    /**
     * Group by BranchTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchTableGroupByArgs['orderBy'] }
        : { orderBy?: BranchTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BranchTable model
   */
  readonly fields: BranchTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BranchTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    university<T extends UniversityTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTableDefaultArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    students<T extends BranchTable$studentsArgs<ExtArgs> = {}>(args?: Subset<T, BranchTable$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    teachers<T extends BranchTable$teachersArgs<ExtArgs> = {}>(args?: Subset<T, BranchTable$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tests<T extends BranchTable$testsArgs<ExtArgs> = {}>(args?: Subset<T, BranchTable$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BranchTable model
   */ 
  interface BranchTableFieldRefs {
    readonly id: FieldRef<"BranchTable", 'Int'>
    readonly Branchcode: FieldRef<"BranchTable", 'String'>
    readonly Branchname: FieldRef<"BranchTable", 'String'>
    readonly universityId: FieldRef<"BranchTable", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BranchTable findUnique
   */
  export type BranchTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter, which BranchTable to fetch.
     */
    where: BranchTableWhereUniqueInput
  }

  /**
   * BranchTable findUniqueOrThrow
   */
  export type BranchTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter, which BranchTable to fetch.
     */
    where: BranchTableWhereUniqueInput
  }

  /**
   * BranchTable findFirst
   */
  export type BranchTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter, which BranchTable to fetch.
     */
    where?: BranchTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchTables to fetch.
     */
    orderBy?: BranchTableOrderByWithRelationInput | BranchTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchTables.
     */
    cursor?: BranchTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchTables.
     */
    distinct?: BranchTableScalarFieldEnum | BranchTableScalarFieldEnum[]
  }

  /**
   * BranchTable findFirstOrThrow
   */
  export type BranchTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter, which BranchTable to fetch.
     */
    where?: BranchTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchTables to fetch.
     */
    orderBy?: BranchTableOrderByWithRelationInput | BranchTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchTables.
     */
    cursor?: BranchTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchTables.
     */
    distinct?: BranchTableScalarFieldEnum | BranchTableScalarFieldEnum[]
  }

  /**
   * BranchTable findMany
   */
  export type BranchTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter, which BranchTables to fetch.
     */
    where?: BranchTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchTables to fetch.
     */
    orderBy?: BranchTableOrderByWithRelationInput | BranchTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BranchTables.
     */
    cursor?: BranchTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchTables.
     */
    skip?: number
    distinct?: BranchTableScalarFieldEnum | BranchTableScalarFieldEnum[]
  }

  /**
   * BranchTable create
   */
  export type BranchTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * The data needed to create a BranchTable.
     */
    data: XOR<BranchTableCreateInput, BranchTableUncheckedCreateInput>
  }

  /**
   * BranchTable createMany
   */
  export type BranchTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BranchTables.
     */
    data: BranchTableCreateManyInput | BranchTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BranchTable createManyAndReturn
   */
  export type BranchTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * The data used to create many BranchTables.
     */
    data: BranchTableCreateManyInput | BranchTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BranchTable update
   */
  export type BranchTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * The data needed to update a BranchTable.
     */
    data: XOR<BranchTableUpdateInput, BranchTableUncheckedUpdateInput>
    /**
     * Choose, which BranchTable to update.
     */
    where: BranchTableWhereUniqueInput
  }

  /**
   * BranchTable updateMany
   */
  export type BranchTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BranchTables.
     */
    data: XOR<BranchTableUpdateManyMutationInput, BranchTableUncheckedUpdateManyInput>
    /**
     * Filter which BranchTables to update
     */
    where?: BranchTableWhereInput
  }

  /**
   * BranchTable updateManyAndReturn
   */
  export type BranchTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * The data used to update BranchTables.
     */
    data: XOR<BranchTableUpdateManyMutationInput, BranchTableUncheckedUpdateManyInput>
    /**
     * Filter which BranchTables to update
     */
    where?: BranchTableWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BranchTable upsert
   */
  export type BranchTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * The filter to search for the BranchTable to update in case it exists.
     */
    where: BranchTableWhereUniqueInput
    /**
     * In case the BranchTable found by the `where` argument doesn't exist, create a new BranchTable with this data.
     */
    create: XOR<BranchTableCreateInput, BranchTableUncheckedCreateInput>
    /**
     * In case the BranchTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchTableUpdateInput, BranchTableUncheckedUpdateInput>
  }

  /**
   * BranchTable delete
   */
  export type BranchTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableInclude<ExtArgs> | null
    /**
     * Filter which BranchTable to delete.
     */
    where: BranchTableWhereUniqueInput
  }

  /**
   * BranchTable deleteMany
   */
  export type BranchTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchTables to delete
     */
    where?: BranchTableWhereInput
  }

  /**
   * BranchTable.students
   */
  export type BranchTable$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    where?: StudentTableWhereInput
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    cursor?: StudentTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }

  /**
   * BranchTable.teachers
   */
  export type BranchTable$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
    where?: TeacherTableWhereInput
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    cursor?: TeacherTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherTableScalarFieldEnum | TeacherTableScalarFieldEnum[]
  }

  /**
   * BranchTable.tests
   */
  export type BranchTable$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    where?: TestTableWhereInput
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    cursor?: TestTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }

  /**
   * BranchTable without action
   */
  export type BranchTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchTable
     */
    select?: BranchTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchTable
     */
    omit?: BranchTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchTableInclude<ExtArgs> | null
  }


  /**
   * Model YearTable
   */

  export type AggregateYearTable = {
    _count: YearTableCountAggregateOutputType | null
    _avg: YearTableAvgAggregateOutputType | null
    _sum: YearTableSumAggregateOutputType | null
    _min: YearTableMinAggregateOutputType | null
    _max: YearTableMaxAggregateOutputType | null
  }

  export type YearTableAvgAggregateOutputType = {
    id: number | null
    year: number | null
  }

  export type YearTableSumAggregateOutputType = {
    id: number | null
    year: number | null
  }

  export type YearTableMinAggregateOutputType = {
    id: number | null
    name: string | null
    year: number | null
  }

  export type YearTableMaxAggregateOutputType = {
    id: number | null
    name: string | null
    year: number | null
  }

  export type YearTableCountAggregateOutputType = {
    id: number
    name: number
    year: number
    _all: number
  }


  export type YearTableAvgAggregateInputType = {
    id?: true
    year?: true
  }

  export type YearTableSumAggregateInputType = {
    id?: true
    year?: true
  }

  export type YearTableMinAggregateInputType = {
    id?: true
    name?: true
    year?: true
  }

  export type YearTableMaxAggregateInputType = {
    id?: true
    name?: true
    year?: true
  }

  export type YearTableCountAggregateInputType = {
    id?: true
    name?: true
    year?: true
    _all?: true
  }

  export type YearTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearTable to aggregate.
     */
    where?: YearTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearTables to fetch.
     */
    orderBy?: YearTableOrderByWithRelationInput | YearTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YearTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YearTables
    **/
    _count?: true | YearTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YearTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YearTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YearTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YearTableMaxAggregateInputType
  }

  export type GetYearTableAggregateType<T extends YearTableAggregateArgs> = {
        [P in keyof T & keyof AggregateYearTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYearTable[P]>
      : GetScalarType<T[P], AggregateYearTable[P]>
  }




  export type YearTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearTableWhereInput
    orderBy?: YearTableOrderByWithAggregationInput | YearTableOrderByWithAggregationInput[]
    by: YearTableScalarFieldEnum[] | YearTableScalarFieldEnum
    having?: YearTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YearTableCountAggregateInputType | true
    _avg?: YearTableAvgAggregateInputType
    _sum?: YearTableSumAggregateInputType
    _min?: YearTableMinAggregateInputType
    _max?: YearTableMaxAggregateInputType
  }

  export type YearTableGroupByOutputType = {
    id: number
    name: string
    year: number
    _count: YearTableCountAggregateOutputType | null
    _avg: YearTableAvgAggregateOutputType | null
    _sum: YearTableSumAggregateOutputType | null
    _min: YearTableMinAggregateOutputType | null
    _max: YearTableMaxAggregateOutputType | null
  }

  type GetYearTableGroupByPayload<T extends YearTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YearTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YearTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YearTableGroupByOutputType[P]>
            : GetScalarType<T[P], YearTableGroupByOutputType[P]>
        }
      >
    >


  export type YearTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    year?: boolean
    students?: boolean | YearTable$studentsArgs<ExtArgs>
    tests?: boolean | YearTable$testsArgs<ExtArgs>
    _count?: boolean | YearTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearTable"]>

  export type YearTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    year?: boolean
  }, ExtArgs["result"]["yearTable"]>

  export type YearTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    year?: boolean
  }, ExtArgs["result"]["yearTable"]>

  export type YearTableSelectScalar = {
    id?: boolean
    name?: boolean
    year?: boolean
  }

  export type YearTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "year", ExtArgs["result"]["yearTable"]>
  export type YearTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | YearTable$studentsArgs<ExtArgs>
    tests?: boolean | YearTable$testsArgs<ExtArgs>
    _count?: boolean | YearTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type YearTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type YearTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $YearTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YearTable"
    objects: {
      students: Prisma.$StudentTablePayload<ExtArgs>[]
      tests: Prisma.$TestTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      year: number
    }, ExtArgs["result"]["yearTable"]>
    composites: {}
  }

  type YearTableGetPayload<S extends boolean | null | undefined | YearTableDefaultArgs> = $Result.GetResult<Prisma.$YearTablePayload, S>

  type YearTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<YearTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: YearTableCountAggregateInputType | true
    }

  export interface YearTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YearTable'], meta: { name: 'YearTable' } }
    /**
     * Find zero or one YearTable that matches the filter.
     * @param {YearTableFindUniqueArgs} args - Arguments to find a YearTable
     * @example
     * // Get one YearTable
     * const yearTable = await prisma.yearTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YearTableFindUniqueArgs>(args: SelectSubset<T, YearTableFindUniqueArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one YearTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {YearTableFindUniqueOrThrowArgs} args - Arguments to find a YearTable
     * @example
     * // Get one YearTable
     * const yearTable = await prisma.yearTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YearTableFindUniqueOrThrowArgs>(args: SelectSubset<T, YearTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first YearTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableFindFirstArgs} args - Arguments to find a YearTable
     * @example
     * // Get one YearTable
     * const yearTable = await prisma.yearTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YearTableFindFirstArgs>(args?: SelectSubset<T, YearTableFindFirstArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first YearTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableFindFirstOrThrowArgs} args - Arguments to find a YearTable
     * @example
     * // Get one YearTable
     * const yearTable = await prisma.yearTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YearTableFindFirstOrThrowArgs>(args?: SelectSubset<T, YearTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more YearTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YearTables
     * const yearTables = await prisma.yearTable.findMany()
     * 
     * // Get first 10 YearTables
     * const yearTables = await prisma.yearTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yearTableWithIdOnly = await prisma.yearTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YearTableFindManyArgs>(args?: SelectSubset<T, YearTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a YearTable.
     * @param {YearTableCreateArgs} args - Arguments to create a YearTable.
     * @example
     * // Create one YearTable
     * const YearTable = await prisma.yearTable.create({
     *   data: {
     *     // ... data to create a YearTable
     *   }
     * })
     * 
     */
    create<T extends YearTableCreateArgs>(args: SelectSubset<T, YearTableCreateArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many YearTables.
     * @param {YearTableCreateManyArgs} args - Arguments to create many YearTables.
     * @example
     * // Create many YearTables
     * const yearTable = await prisma.yearTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YearTableCreateManyArgs>(args?: SelectSubset<T, YearTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many YearTables and returns the data saved in the database.
     * @param {YearTableCreateManyAndReturnArgs} args - Arguments to create many YearTables.
     * @example
     * // Create many YearTables
     * const yearTable = await prisma.yearTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many YearTables and only return the `id`
     * const yearTableWithIdOnly = await prisma.yearTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends YearTableCreateManyAndReturnArgs>(args?: SelectSubset<T, YearTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a YearTable.
     * @param {YearTableDeleteArgs} args - Arguments to delete one YearTable.
     * @example
     * // Delete one YearTable
     * const YearTable = await prisma.yearTable.delete({
     *   where: {
     *     // ... filter to delete one YearTable
     *   }
     * })
     * 
     */
    delete<T extends YearTableDeleteArgs>(args: SelectSubset<T, YearTableDeleteArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one YearTable.
     * @param {YearTableUpdateArgs} args - Arguments to update one YearTable.
     * @example
     * // Update one YearTable
     * const yearTable = await prisma.yearTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YearTableUpdateArgs>(args: SelectSubset<T, YearTableUpdateArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more YearTables.
     * @param {YearTableDeleteManyArgs} args - Arguments to filter YearTables to delete.
     * @example
     * // Delete a few YearTables
     * const { count } = await prisma.yearTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YearTableDeleteManyArgs>(args?: SelectSubset<T, YearTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YearTables
     * const yearTable = await prisma.yearTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YearTableUpdateManyArgs>(args: SelectSubset<T, YearTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearTables and returns the data updated in the database.
     * @param {YearTableUpdateManyAndReturnArgs} args - Arguments to update many YearTables.
     * @example
     * // Update many YearTables
     * const yearTable = await prisma.yearTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more YearTables and only return the `id`
     * const yearTableWithIdOnly = await prisma.yearTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends YearTableUpdateManyAndReturnArgs>(args: SelectSubset<T, YearTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one YearTable.
     * @param {YearTableUpsertArgs} args - Arguments to update or create a YearTable.
     * @example
     * // Update or create a YearTable
     * const yearTable = await prisma.yearTable.upsert({
     *   create: {
     *     // ... data to create a YearTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YearTable we want to update
     *   }
     * })
     */
    upsert<T extends YearTableUpsertArgs>(args: SelectSubset<T, YearTableUpsertArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of YearTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableCountArgs} args - Arguments to filter YearTables to count.
     * @example
     * // Count the number of YearTables
     * const count = await prisma.yearTable.count({
     *   where: {
     *     // ... the filter for the YearTables we want to count
     *   }
     * })
    **/
    count<T extends YearTableCountArgs>(
      args?: Subset<T, YearTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YearTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YearTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YearTableAggregateArgs>(args: Subset<T, YearTableAggregateArgs>): Prisma.PrismaPromise<GetYearTableAggregateType<T>>

    /**
     * Group by YearTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YearTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearTableGroupByArgs['orderBy'] }
        : { orderBy?: YearTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YearTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYearTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YearTable model
   */
  readonly fields: YearTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YearTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YearTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends YearTable$studentsArgs<ExtArgs> = {}>(args?: Subset<T, YearTable$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tests<T extends YearTable$testsArgs<ExtArgs> = {}>(args?: Subset<T, YearTable$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YearTable model
   */ 
  interface YearTableFieldRefs {
    readonly id: FieldRef<"YearTable", 'Int'>
    readonly name: FieldRef<"YearTable", 'String'>
    readonly year: FieldRef<"YearTable", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * YearTable findUnique
   */
  export type YearTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter, which YearTable to fetch.
     */
    where: YearTableWhereUniqueInput
  }

  /**
   * YearTable findUniqueOrThrow
   */
  export type YearTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter, which YearTable to fetch.
     */
    where: YearTableWhereUniqueInput
  }

  /**
   * YearTable findFirst
   */
  export type YearTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter, which YearTable to fetch.
     */
    where?: YearTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearTables to fetch.
     */
    orderBy?: YearTableOrderByWithRelationInput | YearTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearTables.
     */
    cursor?: YearTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearTables.
     */
    distinct?: YearTableScalarFieldEnum | YearTableScalarFieldEnum[]
  }

  /**
   * YearTable findFirstOrThrow
   */
  export type YearTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter, which YearTable to fetch.
     */
    where?: YearTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearTables to fetch.
     */
    orderBy?: YearTableOrderByWithRelationInput | YearTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearTables.
     */
    cursor?: YearTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearTables.
     */
    distinct?: YearTableScalarFieldEnum | YearTableScalarFieldEnum[]
  }

  /**
   * YearTable findMany
   */
  export type YearTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter, which YearTables to fetch.
     */
    where?: YearTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearTables to fetch.
     */
    orderBy?: YearTableOrderByWithRelationInput | YearTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YearTables.
     */
    cursor?: YearTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearTables.
     */
    skip?: number
    distinct?: YearTableScalarFieldEnum | YearTableScalarFieldEnum[]
  }

  /**
   * YearTable create
   */
  export type YearTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * The data needed to create a YearTable.
     */
    data: XOR<YearTableCreateInput, YearTableUncheckedCreateInput>
  }

  /**
   * YearTable createMany
   */
  export type YearTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YearTables.
     */
    data: YearTableCreateManyInput | YearTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YearTable createManyAndReturn
   */
  export type YearTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * The data used to create many YearTables.
     */
    data: YearTableCreateManyInput | YearTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YearTable update
   */
  export type YearTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * The data needed to update a YearTable.
     */
    data: XOR<YearTableUpdateInput, YearTableUncheckedUpdateInput>
    /**
     * Choose, which YearTable to update.
     */
    where: YearTableWhereUniqueInput
  }

  /**
   * YearTable updateMany
   */
  export type YearTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YearTables.
     */
    data: XOR<YearTableUpdateManyMutationInput, YearTableUncheckedUpdateManyInput>
    /**
     * Filter which YearTables to update
     */
    where?: YearTableWhereInput
  }

  /**
   * YearTable updateManyAndReturn
   */
  export type YearTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * The data used to update YearTables.
     */
    data: XOR<YearTableUpdateManyMutationInput, YearTableUncheckedUpdateManyInput>
    /**
     * Filter which YearTables to update
     */
    where?: YearTableWhereInput
  }

  /**
   * YearTable upsert
   */
  export type YearTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * The filter to search for the YearTable to update in case it exists.
     */
    where: YearTableWhereUniqueInput
    /**
     * In case the YearTable found by the `where` argument doesn't exist, create a new YearTable with this data.
     */
    create: XOR<YearTableCreateInput, YearTableUncheckedCreateInput>
    /**
     * In case the YearTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YearTableUpdateInput, YearTableUncheckedUpdateInput>
  }

  /**
   * YearTable delete
   */
  export type YearTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearTableInclude<ExtArgs> | null
    /**
     * Filter which YearTable to delete.
     */
    where: YearTableWhereUniqueInput
  }

  /**
   * YearTable deleteMany
   */
  export type YearTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearTables to delete
     */
    where?: YearTableWhereInput
  }

  /**
   * YearTable.students
   */
  export type YearTable$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    where?: StudentTableWhereInput
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    cursor?: StudentTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }

  /**
   * YearTable.tests
   */
  export type YearTable$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    where?: TestTableWhereInput
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    cursor?: TestTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }

  /**
   * YearTable without action
   */
  export type YearTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearTable
     */
    select?: YearTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearTable
     */
    omit?: YearTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearTableInclude<ExtArgs> | null
  }


  /**
   * Model StudentTable
   */

  export type AggregateStudentTable = {
    _count: StudentTableCountAggregateOutputType | null
    _avg: StudentTableAvgAggregateOutputType | null
    _sum: StudentTableSumAggregateOutputType | null
    _min: StudentTableMinAggregateOutputType | null
    _max: StudentTableMaxAggregateOutputType | null
  }

  export type StudentTableAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    universityId: number | null
    yearId: number | null
  }

  export type StudentTableSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    universityId: number | null
    yearId: number | null
  }

  export type StudentTableMinAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    PRN: string | null
    branchId: number | null
    universityId: number | null
    yearId: number | null
  }

  export type StudentTableMaxAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    PRN: string | null
    branchId: number | null
    universityId: number | null
    yearId: number | null
  }

  export type StudentTableCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    email: number
    password: number
    PRN: number
    branchId: number
    universityId: number
    yearId: number
    _all: number
  }


  export type StudentTableAvgAggregateInputType = {
    id?: true
    branchId?: true
    universityId?: true
    yearId?: true
  }

  export type StudentTableSumAggregateInputType = {
    id?: true
    branchId?: true
    universityId?: true
    yearId?: true
  }

  export type StudentTableMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    PRN?: true
    branchId?: true
    universityId?: true
    yearId?: true
  }

  export type StudentTableMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    PRN?: true
    branchId?: true
    universityId?: true
    yearId?: true
  }

  export type StudentTableCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    PRN?: true
    branchId?: true
    universityId?: true
    yearId?: true
    _all?: true
  }

  export type StudentTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTable to aggregate.
     */
    where?: StudentTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTables to fetch.
     */
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentTables
    **/
    _count?: true | StudentTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentTableMaxAggregateInputType
  }

  export type GetStudentTableAggregateType<T extends StudentTableAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentTable[P]>
      : GetScalarType<T[P], AggregateStudentTable[P]>
  }




  export type StudentTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTableWhereInput
    orderBy?: StudentTableOrderByWithAggregationInput | StudentTableOrderByWithAggregationInput[]
    by: StudentTableScalarFieldEnum[] | StudentTableScalarFieldEnum
    having?: StudentTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentTableCountAggregateInputType | true
    _avg?: StudentTableAvgAggregateInputType
    _sum?: StudentTableSumAggregateInputType
    _min?: StudentTableMinAggregateInputType
    _max?: StudentTableMaxAggregateInputType
  }

  export type StudentTableGroupByOutputType = {
    id: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
    yearId: number
    _count: StudentTableCountAggregateOutputType | null
    _avg: StudentTableAvgAggregateOutputType | null
    _sum: StudentTableSumAggregateOutputType | null
    _min: StudentTableMinAggregateOutputType | null
    _max: StudentTableMaxAggregateOutputType | null
  }

  type GetStudentTableGroupByPayload<T extends StudentTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentTableGroupByOutputType[P]>
            : GetScalarType<T[P], StudentTableGroupByOutputType[P]>
        }
      >
    >


  export type StudentTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    PRN?: boolean
    branchId?: boolean
    universityId?: boolean
    yearId?: boolean
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
    results?: boolean | StudentTable$resultsArgs<ExtArgs>
    _count?: boolean | StudentTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTable"]>

  export type StudentTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    PRN?: boolean
    branchId?: boolean
    universityId?: boolean
    yearId?: boolean
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTable"]>

  export type StudentTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    PRN?: boolean
    branchId?: boolean
    universityId?: boolean
    yearId?: boolean
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTable"]>

  export type StudentTableSelectScalar = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    PRN?: boolean
    branchId?: boolean
    universityId?: boolean
    yearId?: boolean
  }

  export type StudentTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstname" | "lastname" | "email" | "password" | "PRN" | "branchId" | "universityId" | "yearId", ExtArgs["result"]["studentTable"]>
  export type StudentTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
    results?: boolean | StudentTable$resultsArgs<ExtArgs>
    _count?: boolean | StudentTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
  }
  export type StudentTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
  }

  export type $StudentTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentTable"
    objects: {
      branch: Prisma.$BranchTablePayload<ExtArgs>
      university: Prisma.$UniversityTablePayload<ExtArgs>
      year: Prisma.$YearTablePayload<ExtArgs>
      results: Prisma.$ResultTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstname: string
      lastname: string
      email: string
      password: string
      PRN: string
      branchId: number
      universityId: number
      yearId: number
    }, ExtArgs["result"]["studentTable"]>
    composites: {}
  }

  type StudentTableGetPayload<S extends boolean | null | undefined | StudentTableDefaultArgs> = $Result.GetResult<Prisma.$StudentTablePayload, S>

  type StudentTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentTableCountAggregateInputType | true
    }

  export interface StudentTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentTable'], meta: { name: 'StudentTable' } }
    /**
     * Find zero or one StudentTable that matches the filter.
     * @param {StudentTableFindUniqueArgs} args - Arguments to find a StudentTable
     * @example
     * // Get one StudentTable
     * const studentTable = await prisma.studentTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentTableFindUniqueArgs>(args: SelectSubset<T, StudentTableFindUniqueArgs<ExtArgs>>): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one StudentTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentTableFindUniqueOrThrowArgs} args - Arguments to find a StudentTable
     * @example
     * // Get one StudentTable
     * const studentTable = await prisma.studentTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentTableFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first StudentTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableFindFirstArgs} args - Arguments to find a StudentTable
     * @example
     * // Get one StudentTable
     * const studentTable = await prisma.studentTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentTableFindFirstArgs>(args?: SelectSubset<T, StudentTableFindFirstArgs<ExtArgs>>): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first StudentTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableFindFirstOrThrowArgs} args - Arguments to find a StudentTable
     * @example
     * // Get one StudentTable
     * const studentTable = await prisma.studentTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentTableFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more StudentTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentTables
     * const studentTables = await prisma.studentTable.findMany()
     * 
     * // Get first 10 StudentTables
     * const studentTables = await prisma.studentTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentTableWithIdOnly = await prisma.studentTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentTableFindManyArgs>(args?: SelectSubset<T, StudentTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a StudentTable.
     * @param {StudentTableCreateArgs} args - Arguments to create a StudentTable.
     * @example
     * // Create one StudentTable
     * const StudentTable = await prisma.studentTable.create({
     *   data: {
     *     // ... data to create a StudentTable
     *   }
     * })
     * 
     */
    create<T extends StudentTableCreateArgs>(args: SelectSubset<T, StudentTableCreateArgs<ExtArgs>>): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many StudentTables.
     * @param {StudentTableCreateManyArgs} args - Arguments to create many StudentTables.
     * @example
     * // Create many StudentTables
     * const studentTable = await prisma.studentTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentTableCreateManyArgs>(args?: SelectSubset<T, StudentTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentTables and returns the data saved in the database.
     * @param {StudentTableCreateManyAndReturnArgs} args - Arguments to create many StudentTables.
     * @example
     * // Create many StudentTables
     * const studentTable = await prisma.studentTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentTables and only return the `id`
     * const studentTableWithIdOnly = await prisma.studentTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentTableCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a StudentTable.
     * @param {StudentTableDeleteArgs} args - Arguments to delete one StudentTable.
     * @example
     * // Delete one StudentTable
     * const StudentTable = await prisma.studentTable.delete({
     *   where: {
     *     // ... filter to delete one StudentTable
     *   }
     * })
     * 
     */
    delete<T extends StudentTableDeleteArgs>(args: SelectSubset<T, StudentTableDeleteArgs<ExtArgs>>): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one StudentTable.
     * @param {StudentTableUpdateArgs} args - Arguments to update one StudentTable.
     * @example
     * // Update one StudentTable
     * const studentTable = await prisma.studentTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentTableUpdateArgs>(args: SelectSubset<T, StudentTableUpdateArgs<ExtArgs>>): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more StudentTables.
     * @param {StudentTableDeleteManyArgs} args - Arguments to filter StudentTables to delete.
     * @example
     * // Delete a few StudentTables
     * const { count } = await prisma.studentTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentTableDeleteManyArgs>(args?: SelectSubset<T, StudentTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentTables
     * const studentTable = await prisma.studentTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentTableUpdateManyArgs>(args: SelectSubset<T, StudentTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTables and returns the data updated in the database.
     * @param {StudentTableUpdateManyAndReturnArgs} args - Arguments to update many StudentTables.
     * @example
     * // Update many StudentTables
     * const studentTable = await prisma.studentTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentTables and only return the `id`
     * const studentTableWithIdOnly = await prisma.studentTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentTableUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one StudentTable.
     * @param {StudentTableUpsertArgs} args - Arguments to update or create a StudentTable.
     * @example
     * // Update or create a StudentTable
     * const studentTable = await prisma.studentTable.upsert({
     *   create: {
     *     // ... data to create a StudentTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentTable we want to update
     *   }
     * })
     */
    upsert<T extends StudentTableUpsertArgs>(args: SelectSubset<T, StudentTableUpsertArgs<ExtArgs>>): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of StudentTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableCountArgs} args - Arguments to filter StudentTables to count.
     * @example
     * // Count the number of StudentTables
     * const count = await prisma.studentTable.count({
     *   where: {
     *     // ... the filter for the StudentTables we want to count
     *   }
     * })
    **/
    count<T extends StudentTableCountArgs>(
      args?: Subset<T, StudentTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentTableAggregateArgs>(args: Subset<T, StudentTableAggregateArgs>): Prisma.PrismaPromise<GetStudentTableAggregateType<T>>

    /**
     * Group by StudentTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentTableGroupByArgs['orderBy'] }
        : { orderBy?: StudentTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentTable model
   */
  readonly fields: StudentTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchTableDefaultArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    university<T extends UniversityTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTableDefaultArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    year<T extends YearTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearTableDefaultArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    results<T extends StudentTable$resultsArgs<ExtArgs> = {}>(args?: Subset<T, StudentTable$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentTable model
   */ 
  interface StudentTableFieldRefs {
    readonly id: FieldRef<"StudentTable", 'Int'>
    readonly firstname: FieldRef<"StudentTable", 'String'>
    readonly lastname: FieldRef<"StudentTable", 'String'>
    readonly email: FieldRef<"StudentTable", 'String'>
    readonly password: FieldRef<"StudentTable", 'String'>
    readonly PRN: FieldRef<"StudentTable", 'String'>
    readonly branchId: FieldRef<"StudentTable", 'Int'>
    readonly universityId: FieldRef<"StudentTable", 'Int'>
    readonly yearId: FieldRef<"StudentTable", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StudentTable findUnique
   */
  export type StudentTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentTable to fetch.
     */
    where: StudentTableWhereUniqueInput
  }

  /**
   * StudentTable findUniqueOrThrow
   */
  export type StudentTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentTable to fetch.
     */
    where: StudentTableWhereUniqueInput
  }

  /**
   * StudentTable findFirst
   */
  export type StudentTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentTable to fetch.
     */
    where?: StudentTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTables to fetch.
     */
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTables.
     */
    cursor?: StudentTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTables.
     */
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }

  /**
   * StudentTable findFirstOrThrow
   */
  export type StudentTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentTable to fetch.
     */
    where?: StudentTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTables to fetch.
     */
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTables.
     */
    cursor?: StudentTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTables.
     */
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }

  /**
   * StudentTable findMany
   */
  export type StudentTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter, which StudentTables to fetch.
     */
    where?: StudentTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTables to fetch.
     */
    orderBy?: StudentTableOrderByWithRelationInput | StudentTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentTables.
     */
    cursor?: StudentTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTables.
     */
    skip?: number
    distinct?: StudentTableScalarFieldEnum | StudentTableScalarFieldEnum[]
  }

  /**
   * StudentTable create
   */
  export type StudentTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentTable.
     */
    data: XOR<StudentTableCreateInput, StudentTableUncheckedCreateInput>
  }

  /**
   * StudentTable createMany
   */
  export type StudentTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentTables.
     */
    data: StudentTableCreateManyInput | StudentTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentTable createManyAndReturn
   */
  export type StudentTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * The data used to create many StudentTables.
     */
    data: StudentTableCreateManyInput | StudentTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTable update
   */
  export type StudentTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentTable.
     */
    data: XOR<StudentTableUpdateInput, StudentTableUncheckedUpdateInput>
    /**
     * Choose, which StudentTable to update.
     */
    where: StudentTableWhereUniqueInput
  }

  /**
   * StudentTable updateMany
   */
  export type StudentTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentTables.
     */
    data: XOR<StudentTableUpdateManyMutationInput, StudentTableUncheckedUpdateManyInput>
    /**
     * Filter which StudentTables to update
     */
    where?: StudentTableWhereInput
  }

  /**
   * StudentTable updateManyAndReturn
   */
  export type StudentTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * The data used to update StudentTables.
     */
    data: XOR<StudentTableUpdateManyMutationInput, StudentTableUncheckedUpdateManyInput>
    /**
     * Filter which StudentTables to update
     */
    where?: StudentTableWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTable upsert
   */
  export type StudentTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentTable to update in case it exists.
     */
    where: StudentTableWhereUniqueInput
    /**
     * In case the StudentTable found by the `where` argument doesn't exist, create a new StudentTable with this data.
     */
    create: XOR<StudentTableCreateInput, StudentTableUncheckedCreateInput>
    /**
     * In case the StudentTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentTableUpdateInput, StudentTableUncheckedUpdateInput>
  }

  /**
   * StudentTable delete
   */
  export type StudentTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
    /**
     * Filter which StudentTable to delete.
     */
    where: StudentTableWhereUniqueInput
  }

  /**
   * StudentTable deleteMany
   */
  export type StudentTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTables to delete
     */
    where?: StudentTableWhereInput
  }

  /**
   * StudentTable.results
   */
  export type StudentTable$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
    where?: ResultTableWhereInput
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    cursor?: ResultTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultTableScalarFieldEnum | ResultTableScalarFieldEnum[]
  }

  /**
   * StudentTable without action
   */
  export type StudentTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTable
     */
    select?: StudentTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTable
     */
    omit?: StudentTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTableInclude<ExtArgs> | null
  }


  /**
   * Model TeacherTable
   */

  export type AggregateTeacherTable = {
    _count: TeacherTableCountAggregateOutputType | null
    _avg: TeacherTableAvgAggregateOutputType | null
    _sum: TeacherTableSumAggregateOutputType | null
    _min: TeacherTableMinAggregateOutputType | null
    _max: TeacherTableMaxAggregateOutputType | null
  }

  export type TeacherTableAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    universityId: number | null
  }

  export type TeacherTableSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    universityId: number | null
  }

  export type TeacherTableMinAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    branchId: number | null
    universityId: number | null
  }

  export type TeacherTableMaxAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    branchId: number | null
    universityId: number | null
  }

  export type TeacherTableCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    email: number
    password: number
    branchId: number
    universityId: number
    _all: number
  }


  export type TeacherTableAvgAggregateInputType = {
    id?: true
    branchId?: true
    universityId?: true
  }

  export type TeacherTableSumAggregateInputType = {
    id?: true
    branchId?: true
    universityId?: true
  }

  export type TeacherTableMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    branchId?: true
    universityId?: true
  }

  export type TeacherTableMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    branchId?: true
    universityId?: true
  }

  export type TeacherTableCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    branchId?: true
    universityId?: true
    _all?: true
  }

  export type TeacherTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherTable to aggregate.
     */
    where?: TeacherTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherTables to fetch.
     */
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherTables
    **/
    _count?: true | TeacherTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherTableMaxAggregateInputType
  }

  export type GetTeacherTableAggregateType<T extends TeacherTableAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherTable[P]>
      : GetScalarType<T[P], AggregateTeacherTable[P]>
  }




  export type TeacherTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherTableWhereInput
    orderBy?: TeacherTableOrderByWithAggregationInput | TeacherTableOrderByWithAggregationInput[]
    by: TeacherTableScalarFieldEnum[] | TeacherTableScalarFieldEnum
    having?: TeacherTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherTableCountAggregateInputType | true
    _avg?: TeacherTableAvgAggregateInputType
    _sum?: TeacherTableSumAggregateInputType
    _min?: TeacherTableMinAggregateInputType
    _max?: TeacherTableMaxAggregateInputType
  }

  export type TeacherTableGroupByOutputType = {
    id: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
    universityId: number
    _count: TeacherTableCountAggregateOutputType | null
    _avg: TeacherTableAvgAggregateOutputType | null
    _sum: TeacherTableSumAggregateOutputType | null
    _min: TeacherTableMinAggregateOutputType | null
    _max: TeacherTableMaxAggregateOutputType | null
  }

  type GetTeacherTableGroupByPayload<T extends TeacherTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherTableGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherTableGroupByOutputType[P]>
        }
      >
    >


  export type TeacherTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    branchId?: boolean
    universityId?: boolean
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    tests?: boolean | TeacherTable$testsArgs<ExtArgs>
    _count?: boolean | TeacherTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherTable"]>

  export type TeacherTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    branchId?: boolean
    universityId?: boolean
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherTable"]>

  export type TeacherTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    branchId?: boolean
    universityId?: boolean
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherTable"]>

  export type TeacherTableSelectScalar = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    branchId?: boolean
    universityId?: boolean
  }

  export type TeacherTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstname" | "lastname" | "email" | "password" | "branchId" | "universityId", ExtArgs["result"]["teacherTable"]>
  export type TeacherTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
    tests?: boolean | TeacherTable$testsArgs<ExtArgs>
    _count?: boolean | TeacherTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeacherTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
  }
  export type TeacherTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    university?: boolean | UniversityTableDefaultArgs<ExtArgs>
  }

  export type $TeacherTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherTable"
    objects: {
      branch: Prisma.$BranchTablePayload<ExtArgs>
      university: Prisma.$UniversityTablePayload<ExtArgs>
      tests: Prisma.$TestTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstname: string
      lastname: string
      email: string
      password: string
      branchId: number
      universityId: number
    }, ExtArgs["result"]["teacherTable"]>
    composites: {}
  }

  type TeacherTableGetPayload<S extends boolean | null | undefined | TeacherTableDefaultArgs> = $Result.GetResult<Prisma.$TeacherTablePayload, S>

  type TeacherTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherTableCountAggregateInputType | true
    }

  export interface TeacherTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherTable'], meta: { name: 'TeacherTable' } }
    /**
     * Find zero or one TeacherTable that matches the filter.
     * @param {TeacherTableFindUniqueArgs} args - Arguments to find a TeacherTable
     * @example
     * // Get one TeacherTable
     * const teacherTable = await prisma.teacherTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherTableFindUniqueArgs>(args: SelectSubset<T, TeacherTableFindUniqueArgs<ExtArgs>>): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TeacherTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherTableFindUniqueOrThrowArgs} args - Arguments to find a TeacherTable
     * @example
     * // Get one TeacherTable
     * const teacherTable = await prisma.teacherTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherTableFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TeacherTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableFindFirstArgs} args - Arguments to find a TeacherTable
     * @example
     * // Get one TeacherTable
     * const teacherTable = await prisma.teacherTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherTableFindFirstArgs>(args?: SelectSubset<T, TeacherTableFindFirstArgs<ExtArgs>>): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TeacherTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableFindFirstOrThrowArgs} args - Arguments to find a TeacherTable
     * @example
     * // Get one TeacherTable
     * const teacherTable = await prisma.teacherTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherTableFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TeacherTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherTables
     * const teacherTables = await prisma.teacherTable.findMany()
     * 
     * // Get first 10 TeacherTables
     * const teacherTables = await prisma.teacherTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherTableWithIdOnly = await prisma.teacherTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherTableFindManyArgs>(args?: SelectSubset<T, TeacherTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TeacherTable.
     * @param {TeacherTableCreateArgs} args - Arguments to create a TeacherTable.
     * @example
     * // Create one TeacherTable
     * const TeacherTable = await prisma.teacherTable.create({
     *   data: {
     *     // ... data to create a TeacherTable
     *   }
     * })
     * 
     */
    create<T extends TeacherTableCreateArgs>(args: SelectSubset<T, TeacherTableCreateArgs<ExtArgs>>): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TeacherTables.
     * @param {TeacherTableCreateManyArgs} args - Arguments to create many TeacherTables.
     * @example
     * // Create many TeacherTables
     * const teacherTable = await prisma.teacherTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherTableCreateManyArgs>(args?: SelectSubset<T, TeacherTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherTables and returns the data saved in the database.
     * @param {TeacherTableCreateManyAndReturnArgs} args - Arguments to create many TeacherTables.
     * @example
     * // Create many TeacherTables
     * const teacherTable = await prisma.teacherTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherTables and only return the `id`
     * const teacherTableWithIdOnly = await prisma.teacherTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherTableCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TeacherTable.
     * @param {TeacherTableDeleteArgs} args - Arguments to delete one TeacherTable.
     * @example
     * // Delete one TeacherTable
     * const TeacherTable = await prisma.teacherTable.delete({
     *   where: {
     *     // ... filter to delete one TeacherTable
     *   }
     * })
     * 
     */
    delete<T extends TeacherTableDeleteArgs>(args: SelectSubset<T, TeacherTableDeleteArgs<ExtArgs>>): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TeacherTable.
     * @param {TeacherTableUpdateArgs} args - Arguments to update one TeacherTable.
     * @example
     * // Update one TeacherTable
     * const teacherTable = await prisma.teacherTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherTableUpdateArgs>(args: SelectSubset<T, TeacherTableUpdateArgs<ExtArgs>>): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TeacherTables.
     * @param {TeacherTableDeleteManyArgs} args - Arguments to filter TeacherTables to delete.
     * @example
     * // Delete a few TeacherTables
     * const { count } = await prisma.teacherTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherTableDeleteManyArgs>(args?: SelectSubset<T, TeacherTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherTables
     * const teacherTable = await prisma.teacherTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherTableUpdateManyArgs>(args: SelectSubset<T, TeacherTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherTables and returns the data updated in the database.
     * @param {TeacherTableUpdateManyAndReturnArgs} args - Arguments to update many TeacherTables.
     * @example
     * // Update many TeacherTables
     * const teacherTable = await prisma.teacherTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeacherTables and only return the `id`
     * const teacherTableWithIdOnly = await prisma.teacherTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherTableUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TeacherTable.
     * @param {TeacherTableUpsertArgs} args - Arguments to update or create a TeacherTable.
     * @example
     * // Update or create a TeacherTable
     * const teacherTable = await prisma.teacherTable.upsert({
     *   create: {
     *     // ... data to create a TeacherTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherTable we want to update
     *   }
     * })
     */
    upsert<T extends TeacherTableUpsertArgs>(args: SelectSubset<T, TeacherTableUpsertArgs<ExtArgs>>): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TeacherTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableCountArgs} args - Arguments to filter TeacherTables to count.
     * @example
     * // Count the number of TeacherTables
     * const count = await prisma.teacherTable.count({
     *   where: {
     *     // ... the filter for the TeacherTables we want to count
     *   }
     * })
    **/
    count<T extends TeacherTableCountArgs>(
      args?: Subset<T, TeacherTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherTableAggregateArgs>(args: Subset<T, TeacherTableAggregateArgs>): Prisma.PrismaPromise<GetTeacherTableAggregateType<T>>

    /**
     * Group by TeacherTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherTableGroupByArgs['orderBy'] }
        : { orderBy?: TeacherTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherTable model
   */
  readonly fields: TeacherTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchTableDefaultArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    university<T extends UniversityTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityTableDefaultArgs<ExtArgs>>): Prisma__UniversityTableClient<$Result.GetResult<Prisma.$UniversityTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    tests<T extends TeacherTable$testsArgs<ExtArgs> = {}>(args?: Subset<T, TeacherTable$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherTable model
   */ 
  interface TeacherTableFieldRefs {
    readonly id: FieldRef<"TeacherTable", 'Int'>
    readonly firstname: FieldRef<"TeacherTable", 'String'>
    readonly lastname: FieldRef<"TeacherTable", 'String'>
    readonly email: FieldRef<"TeacherTable", 'String'>
    readonly password: FieldRef<"TeacherTable", 'String'>
    readonly branchId: FieldRef<"TeacherTable", 'Int'>
    readonly universityId: FieldRef<"TeacherTable", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TeacherTable findUnique
   */
  export type TeacherTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter, which TeacherTable to fetch.
     */
    where: TeacherTableWhereUniqueInput
  }

  /**
   * TeacherTable findUniqueOrThrow
   */
  export type TeacherTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter, which TeacherTable to fetch.
     */
    where: TeacherTableWhereUniqueInput
  }

  /**
   * TeacherTable findFirst
   */
  export type TeacherTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter, which TeacherTable to fetch.
     */
    where?: TeacherTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherTables to fetch.
     */
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherTables.
     */
    cursor?: TeacherTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherTables.
     */
    distinct?: TeacherTableScalarFieldEnum | TeacherTableScalarFieldEnum[]
  }

  /**
   * TeacherTable findFirstOrThrow
   */
  export type TeacherTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter, which TeacherTable to fetch.
     */
    where?: TeacherTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherTables to fetch.
     */
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherTables.
     */
    cursor?: TeacherTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherTables.
     */
    distinct?: TeacherTableScalarFieldEnum | TeacherTableScalarFieldEnum[]
  }

  /**
   * TeacherTable findMany
   */
  export type TeacherTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter, which TeacherTables to fetch.
     */
    where?: TeacherTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherTables to fetch.
     */
    orderBy?: TeacherTableOrderByWithRelationInput | TeacherTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherTables.
     */
    cursor?: TeacherTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherTables.
     */
    skip?: number
    distinct?: TeacherTableScalarFieldEnum | TeacherTableScalarFieldEnum[]
  }

  /**
   * TeacherTable create
   */
  export type TeacherTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherTable.
     */
    data: XOR<TeacherTableCreateInput, TeacherTableUncheckedCreateInput>
  }

  /**
   * TeacherTable createMany
   */
  export type TeacherTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherTables.
     */
    data: TeacherTableCreateManyInput | TeacherTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeacherTable createManyAndReturn
   */
  export type TeacherTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * The data used to create many TeacherTables.
     */
    data: TeacherTableCreateManyInput | TeacherTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherTable update
   */
  export type TeacherTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherTable.
     */
    data: XOR<TeacherTableUpdateInput, TeacherTableUncheckedUpdateInput>
    /**
     * Choose, which TeacherTable to update.
     */
    where: TeacherTableWhereUniqueInput
  }

  /**
   * TeacherTable updateMany
   */
  export type TeacherTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherTables.
     */
    data: XOR<TeacherTableUpdateManyMutationInput, TeacherTableUncheckedUpdateManyInput>
    /**
     * Filter which TeacherTables to update
     */
    where?: TeacherTableWhereInput
  }

  /**
   * TeacherTable updateManyAndReturn
   */
  export type TeacherTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * The data used to update TeacherTables.
     */
    data: XOR<TeacherTableUpdateManyMutationInput, TeacherTableUncheckedUpdateManyInput>
    /**
     * Filter which TeacherTables to update
     */
    where?: TeacherTableWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherTable upsert
   */
  export type TeacherTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherTable to update in case it exists.
     */
    where: TeacherTableWhereUniqueInput
    /**
     * In case the TeacherTable found by the `where` argument doesn't exist, create a new TeacherTable with this data.
     */
    create: XOR<TeacherTableCreateInput, TeacherTableUncheckedCreateInput>
    /**
     * In case the TeacherTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherTableUpdateInput, TeacherTableUncheckedUpdateInput>
  }

  /**
   * TeacherTable delete
   */
  export type TeacherTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
    /**
     * Filter which TeacherTable to delete.
     */
    where: TeacherTableWhereUniqueInput
  }

  /**
   * TeacherTable deleteMany
   */
  export type TeacherTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherTables to delete
     */
    where?: TeacherTableWhereInput
  }

  /**
   * TeacherTable.tests
   */
  export type TeacherTable$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    where?: TestTableWhereInput
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    cursor?: TestTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }

  /**
   * TeacherTable without action
   */
  export type TeacherTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherTable
     */
    select?: TeacherTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherTable
     */
    omit?: TeacherTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherTableInclude<ExtArgs> | null
  }


  /**
   * Model TestTable
   */

  export type AggregateTestTable = {
    _count: TestTableCountAggregateOutputType | null
    _avg: TestTableAvgAggregateOutputType | null
    _sum: TestTableSumAggregateOutputType | null
    _min: TestTableMinAggregateOutputType | null
    _max: TestTableMaxAggregateOutputType | null
  }

  export type TestTableAvgAggregateOutputType = {
    id: number | null
    teacherID: number | null
    branchId: number | null
    yearId: number | null
    totalmarks: number | null
    duration: number | null
  }

  export type TestTableSumAggregateOutputType = {
    id: number | null
    teacherID: number | null
    branchId: number | null
    yearId: number | null
    totalmarks: number | null
    duration: number | null
  }

  export type TestTableMinAggregateOutputType = {
    id: number | null
    title: string | null
    teacherID: number | null
    branchId: number | null
    subject: string | null
    yearId: number | null
    totalmarks: number | null
    duration: number | null
    scheduledDate: Date | null
  }

  export type TestTableMaxAggregateOutputType = {
    id: number | null
    title: string | null
    teacherID: number | null
    branchId: number | null
    subject: string | null
    yearId: number | null
    totalmarks: number | null
    duration: number | null
    scheduledDate: Date | null
  }

  export type TestTableCountAggregateOutputType = {
    id: number
    title: number
    teacherID: number
    branchId: number
    subject: number
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: number
    _all: number
  }


  export type TestTableAvgAggregateInputType = {
    id?: true
    teacherID?: true
    branchId?: true
    yearId?: true
    totalmarks?: true
    duration?: true
  }

  export type TestTableSumAggregateInputType = {
    id?: true
    teacherID?: true
    branchId?: true
    yearId?: true
    totalmarks?: true
    duration?: true
  }

  export type TestTableMinAggregateInputType = {
    id?: true
    title?: true
    teacherID?: true
    branchId?: true
    subject?: true
    yearId?: true
    totalmarks?: true
    duration?: true
    scheduledDate?: true
  }

  export type TestTableMaxAggregateInputType = {
    id?: true
    title?: true
    teacherID?: true
    branchId?: true
    subject?: true
    yearId?: true
    totalmarks?: true
    duration?: true
    scheduledDate?: true
  }

  export type TestTableCountAggregateInputType = {
    id?: true
    title?: true
    teacherID?: true
    branchId?: true
    subject?: true
    yearId?: true
    totalmarks?: true
    duration?: true
    scheduledDate?: true
    _all?: true
  }

  export type TestTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestTable to aggregate.
     */
    where?: TestTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTables to fetch.
     */
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestTables
    **/
    _count?: true | TestTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestTableMaxAggregateInputType
  }

  export type GetTestTableAggregateType<T extends TestTableAggregateArgs> = {
        [P in keyof T & keyof AggregateTestTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestTable[P]>
      : GetScalarType<T[P], AggregateTestTable[P]>
  }




  export type TestTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTableWhereInput
    orderBy?: TestTableOrderByWithAggregationInput | TestTableOrderByWithAggregationInput[]
    by: TestTableScalarFieldEnum[] | TestTableScalarFieldEnum
    having?: TestTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestTableCountAggregateInputType | true
    _avg?: TestTableAvgAggregateInputType
    _sum?: TestTableSumAggregateInputType
    _min?: TestTableMinAggregateInputType
    _max?: TestTableMaxAggregateInputType
  }

  export type TestTableGroupByOutputType = {
    id: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date
    _count: TestTableCountAggregateOutputType | null
    _avg: TestTableAvgAggregateOutputType | null
    _sum: TestTableSumAggregateOutputType | null
    _min: TestTableMinAggregateOutputType | null
    _max: TestTableMaxAggregateOutputType | null
  }

  type GetTestTableGroupByPayload<T extends TestTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestTableGroupByOutputType[P]>
            : GetScalarType<T[P], TestTableGroupByOutputType[P]>
        }
      >
    >


  export type TestTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    teacherID?: boolean
    branchId?: boolean
    subject?: boolean
    yearId?: boolean
    totalmarks?: boolean
    duration?: boolean
    scheduledDate?: boolean
    teacher?: boolean | TeacherTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
    questions?: boolean | TestTable$questionsArgs<ExtArgs>
    results?: boolean | TestTable$resultsArgs<ExtArgs>
    _count?: boolean | TestTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testTable"]>

  export type TestTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    teacherID?: boolean
    branchId?: boolean
    subject?: boolean
    yearId?: boolean
    totalmarks?: boolean
    duration?: boolean
    scheduledDate?: boolean
    teacher?: boolean | TeacherTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testTable"]>

  export type TestTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    teacherID?: boolean
    branchId?: boolean
    subject?: boolean
    yearId?: boolean
    totalmarks?: boolean
    duration?: boolean
    scheduledDate?: boolean
    teacher?: boolean | TeacherTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testTable"]>

  export type TestTableSelectScalar = {
    id?: boolean
    title?: boolean
    teacherID?: boolean
    branchId?: boolean
    subject?: boolean
    yearId?: boolean
    totalmarks?: boolean
    duration?: boolean
    scheduledDate?: boolean
  }

  export type TestTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "teacherID" | "branchId" | "subject" | "yearId" | "totalmarks" | "duration" | "scheduledDate", ExtArgs["result"]["testTable"]>
  export type TestTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
    questions?: boolean | TestTable$questionsArgs<ExtArgs>
    results?: boolean | TestTable$resultsArgs<ExtArgs>
    _count?: boolean | TestTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
  }
  export type TestTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherTableDefaultArgs<ExtArgs>
    branch?: boolean | BranchTableDefaultArgs<ExtArgs>
    year?: boolean | YearTableDefaultArgs<ExtArgs>
  }

  export type $TestTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestTable"
    objects: {
      teacher: Prisma.$TeacherTablePayload<ExtArgs>
      branch: Prisma.$BranchTablePayload<ExtArgs>
      year: Prisma.$YearTablePayload<ExtArgs>
      questions: Prisma.$QuestionsTablePayload<ExtArgs>[]
      results: Prisma.$ResultTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      teacherID: number
      branchId: number
      subject: string
      yearId: number
      totalmarks: number
      duration: number
      scheduledDate: Date
    }, ExtArgs["result"]["testTable"]>
    composites: {}
  }

  type TestTableGetPayload<S extends boolean | null | undefined | TestTableDefaultArgs> = $Result.GetResult<Prisma.$TestTablePayload, S>

  type TestTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestTableCountAggregateInputType | true
    }

  export interface TestTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestTable'], meta: { name: 'TestTable' } }
    /**
     * Find zero or one TestTable that matches the filter.
     * @param {TestTableFindUniqueArgs} args - Arguments to find a TestTable
     * @example
     * // Get one TestTable
     * const testTable = await prisma.testTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestTableFindUniqueArgs>(args: SelectSubset<T, TestTableFindUniqueArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TestTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestTableFindUniqueOrThrowArgs} args - Arguments to find a TestTable
     * @example
     * // Get one TestTable
     * const testTable = await prisma.testTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestTableFindUniqueOrThrowArgs>(args: SelectSubset<T, TestTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TestTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableFindFirstArgs} args - Arguments to find a TestTable
     * @example
     * // Get one TestTable
     * const testTable = await prisma.testTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestTableFindFirstArgs>(args?: SelectSubset<T, TestTableFindFirstArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TestTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableFindFirstOrThrowArgs} args - Arguments to find a TestTable
     * @example
     * // Get one TestTable
     * const testTable = await prisma.testTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestTableFindFirstOrThrowArgs>(args?: SelectSubset<T, TestTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TestTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestTables
     * const testTables = await prisma.testTable.findMany()
     * 
     * // Get first 10 TestTables
     * const testTables = await prisma.testTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testTableWithIdOnly = await prisma.testTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestTableFindManyArgs>(args?: SelectSubset<T, TestTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TestTable.
     * @param {TestTableCreateArgs} args - Arguments to create a TestTable.
     * @example
     * // Create one TestTable
     * const TestTable = await prisma.testTable.create({
     *   data: {
     *     // ... data to create a TestTable
     *   }
     * })
     * 
     */
    create<T extends TestTableCreateArgs>(args: SelectSubset<T, TestTableCreateArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TestTables.
     * @param {TestTableCreateManyArgs} args - Arguments to create many TestTables.
     * @example
     * // Create many TestTables
     * const testTable = await prisma.testTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestTableCreateManyArgs>(args?: SelectSubset<T, TestTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestTables and returns the data saved in the database.
     * @param {TestTableCreateManyAndReturnArgs} args - Arguments to create many TestTables.
     * @example
     * // Create many TestTables
     * const testTable = await prisma.testTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestTables and only return the `id`
     * const testTableWithIdOnly = await prisma.testTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestTableCreateManyAndReturnArgs>(args?: SelectSubset<T, TestTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TestTable.
     * @param {TestTableDeleteArgs} args - Arguments to delete one TestTable.
     * @example
     * // Delete one TestTable
     * const TestTable = await prisma.testTable.delete({
     *   where: {
     *     // ... filter to delete one TestTable
     *   }
     * })
     * 
     */
    delete<T extends TestTableDeleteArgs>(args: SelectSubset<T, TestTableDeleteArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TestTable.
     * @param {TestTableUpdateArgs} args - Arguments to update one TestTable.
     * @example
     * // Update one TestTable
     * const testTable = await prisma.testTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestTableUpdateArgs>(args: SelectSubset<T, TestTableUpdateArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TestTables.
     * @param {TestTableDeleteManyArgs} args - Arguments to filter TestTables to delete.
     * @example
     * // Delete a few TestTables
     * const { count } = await prisma.testTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestTableDeleteManyArgs>(args?: SelectSubset<T, TestTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestTables
     * const testTable = await prisma.testTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestTableUpdateManyArgs>(args: SelectSubset<T, TestTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestTables and returns the data updated in the database.
     * @param {TestTableUpdateManyAndReturnArgs} args - Arguments to update many TestTables.
     * @example
     * // Update many TestTables
     * const testTable = await prisma.testTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestTables and only return the `id`
     * const testTableWithIdOnly = await prisma.testTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestTableUpdateManyAndReturnArgs>(args: SelectSubset<T, TestTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TestTable.
     * @param {TestTableUpsertArgs} args - Arguments to update or create a TestTable.
     * @example
     * // Update or create a TestTable
     * const testTable = await prisma.testTable.upsert({
     *   create: {
     *     // ... data to create a TestTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestTable we want to update
     *   }
     * })
     */
    upsert<T extends TestTableUpsertArgs>(args: SelectSubset<T, TestTableUpsertArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TestTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableCountArgs} args - Arguments to filter TestTables to count.
     * @example
     * // Count the number of TestTables
     * const count = await prisma.testTable.count({
     *   where: {
     *     // ... the filter for the TestTables we want to count
     *   }
     * })
    **/
    count<T extends TestTableCountArgs>(
      args?: Subset<T, TestTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestTableAggregateArgs>(args: Subset<T, TestTableAggregateArgs>): Prisma.PrismaPromise<GetTestTableAggregateType<T>>

    /**
     * Group by TestTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestTableGroupByArgs['orderBy'] }
        : { orderBy?: TestTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestTable model
   */
  readonly fields: TestTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherTableDefaultArgs<ExtArgs>>): Prisma__TeacherTableClient<$Result.GetResult<Prisma.$TeacherTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    branch<T extends BranchTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchTableDefaultArgs<ExtArgs>>): Prisma__BranchTableClient<$Result.GetResult<Prisma.$BranchTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    year<T extends YearTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearTableDefaultArgs<ExtArgs>>): Prisma__YearTableClient<$Result.GetResult<Prisma.$YearTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    questions<T extends TestTable$questionsArgs<ExtArgs> = {}>(args?: Subset<T, TestTable$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    results<T extends TestTable$resultsArgs<ExtArgs> = {}>(args?: Subset<T, TestTable$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestTable model
   */ 
  interface TestTableFieldRefs {
    readonly id: FieldRef<"TestTable", 'Int'>
    readonly title: FieldRef<"TestTable", 'String'>
    readonly teacherID: FieldRef<"TestTable", 'Int'>
    readonly branchId: FieldRef<"TestTable", 'Int'>
    readonly subject: FieldRef<"TestTable", 'String'>
    readonly yearId: FieldRef<"TestTable", 'Int'>
    readonly totalmarks: FieldRef<"TestTable", 'Int'>
    readonly duration: FieldRef<"TestTable", 'Int'>
    readonly scheduledDate: FieldRef<"TestTable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestTable findUnique
   */
  export type TestTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter, which TestTable to fetch.
     */
    where: TestTableWhereUniqueInput
  }

  /**
   * TestTable findUniqueOrThrow
   */
  export type TestTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter, which TestTable to fetch.
     */
    where: TestTableWhereUniqueInput
  }

  /**
   * TestTable findFirst
   */
  export type TestTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter, which TestTable to fetch.
     */
    where?: TestTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTables to fetch.
     */
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestTables.
     */
    cursor?: TestTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestTables.
     */
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }

  /**
   * TestTable findFirstOrThrow
   */
  export type TestTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter, which TestTable to fetch.
     */
    where?: TestTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTables to fetch.
     */
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestTables.
     */
    cursor?: TestTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestTables.
     */
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }

  /**
   * TestTable findMany
   */
  export type TestTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter, which TestTables to fetch.
     */
    where?: TestTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTables to fetch.
     */
    orderBy?: TestTableOrderByWithRelationInput | TestTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestTables.
     */
    cursor?: TestTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTables.
     */
    skip?: number
    distinct?: TestTableScalarFieldEnum | TestTableScalarFieldEnum[]
  }

  /**
   * TestTable create
   */
  export type TestTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * The data needed to create a TestTable.
     */
    data: XOR<TestTableCreateInput, TestTableUncheckedCreateInput>
  }

  /**
   * TestTable createMany
   */
  export type TestTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestTables.
     */
    data: TestTableCreateManyInput | TestTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestTable createManyAndReturn
   */
  export type TestTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * The data used to create many TestTables.
     */
    data: TestTableCreateManyInput | TestTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestTable update
   */
  export type TestTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * The data needed to update a TestTable.
     */
    data: XOR<TestTableUpdateInput, TestTableUncheckedUpdateInput>
    /**
     * Choose, which TestTable to update.
     */
    where: TestTableWhereUniqueInput
  }

  /**
   * TestTable updateMany
   */
  export type TestTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestTables.
     */
    data: XOR<TestTableUpdateManyMutationInput, TestTableUncheckedUpdateManyInput>
    /**
     * Filter which TestTables to update
     */
    where?: TestTableWhereInput
  }

  /**
   * TestTable updateManyAndReturn
   */
  export type TestTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * The data used to update TestTables.
     */
    data: XOR<TestTableUpdateManyMutationInput, TestTableUncheckedUpdateManyInput>
    /**
     * Filter which TestTables to update
     */
    where?: TestTableWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestTable upsert
   */
  export type TestTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * The filter to search for the TestTable to update in case it exists.
     */
    where: TestTableWhereUniqueInput
    /**
     * In case the TestTable found by the `where` argument doesn't exist, create a new TestTable with this data.
     */
    create: XOR<TestTableCreateInput, TestTableUncheckedCreateInput>
    /**
     * In case the TestTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestTableUpdateInput, TestTableUncheckedUpdateInput>
  }

  /**
   * TestTable delete
   */
  export type TestTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
    /**
     * Filter which TestTable to delete.
     */
    where: TestTableWhereUniqueInput
  }

  /**
   * TestTable deleteMany
   */
  export type TestTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestTables to delete
     */
    where?: TestTableWhereInput
  }

  /**
   * TestTable.questions
   */
  export type TestTable$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    where?: QuestionsTableWhereInput
    orderBy?: QuestionsTableOrderByWithRelationInput | QuestionsTableOrderByWithRelationInput[]
    cursor?: QuestionsTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsTableScalarFieldEnum | QuestionsTableScalarFieldEnum[]
  }

  /**
   * TestTable.results
   */
  export type TestTable$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
    where?: ResultTableWhereInput
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    cursor?: ResultTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultTableScalarFieldEnum | ResultTableScalarFieldEnum[]
  }

  /**
   * TestTable without action
   */
  export type TestTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTable
     */
    select?: TestTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTable
     */
    omit?: TestTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTableInclude<ExtArgs> | null
  }


  /**
   * Model QuestionsTable
   */

  export type AggregateQuestionsTable = {
    _count: QuestionsTableCountAggregateOutputType | null
    _avg: QuestionsTableAvgAggregateOutputType | null
    _sum: QuestionsTableSumAggregateOutputType | null
    _min: QuestionsTableMinAggregateOutputType | null
    _max: QuestionsTableMaxAggregateOutputType | null
  }

  export type QuestionsTableAvgAggregateOutputType = {
    id: number | null
    maxMark: number | null
    testId: number | null
  }

  export type QuestionsTableSumAggregateOutputType = {
    id: number | null
    maxMark: number | null
    testId: number | null
  }

  export type QuestionsTableMinAggregateOutputType = {
    id: number | null
    queText: string | null
    optionA: string | null
    optionB: string | null
    optionC: string | null
    optionD: string | null
    correctOption: string | null
    maxMark: number | null
    testId: number | null
  }

  export type QuestionsTableMaxAggregateOutputType = {
    id: number | null
    queText: string | null
    optionA: string | null
    optionB: string | null
    optionC: string | null
    optionD: string | null
    correctOption: string | null
    maxMark: number | null
    testId: number | null
  }

  export type QuestionsTableCountAggregateOutputType = {
    id: number
    queText: number
    optionA: number
    optionB: number
    optionC: number
    optionD: number
    correctOption: number
    maxMark: number
    testId: number
    _all: number
  }


  export type QuestionsTableAvgAggregateInputType = {
    id?: true
    maxMark?: true
    testId?: true
  }

  export type QuestionsTableSumAggregateInputType = {
    id?: true
    maxMark?: true
    testId?: true
  }

  export type QuestionsTableMinAggregateInputType = {
    id?: true
    queText?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    maxMark?: true
    testId?: true
  }

  export type QuestionsTableMaxAggregateInputType = {
    id?: true
    queText?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    maxMark?: true
    testId?: true
  }

  export type QuestionsTableCountAggregateInputType = {
    id?: true
    queText?: true
    optionA?: true
    optionB?: true
    optionC?: true
    optionD?: true
    correctOption?: true
    maxMark?: true
    testId?: true
    _all?: true
  }

  export type QuestionsTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionsTable to aggregate.
     */
    where?: QuestionsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsTables to fetch.
     */
    orderBy?: QuestionsTableOrderByWithRelationInput | QuestionsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsTables
    **/
    _count?: true | QuestionsTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsTableMaxAggregateInputType
  }

  export type GetQuestionsTableAggregateType<T extends QuestionsTableAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsTable[P]>
      : GetScalarType<T[P], AggregateQuestionsTable[P]>
  }




  export type QuestionsTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsTableWhereInput
    orderBy?: QuestionsTableOrderByWithAggregationInput | QuestionsTableOrderByWithAggregationInput[]
    by: QuestionsTableScalarFieldEnum[] | QuestionsTableScalarFieldEnum
    having?: QuestionsTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsTableCountAggregateInputType | true
    _avg?: QuestionsTableAvgAggregateInputType
    _sum?: QuestionsTableSumAggregateInputType
    _min?: QuestionsTableMinAggregateInputType
    _max?: QuestionsTableMaxAggregateInputType
  }

  export type QuestionsTableGroupByOutputType = {
    id: number
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    testId: number
    _count: QuestionsTableCountAggregateOutputType | null
    _avg: QuestionsTableAvgAggregateOutputType | null
    _sum: QuestionsTableSumAggregateOutputType | null
    _min: QuestionsTableMinAggregateOutputType | null
    _max: QuestionsTableMaxAggregateOutputType | null
  }

  type GetQuestionsTableGroupByPayload<T extends QuestionsTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsTableGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsTableGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queText?: boolean
    optionA?: boolean
    optionB?: boolean
    optionC?: boolean
    optionD?: boolean
    correctOption?: boolean
    maxMark?: boolean
    testId?: boolean
    test?: boolean | TestTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionsTable"]>

  export type QuestionsTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queText?: boolean
    optionA?: boolean
    optionB?: boolean
    optionC?: boolean
    optionD?: boolean
    correctOption?: boolean
    maxMark?: boolean
    testId?: boolean
    test?: boolean | TestTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionsTable"]>

  export type QuestionsTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queText?: boolean
    optionA?: boolean
    optionB?: boolean
    optionC?: boolean
    optionD?: boolean
    correctOption?: boolean
    maxMark?: boolean
    testId?: boolean
    test?: boolean | TestTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionsTable"]>

  export type QuestionsTableSelectScalar = {
    id?: boolean
    queText?: boolean
    optionA?: boolean
    optionB?: boolean
    optionC?: boolean
    optionD?: boolean
    correctOption?: boolean
    maxMark?: boolean
    testId?: boolean
  }

  export type QuestionsTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queText" | "optionA" | "optionB" | "optionC" | "optionD" | "correctOption" | "maxMark" | "testId", ExtArgs["result"]["questionsTable"]>
  export type QuestionsTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestTableDefaultArgs<ExtArgs>
  }
  export type QuestionsTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestTableDefaultArgs<ExtArgs>
  }
  export type QuestionsTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestTableDefaultArgs<ExtArgs>
  }

  export type $QuestionsTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionsTable"
    objects: {
      test: Prisma.$TestTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      queText: string
      optionA: string
      optionB: string
      optionC: string
      optionD: string
      correctOption: string
      maxMark: number
      testId: number
    }, ExtArgs["result"]["questionsTable"]>
    composites: {}
  }

  type QuestionsTableGetPayload<S extends boolean | null | undefined | QuestionsTableDefaultArgs> = $Result.GetResult<Prisma.$QuestionsTablePayload, S>

  type QuestionsTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionsTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionsTableCountAggregateInputType | true
    }

  export interface QuestionsTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionsTable'], meta: { name: 'QuestionsTable' } }
    /**
     * Find zero or one QuestionsTable that matches the filter.
     * @param {QuestionsTableFindUniqueArgs} args - Arguments to find a QuestionsTable
     * @example
     * // Get one QuestionsTable
     * const questionsTable = await prisma.questionsTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionsTableFindUniqueArgs>(args: SelectSubset<T, QuestionsTableFindUniqueArgs<ExtArgs>>): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one QuestionsTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionsTableFindUniqueOrThrowArgs} args - Arguments to find a QuestionsTable
     * @example
     * // Get one QuestionsTable
     * const questionsTable = await prisma.questionsTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionsTableFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionsTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first QuestionsTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableFindFirstArgs} args - Arguments to find a QuestionsTable
     * @example
     * // Get one QuestionsTable
     * const questionsTable = await prisma.questionsTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionsTableFindFirstArgs>(args?: SelectSubset<T, QuestionsTableFindFirstArgs<ExtArgs>>): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first QuestionsTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableFindFirstOrThrowArgs} args - Arguments to find a QuestionsTable
     * @example
     * // Get one QuestionsTable
     * const questionsTable = await prisma.questionsTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionsTableFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionsTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more QuestionsTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsTables
     * const questionsTables = await prisma.questionsTable.findMany()
     * 
     * // Get first 10 QuestionsTables
     * const questionsTables = await prisma.questionsTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsTableWithIdOnly = await prisma.questionsTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionsTableFindManyArgs>(args?: SelectSubset<T, QuestionsTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a QuestionsTable.
     * @param {QuestionsTableCreateArgs} args - Arguments to create a QuestionsTable.
     * @example
     * // Create one QuestionsTable
     * const QuestionsTable = await prisma.questionsTable.create({
     *   data: {
     *     // ... data to create a QuestionsTable
     *   }
     * })
     * 
     */
    create<T extends QuestionsTableCreateArgs>(args: SelectSubset<T, QuestionsTableCreateArgs<ExtArgs>>): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many QuestionsTables.
     * @param {QuestionsTableCreateManyArgs} args - Arguments to create many QuestionsTables.
     * @example
     * // Create many QuestionsTables
     * const questionsTable = await prisma.questionsTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionsTableCreateManyArgs>(args?: SelectSubset<T, QuestionsTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionsTables and returns the data saved in the database.
     * @param {QuestionsTableCreateManyAndReturnArgs} args - Arguments to create many QuestionsTables.
     * @example
     * // Create many QuestionsTables
     * const questionsTable = await prisma.questionsTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionsTables and only return the `id`
     * const questionsTableWithIdOnly = await prisma.questionsTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionsTableCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionsTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a QuestionsTable.
     * @param {QuestionsTableDeleteArgs} args - Arguments to delete one QuestionsTable.
     * @example
     * // Delete one QuestionsTable
     * const QuestionsTable = await prisma.questionsTable.delete({
     *   where: {
     *     // ... filter to delete one QuestionsTable
     *   }
     * })
     * 
     */
    delete<T extends QuestionsTableDeleteArgs>(args: SelectSubset<T, QuestionsTableDeleteArgs<ExtArgs>>): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one QuestionsTable.
     * @param {QuestionsTableUpdateArgs} args - Arguments to update one QuestionsTable.
     * @example
     * // Update one QuestionsTable
     * const questionsTable = await prisma.questionsTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionsTableUpdateArgs>(args: SelectSubset<T, QuestionsTableUpdateArgs<ExtArgs>>): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more QuestionsTables.
     * @param {QuestionsTableDeleteManyArgs} args - Arguments to filter QuestionsTables to delete.
     * @example
     * // Delete a few QuestionsTables
     * const { count } = await prisma.questionsTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionsTableDeleteManyArgs>(args?: SelectSubset<T, QuestionsTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsTables
     * const questionsTable = await prisma.questionsTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionsTableUpdateManyArgs>(args: SelectSubset<T, QuestionsTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsTables and returns the data updated in the database.
     * @param {QuestionsTableUpdateManyAndReturnArgs} args - Arguments to update many QuestionsTables.
     * @example
     * // Update many QuestionsTables
     * const questionsTable = await prisma.questionsTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionsTables and only return the `id`
     * const questionsTableWithIdOnly = await prisma.questionsTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionsTableUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionsTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one QuestionsTable.
     * @param {QuestionsTableUpsertArgs} args - Arguments to update or create a QuestionsTable.
     * @example
     * // Update or create a QuestionsTable
     * const questionsTable = await prisma.questionsTable.upsert({
     *   create: {
     *     // ... data to create a QuestionsTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsTable we want to update
     *   }
     * })
     */
    upsert<T extends QuestionsTableUpsertArgs>(args: SelectSubset<T, QuestionsTableUpsertArgs<ExtArgs>>): Prisma__QuestionsTableClient<$Result.GetResult<Prisma.$QuestionsTablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of QuestionsTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableCountArgs} args - Arguments to filter QuestionsTables to count.
     * @example
     * // Count the number of QuestionsTables
     * const count = await prisma.questionsTable.count({
     *   where: {
     *     // ... the filter for the QuestionsTables we want to count
     *   }
     * })
    **/
    count<T extends QuestionsTableCountArgs>(
      args?: Subset<T, QuestionsTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsTableAggregateArgs>(args: Subset<T, QuestionsTableAggregateArgs>): Prisma.PrismaPromise<GetQuestionsTableAggregateType<T>>

    /**
     * Group by QuestionsTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsTableGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionsTable model
   */
  readonly fields: QuestionsTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionsTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends TestTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestTableDefaultArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionsTable model
   */ 
  interface QuestionsTableFieldRefs {
    readonly id: FieldRef<"QuestionsTable", 'Int'>
    readonly queText: FieldRef<"QuestionsTable", 'String'>
    readonly optionA: FieldRef<"QuestionsTable", 'String'>
    readonly optionB: FieldRef<"QuestionsTable", 'String'>
    readonly optionC: FieldRef<"QuestionsTable", 'String'>
    readonly optionD: FieldRef<"QuestionsTable", 'String'>
    readonly correctOption: FieldRef<"QuestionsTable", 'String'>
    readonly maxMark: FieldRef<"QuestionsTable", 'Int'>
    readonly testId: FieldRef<"QuestionsTable", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuestionsTable findUnique
   */
  export type QuestionsTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsTable to fetch.
     */
    where: QuestionsTableWhereUniqueInput
  }

  /**
   * QuestionsTable findUniqueOrThrow
   */
  export type QuestionsTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsTable to fetch.
     */
    where: QuestionsTableWhereUniqueInput
  }

  /**
   * QuestionsTable findFirst
   */
  export type QuestionsTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsTable to fetch.
     */
    where?: QuestionsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsTables to fetch.
     */
    orderBy?: QuestionsTableOrderByWithRelationInput | QuestionsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsTables.
     */
    cursor?: QuestionsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsTables.
     */
    distinct?: QuestionsTableScalarFieldEnum | QuestionsTableScalarFieldEnum[]
  }

  /**
   * QuestionsTable findFirstOrThrow
   */
  export type QuestionsTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsTable to fetch.
     */
    where?: QuestionsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsTables to fetch.
     */
    orderBy?: QuestionsTableOrderByWithRelationInput | QuestionsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsTables.
     */
    cursor?: QuestionsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsTables.
     */
    distinct?: QuestionsTableScalarFieldEnum | QuestionsTableScalarFieldEnum[]
  }

  /**
   * QuestionsTable findMany
   */
  export type QuestionsTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsTables to fetch.
     */
    where?: QuestionsTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsTables to fetch.
     */
    orderBy?: QuestionsTableOrderByWithRelationInput | QuestionsTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsTables.
     */
    cursor?: QuestionsTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsTables.
     */
    skip?: number
    distinct?: QuestionsTableScalarFieldEnum | QuestionsTableScalarFieldEnum[]
  }

  /**
   * QuestionsTable create
   */
  export type QuestionsTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionsTable.
     */
    data: XOR<QuestionsTableCreateInput, QuestionsTableUncheckedCreateInput>
  }

  /**
   * QuestionsTable createMany
   */
  export type QuestionsTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionsTables.
     */
    data: QuestionsTableCreateManyInput | QuestionsTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionsTable createManyAndReturn
   */
  export type QuestionsTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionsTables.
     */
    data: QuestionsTableCreateManyInput | QuestionsTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionsTable update
   */
  export type QuestionsTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionsTable.
     */
    data: XOR<QuestionsTableUpdateInput, QuestionsTableUncheckedUpdateInput>
    /**
     * Choose, which QuestionsTable to update.
     */
    where: QuestionsTableWhereUniqueInput
  }

  /**
   * QuestionsTable updateMany
   */
  export type QuestionsTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionsTables.
     */
    data: XOR<QuestionsTableUpdateManyMutationInput, QuestionsTableUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsTables to update
     */
    where?: QuestionsTableWhereInput
  }

  /**
   * QuestionsTable updateManyAndReturn
   */
  export type QuestionsTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * The data used to update QuestionsTables.
     */
    data: XOR<QuestionsTableUpdateManyMutationInput, QuestionsTableUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsTables to update
     */
    where?: QuestionsTableWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionsTable upsert
   */
  export type QuestionsTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionsTable to update in case it exists.
     */
    where: QuestionsTableWhereUniqueInput
    /**
     * In case the QuestionsTable found by the `where` argument doesn't exist, create a new QuestionsTable with this data.
     */
    create: XOR<QuestionsTableCreateInput, QuestionsTableUncheckedCreateInput>
    /**
     * In case the QuestionsTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionsTableUpdateInput, QuestionsTableUncheckedUpdateInput>
  }

  /**
   * QuestionsTable delete
   */
  export type QuestionsTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableInclude<ExtArgs> | null
    /**
     * Filter which QuestionsTable to delete.
     */
    where: QuestionsTableWhereUniqueInput
  }

  /**
   * QuestionsTable deleteMany
   */
  export type QuestionsTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionsTables to delete
     */
    where?: QuestionsTableWhereInput
  }

  /**
   * QuestionsTable without action
   */
  export type QuestionsTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsTable
     */
    select?: QuestionsTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionsTable
     */
    omit?: QuestionsTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsTableInclude<ExtArgs> | null
  }


  /**
   * Model ResultTable
   */

  export type AggregateResultTable = {
    _count: ResultTableCountAggregateOutputType | null
    _avg: ResultTableAvgAggregateOutputType | null
    _sum: ResultTableSumAggregateOutputType | null
    _min: ResultTableMinAggregateOutputType | null
    _max: ResultTableMaxAggregateOutputType | null
  }

  export type ResultTableAvgAggregateOutputType = {
    id: number | null
    totalmarks: number | null
    scoredmarks: number | null
    testId: number | null
    studentId: number | null
  }

  export type ResultTableSumAggregateOutputType = {
    id: number | null
    totalmarks: number | null
    scoredmarks: number | null
    testId: number | null
    studentId: number | null
  }

  export type ResultTableMinAggregateOutputType = {
    id: number | null
    totalmarks: number | null
    scoredmarks: number | null
    testId: number | null
    studentId: number | null
  }

  export type ResultTableMaxAggregateOutputType = {
    id: number | null
    totalmarks: number | null
    scoredmarks: number | null
    testId: number | null
    studentId: number | null
  }

  export type ResultTableCountAggregateOutputType = {
    id: number
    totalmarks: number
    scoredmarks: number
    testId: number
    studentId: number
    _all: number
  }


  export type ResultTableAvgAggregateInputType = {
    id?: true
    totalmarks?: true
    scoredmarks?: true
    testId?: true
    studentId?: true
  }

  export type ResultTableSumAggregateInputType = {
    id?: true
    totalmarks?: true
    scoredmarks?: true
    testId?: true
    studentId?: true
  }

  export type ResultTableMinAggregateInputType = {
    id?: true
    totalmarks?: true
    scoredmarks?: true
    testId?: true
    studentId?: true
  }

  export type ResultTableMaxAggregateInputType = {
    id?: true
    totalmarks?: true
    scoredmarks?: true
    testId?: true
    studentId?: true
  }

  export type ResultTableCountAggregateInputType = {
    id?: true
    totalmarks?: true
    scoredmarks?: true
    testId?: true
    studentId?: true
    _all?: true
  }

  export type ResultTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultTable to aggregate.
     */
    where?: ResultTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultTables to fetch.
     */
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResultTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResultTables
    **/
    _count?: true | ResultTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResultTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResultTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResultTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResultTableMaxAggregateInputType
  }

  export type GetResultTableAggregateType<T extends ResultTableAggregateArgs> = {
        [P in keyof T & keyof AggregateResultTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResultTable[P]>
      : GetScalarType<T[P], AggregateResultTable[P]>
  }




  export type ResultTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultTableWhereInput
    orderBy?: ResultTableOrderByWithAggregationInput | ResultTableOrderByWithAggregationInput[]
    by: ResultTableScalarFieldEnum[] | ResultTableScalarFieldEnum
    having?: ResultTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResultTableCountAggregateInputType | true
    _avg?: ResultTableAvgAggregateInputType
    _sum?: ResultTableSumAggregateInputType
    _min?: ResultTableMinAggregateInputType
    _max?: ResultTableMaxAggregateInputType
  }

  export type ResultTableGroupByOutputType = {
    id: number
    totalmarks: number
    scoredmarks: number
    testId: number
    studentId: number
    _count: ResultTableCountAggregateOutputType | null
    _avg: ResultTableAvgAggregateOutputType | null
    _sum: ResultTableSumAggregateOutputType | null
    _min: ResultTableMinAggregateOutputType | null
    _max: ResultTableMaxAggregateOutputType | null
  }

  type GetResultTableGroupByPayload<T extends ResultTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResultTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResultTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResultTableGroupByOutputType[P]>
            : GetScalarType<T[P], ResultTableGroupByOutputType[P]>
        }
      >
    >


  export type ResultTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalmarks?: boolean
    scoredmarks?: boolean
    testId?: boolean
    studentId?: boolean
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    student?: boolean | StudentTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultTable"]>

  export type ResultTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalmarks?: boolean
    scoredmarks?: boolean
    testId?: boolean
    studentId?: boolean
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    student?: boolean | StudentTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultTable"]>

  export type ResultTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalmarks?: boolean
    scoredmarks?: boolean
    testId?: boolean
    studentId?: boolean
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    student?: boolean | StudentTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultTable"]>

  export type ResultTableSelectScalar = {
    id?: boolean
    totalmarks?: boolean
    scoredmarks?: boolean
    testId?: boolean
    studentId?: boolean
  }

  export type ResultTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "totalmarks" | "scoredmarks" | "testId" | "studentId", ExtArgs["result"]["resultTable"]>
  export type ResultTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    student?: boolean | StudentTableDefaultArgs<ExtArgs>
  }
  export type ResultTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    student?: boolean | StudentTableDefaultArgs<ExtArgs>
  }
  export type ResultTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestTableDefaultArgs<ExtArgs>
    student?: boolean | StudentTableDefaultArgs<ExtArgs>
  }

  export type $ResultTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResultTable"
    objects: {
      test: Prisma.$TestTablePayload<ExtArgs>
      student: Prisma.$StudentTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalmarks: number
      scoredmarks: number
      testId: number
      studentId: number
    }, ExtArgs["result"]["resultTable"]>
    composites: {}
  }

  type ResultTableGetPayload<S extends boolean | null | undefined | ResultTableDefaultArgs> = $Result.GetResult<Prisma.$ResultTablePayload, S>

  type ResultTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResultTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResultTableCountAggregateInputType | true
    }

  export interface ResultTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResultTable'], meta: { name: 'ResultTable' } }
    /**
     * Find zero or one ResultTable that matches the filter.
     * @param {ResultTableFindUniqueArgs} args - Arguments to find a ResultTable
     * @example
     * // Get one ResultTable
     * const resultTable = await prisma.resultTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResultTableFindUniqueArgs>(args: SelectSubset<T, ResultTableFindUniqueArgs<ExtArgs>>): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ResultTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResultTableFindUniqueOrThrowArgs} args - Arguments to find a ResultTable
     * @example
     * // Get one ResultTable
     * const resultTable = await prisma.resultTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResultTableFindUniqueOrThrowArgs>(args: SelectSubset<T, ResultTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ResultTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableFindFirstArgs} args - Arguments to find a ResultTable
     * @example
     * // Get one ResultTable
     * const resultTable = await prisma.resultTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResultTableFindFirstArgs>(args?: SelectSubset<T, ResultTableFindFirstArgs<ExtArgs>>): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ResultTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableFindFirstOrThrowArgs} args - Arguments to find a ResultTable
     * @example
     * // Get one ResultTable
     * const resultTable = await prisma.resultTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResultTableFindFirstOrThrowArgs>(args?: SelectSubset<T, ResultTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ResultTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResultTables
     * const resultTables = await prisma.resultTable.findMany()
     * 
     * // Get first 10 ResultTables
     * const resultTables = await prisma.resultTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resultTableWithIdOnly = await prisma.resultTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResultTableFindManyArgs>(args?: SelectSubset<T, ResultTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ResultTable.
     * @param {ResultTableCreateArgs} args - Arguments to create a ResultTable.
     * @example
     * // Create one ResultTable
     * const ResultTable = await prisma.resultTable.create({
     *   data: {
     *     // ... data to create a ResultTable
     *   }
     * })
     * 
     */
    create<T extends ResultTableCreateArgs>(args: SelectSubset<T, ResultTableCreateArgs<ExtArgs>>): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ResultTables.
     * @param {ResultTableCreateManyArgs} args - Arguments to create many ResultTables.
     * @example
     * // Create many ResultTables
     * const resultTable = await prisma.resultTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResultTableCreateManyArgs>(args?: SelectSubset<T, ResultTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResultTables and returns the data saved in the database.
     * @param {ResultTableCreateManyAndReturnArgs} args - Arguments to create many ResultTables.
     * @example
     * // Create many ResultTables
     * const resultTable = await prisma.resultTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResultTables and only return the `id`
     * const resultTableWithIdOnly = await prisma.resultTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResultTableCreateManyAndReturnArgs>(args?: SelectSubset<T, ResultTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ResultTable.
     * @param {ResultTableDeleteArgs} args - Arguments to delete one ResultTable.
     * @example
     * // Delete one ResultTable
     * const ResultTable = await prisma.resultTable.delete({
     *   where: {
     *     // ... filter to delete one ResultTable
     *   }
     * })
     * 
     */
    delete<T extends ResultTableDeleteArgs>(args: SelectSubset<T, ResultTableDeleteArgs<ExtArgs>>): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ResultTable.
     * @param {ResultTableUpdateArgs} args - Arguments to update one ResultTable.
     * @example
     * // Update one ResultTable
     * const resultTable = await prisma.resultTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResultTableUpdateArgs>(args: SelectSubset<T, ResultTableUpdateArgs<ExtArgs>>): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ResultTables.
     * @param {ResultTableDeleteManyArgs} args - Arguments to filter ResultTables to delete.
     * @example
     * // Delete a few ResultTables
     * const { count } = await prisma.resultTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResultTableDeleteManyArgs>(args?: SelectSubset<T, ResultTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResultTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResultTables
     * const resultTable = await prisma.resultTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResultTableUpdateManyArgs>(args: SelectSubset<T, ResultTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResultTables and returns the data updated in the database.
     * @param {ResultTableUpdateManyAndReturnArgs} args - Arguments to update many ResultTables.
     * @example
     * // Update many ResultTables
     * const resultTable = await prisma.resultTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResultTables and only return the `id`
     * const resultTableWithIdOnly = await prisma.resultTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResultTableUpdateManyAndReturnArgs>(args: SelectSubset<T, ResultTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ResultTable.
     * @param {ResultTableUpsertArgs} args - Arguments to update or create a ResultTable.
     * @example
     * // Update or create a ResultTable
     * const resultTable = await prisma.resultTable.upsert({
     *   create: {
     *     // ... data to create a ResultTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResultTable we want to update
     *   }
     * })
     */
    upsert<T extends ResultTableUpsertArgs>(args: SelectSubset<T, ResultTableUpsertArgs<ExtArgs>>): Prisma__ResultTableClient<$Result.GetResult<Prisma.$ResultTablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ResultTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableCountArgs} args - Arguments to filter ResultTables to count.
     * @example
     * // Count the number of ResultTables
     * const count = await prisma.resultTable.count({
     *   where: {
     *     // ... the filter for the ResultTables we want to count
     *   }
     * })
    **/
    count<T extends ResultTableCountArgs>(
      args?: Subset<T, ResultTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResultTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResultTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResultTableAggregateArgs>(args: Subset<T, ResultTableAggregateArgs>): Prisma.PrismaPromise<GetResultTableAggregateType<T>>

    /**
     * Group by ResultTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResultTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResultTableGroupByArgs['orderBy'] }
        : { orderBy?: ResultTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResultTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResultTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResultTable model
   */
  readonly fields: ResultTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResultTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResultTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends TestTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestTableDefaultArgs<ExtArgs>>): Prisma__TestTableClient<$Result.GetResult<Prisma.$TestTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    student<T extends StudentTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentTableDefaultArgs<ExtArgs>>): Prisma__StudentTableClient<$Result.GetResult<Prisma.$StudentTablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResultTable model
   */ 
  interface ResultTableFieldRefs {
    readonly id: FieldRef<"ResultTable", 'Int'>
    readonly totalmarks: FieldRef<"ResultTable", 'Int'>
    readonly scoredmarks: FieldRef<"ResultTable", 'Int'>
    readonly testId: FieldRef<"ResultTable", 'Int'>
    readonly studentId: FieldRef<"ResultTable", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ResultTable findUnique
   */
  export type ResultTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter, which ResultTable to fetch.
     */
    where: ResultTableWhereUniqueInput
  }

  /**
   * ResultTable findUniqueOrThrow
   */
  export type ResultTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter, which ResultTable to fetch.
     */
    where: ResultTableWhereUniqueInput
  }

  /**
   * ResultTable findFirst
   */
  export type ResultTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter, which ResultTable to fetch.
     */
    where?: ResultTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultTables to fetch.
     */
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultTables.
     */
    cursor?: ResultTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultTables.
     */
    distinct?: ResultTableScalarFieldEnum | ResultTableScalarFieldEnum[]
  }

  /**
   * ResultTable findFirstOrThrow
   */
  export type ResultTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter, which ResultTable to fetch.
     */
    where?: ResultTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultTables to fetch.
     */
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultTables.
     */
    cursor?: ResultTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultTables.
     */
    distinct?: ResultTableScalarFieldEnum | ResultTableScalarFieldEnum[]
  }

  /**
   * ResultTable findMany
   */
  export type ResultTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter, which ResultTables to fetch.
     */
    where?: ResultTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultTables to fetch.
     */
    orderBy?: ResultTableOrderByWithRelationInput | ResultTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResultTables.
     */
    cursor?: ResultTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultTables.
     */
    skip?: number
    distinct?: ResultTableScalarFieldEnum | ResultTableScalarFieldEnum[]
  }

  /**
   * ResultTable create
   */
  export type ResultTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * The data needed to create a ResultTable.
     */
    data: XOR<ResultTableCreateInput, ResultTableUncheckedCreateInput>
  }

  /**
   * ResultTable createMany
   */
  export type ResultTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResultTables.
     */
    data: ResultTableCreateManyInput | ResultTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResultTable createManyAndReturn
   */
  export type ResultTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * The data used to create many ResultTables.
     */
    data: ResultTableCreateManyInput | ResultTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResultTable update
   */
  export type ResultTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * The data needed to update a ResultTable.
     */
    data: XOR<ResultTableUpdateInput, ResultTableUncheckedUpdateInput>
    /**
     * Choose, which ResultTable to update.
     */
    where: ResultTableWhereUniqueInput
  }

  /**
   * ResultTable updateMany
   */
  export type ResultTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResultTables.
     */
    data: XOR<ResultTableUpdateManyMutationInput, ResultTableUncheckedUpdateManyInput>
    /**
     * Filter which ResultTables to update
     */
    where?: ResultTableWhereInput
  }

  /**
   * ResultTable updateManyAndReturn
   */
  export type ResultTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * The data used to update ResultTables.
     */
    data: XOR<ResultTableUpdateManyMutationInput, ResultTableUncheckedUpdateManyInput>
    /**
     * Filter which ResultTables to update
     */
    where?: ResultTableWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResultTable upsert
   */
  export type ResultTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * The filter to search for the ResultTable to update in case it exists.
     */
    where: ResultTableWhereUniqueInput
    /**
     * In case the ResultTable found by the `where` argument doesn't exist, create a new ResultTable with this data.
     */
    create: XOR<ResultTableCreateInput, ResultTableUncheckedCreateInput>
    /**
     * In case the ResultTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResultTableUpdateInput, ResultTableUncheckedUpdateInput>
  }

  /**
   * ResultTable delete
   */
  export type ResultTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
    /**
     * Filter which ResultTable to delete.
     */
    where: ResultTableWhereUniqueInput
  }

  /**
   * ResultTable deleteMany
   */
  export type ResultTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultTables to delete
     */
    where?: ResultTableWhereInput
  }

  /**
   * ResultTable without action
   */
  export type ResultTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultTable
     */
    select?: ResultTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultTable
     */
    omit?: ResultTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultTableInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UniversityTableScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address'
  };

  export type UniversityTableScalarFieldEnum = (typeof UniversityTableScalarFieldEnum)[keyof typeof UniversityTableScalarFieldEnum]


  export const BranchTableScalarFieldEnum: {
    id: 'id',
    Branchcode: 'Branchcode',
    Branchname: 'Branchname',
    universityId: 'universityId'
  };

  export type BranchTableScalarFieldEnum = (typeof BranchTableScalarFieldEnum)[keyof typeof BranchTableScalarFieldEnum]


  export const YearTableScalarFieldEnum: {
    id: 'id',
    name: 'name',
    year: 'year'
  };

  export type YearTableScalarFieldEnum = (typeof YearTableScalarFieldEnum)[keyof typeof YearTableScalarFieldEnum]


  export const StudentTableScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    password: 'password',
    PRN: 'PRN',
    branchId: 'branchId',
    universityId: 'universityId',
    yearId: 'yearId'
  };

  export type StudentTableScalarFieldEnum = (typeof StudentTableScalarFieldEnum)[keyof typeof StudentTableScalarFieldEnum]


  export const TeacherTableScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    password: 'password',
    branchId: 'branchId',
    universityId: 'universityId'
  };

  export type TeacherTableScalarFieldEnum = (typeof TeacherTableScalarFieldEnum)[keyof typeof TeacherTableScalarFieldEnum]


  export const TestTableScalarFieldEnum: {
    id: 'id',
    title: 'title',
    teacherID: 'teacherID',
    branchId: 'branchId',
    subject: 'subject',
    yearId: 'yearId',
    totalmarks: 'totalmarks',
    duration: 'duration',
    scheduledDate: 'scheduledDate'
  };

  export type TestTableScalarFieldEnum = (typeof TestTableScalarFieldEnum)[keyof typeof TestTableScalarFieldEnum]


  export const QuestionsTableScalarFieldEnum: {
    id: 'id',
    queText: 'queText',
    optionA: 'optionA',
    optionB: 'optionB',
    optionC: 'optionC',
    optionD: 'optionD',
    correctOption: 'correctOption',
    maxMark: 'maxMark',
    testId: 'testId'
  };

  export type QuestionsTableScalarFieldEnum = (typeof QuestionsTableScalarFieldEnum)[keyof typeof QuestionsTableScalarFieldEnum]


  export const ResultTableScalarFieldEnum: {
    id: 'id',
    totalmarks: 'totalmarks',
    scoredmarks: 'scoredmarks',
    testId: 'testId',
    studentId: 'studentId'
  };

  export type ResultTableScalarFieldEnum = (typeof ResultTableScalarFieldEnum)[keyof typeof ResultTableScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UniversityTableWhereInput = {
    AND?: UniversityTableWhereInput | UniversityTableWhereInput[]
    OR?: UniversityTableWhereInput[]
    NOT?: UniversityTableWhereInput | UniversityTableWhereInput[]
    id?: IntFilter<"UniversityTable"> | number
    name?: StringFilter<"UniversityTable"> | string
    address?: StringFilter<"UniversityTable"> | string
    branches?: BranchTableListRelationFilter
    students?: StudentTableListRelationFilter
    teachers?: TeacherTableListRelationFilter
  }

  export type UniversityTableOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    branches?: BranchTableOrderByRelationAggregateInput
    students?: StudentTableOrderByRelationAggregateInput
    teachers?: TeacherTableOrderByRelationAggregateInput
  }

  export type UniversityTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UniversityTableWhereInput | UniversityTableWhereInput[]
    OR?: UniversityTableWhereInput[]
    NOT?: UniversityTableWhereInput | UniversityTableWhereInput[]
    name?: StringFilter<"UniversityTable"> | string
    address?: StringFilter<"UniversityTable"> | string
    branches?: BranchTableListRelationFilter
    students?: StudentTableListRelationFilter
    teachers?: TeacherTableListRelationFilter
  }, "id">

  export type UniversityTableOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    _count?: UniversityTableCountOrderByAggregateInput
    _avg?: UniversityTableAvgOrderByAggregateInput
    _max?: UniversityTableMaxOrderByAggregateInput
    _min?: UniversityTableMinOrderByAggregateInput
    _sum?: UniversityTableSumOrderByAggregateInput
  }

  export type UniversityTableScalarWhereWithAggregatesInput = {
    AND?: UniversityTableScalarWhereWithAggregatesInput | UniversityTableScalarWhereWithAggregatesInput[]
    OR?: UniversityTableScalarWhereWithAggregatesInput[]
    NOT?: UniversityTableScalarWhereWithAggregatesInput | UniversityTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UniversityTable"> | number
    name?: StringWithAggregatesFilter<"UniversityTable"> | string
    address?: StringWithAggregatesFilter<"UniversityTable"> | string
  }

  export type BranchTableWhereInput = {
    AND?: BranchTableWhereInput | BranchTableWhereInput[]
    OR?: BranchTableWhereInput[]
    NOT?: BranchTableWhereInput | BranchTableWhereInput[]
    id?: IntFilter<"BranchTable"> | number
    Branchcode?: StringFilter<"BranchTable"> | string
    Branchname?: StringFilter<"BranchTable"> | string
    universityId?: IntFilter<"BranchTable"> | number
    university?: XOR<UniversityTableScalarRelationFilter, UniversityTableWhereInput>
    students?: StudentTableListRelationFilter
    teachers?: TeacherTableListRelationFilter
    tests?: TestTableListRelationFilter
  }

  export type BranchTableOrderByWithRelationInput = {
    id?: SortOrder
    Branchcode?: SortOrder
    Branchname?: SortOrder
    universityId?: SortOrder
    university?: UniversityTableOrderByWithRelationInput
    students?: StudentTableOrderByRelationAggregateInput
    teachers?: TeacherTableOrderByRelationAggregateInput
    tests?: TestTableOrderByRelationAggregateInput
  }

  export type BranchTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BranchTableWhereInput | BranchTableWhereInput[]
    OR?: BranchTableWhereInput[]
    NOT?: BranchTableWhereInput | BranchTableWhereInput[]
    Branchcode?: StringFilter<"BranchTable"> | string
    Branchname?: StringFilter<"BranchTable"> | string
    universityId?: IntFilter<"BranchTable"> | number
    university?: XOR<UniversityTableScalarRelationFilter, UniversityTableWhereInput>
    students?: StudentTableListRelationFilter
    teachers?: TeacherTableListRelationFilter
    tests?: TestTableListRelationFilter
  }, "id">

  export type BranchTableOrderByWithAggregationInput = {
    id?: SortOrder
    Branchcode?: SortOrder
    Branchname?: SortOrder
    universityId?: SortOrder
    _count?: BranchTableCountOrderByAggregateInput
    _avg?: BranchTableAvgOrderByAggregateInput
    _max?: BranchTableMaxOrderByAggregateInput
    _min?: BranchTableMinOrderByAggregateInput
    _sum?: BranchTableSumOrderByAggregateInput
  }

  export type BranchTableScalarWhereWithAggregatesInput = {
    AND?: BranchTableScalarWhereWithAggregatesInput | BranchTableScalarWhereWithAggregatesInput[]
    OR?: BranchTableScalarWhereWithAggregatesInput[]
    NOT?: BranchTableScalarWhereWithAggregatesInput | BranchTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BranchTable"> | number
    Branchcode?: StringWithAggregatesFilter<"BranchTable"> | string
    Branchname?: StringWithAggregatesFilter<"BranchTable"> | string
    universityId?: IntWithAggregatesFilter<"BranchTable"> | number
  }

  export type YearTableWhereInput = {
    AND?: YearTableWhereInput | YearTableWhereInput[]
    OR?: YearTableWhereInput[]
    NOT?: YearTableWhereInput | YearTableWhereInput[]
    id?: IntFilter<"YearTable"> | number
    name?: StringFilter<"YearTable"> | string
    year?: IntFilter<"YearTable"> | number
    students?: StudentTableListRelationFilter
    tests?: TestTableListRelationFilter
  }

  export type YearTableOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    students?: StudentTableOrderByRelationAggregateInput
    tests?: TestTableOrderByRelationAggregateInput
  }

  export type YearTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: YearTableWhereInput | YearTableWhereInput[]
    OR?: YearTableWhereInput[]
    NOT?: YearTableWhereInput | YearTableWhereInput[]
    name?: StringFilter<"YearTable"> | string
    year?: IntFilter<"YearTable"> | number
    students?: StudentTableListRelationFilter
    tests?: TestTableListRelationFilter
  }, "id">

  export type YearTableOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    _count?: YearTableCountOrderByAggregateInput
    _avg?: YearTableAvgOrderByAggregateInput
    _max?: YearTableMaxOrderByAggregateInput
    _min?: YearTableMinOrderByAggregateInput
    _sum?: YearTableSumOrderByAggregateInput
  }

  export type YearTableScalarWhereWithAggregatesInput = {
    AND?: YearTableScalarWhereWithAggregatesInput | YearTableScalarWhereWithAggregatesInput[]
    OR?: YearTableScalarWhereWithAggregatesInput[]
    NOT?: YearTableScalarWhereWithAggregatesInput | YearTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"YearTable"> | number
    name?: StringWithAggregatesFilter<"YearTable"> | string
    year?: IntWithAggregatesFilter<"YearTable"> | number
  }

  export type StudentTableWhereInput = {
    AND?: StudentTableWhereInput | StudentTableWhereInput[]
    OR?: StudentTableWhereInput[]
    NOT?: StudentTableWhereInput | StudentTableWhereInput[]
    id?: IntFilter<"StudentTable"> | number
    firstname?: StringFilter<"StudentTable"> | string
    lastname?: StringFilter<"StudentTable"> | string
    email?: StringFilter<"StudentTable"> | string
    password?: StringFilter<"StudentTable"> | string
    PRN?: StringFilter<"StudentTable"> | string
    branchId?: IntFilter<"StudentTable"> | number
    universityId?: IntFilter<"StudentTable"> | number
    yearId?: IntFilter<"StudentTable"> | number
    branch?: XOR<BranchTableScalarRelationFilter, BranchTableWhereInput>
    university?: XOR<UniversityTableScalarRelationFilter, UniversityTableWhereInput>
    year?: XOR<YearTableScalarRelationFilter, YearTableWhereInput>
    results?: ResultTableListRelationFilter
  }

  export type StudentTableOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    PRN?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
    branch?: BranchTableOrderByWithRelationInput
    university?: UniversityTableOrderByWithRelationInput
    year?: YearTableOrderByWithRelationInput
    results?: ResultTableOrderByRelationAggregateInput
  }

  export type StudentTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: StudentTableWhereInput | StudentTableWhereInput[]
    OR?: StudentTableWhereInput[]
    NOT?: StudentTableWhereInput | StudentTableWhereInput[]
    firstname?: StringFilter<"StudentTable"> | string
    lastname?: StringFilter<"StudentTable"> | string
    password?: StringFilter<"StudentTable"> | string
    PRN?: StringFilter<"StudentTable"> | string
    branchId?: IntFilter<"StudentTable"> | number
    universityId?: IntFilter<"StudentTable"> | number
    yearId?: IntFilter<"StudentTable"> | number
    branch?: XOR<BranchTableScalarRelationFilter, BranchTableWhereInput>
    university?: XOR<UniversityTableScalarRelationFilter, UniversityTableWhereInput>
    year?: XOR<YearTableScalarRelationFilter, YearTableWhereInput>
    results?: ResultTableListRelationFilter
  }, "id" | "email">

  export type StudentTableOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    PRN?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
    _count?: StudentTableCountOrderByAggregateInput
    _avg?: StudentTableAvgOrderByAggregateInput
    _max?: StudentTableMaxOrderByAggregateInput
    _min?: StudentTableMinOrderByAggregateInput
    _sum?: StudentTableSumOrderByAggregateInput
  }

  export type StudentTableScalarWhereWithAggregatesInput = {
    AND?: StudentTableScalarWhereWithAggregatesInput | StudentTableScalarWhereWithAggregatesInput[]
    OR?: StudentTableScalarWhereWithAggregatesInput[]
    NOT?: StudentTableScalarWhereWithAggregatesInput | StudentTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentTable"> | number
    firstname?: StringWithAggregatesFilter<"StudentTable"> | string
    lastname?: StringWithAggregatesFilter<"StudentTable"> | string
    email?: StringWithAggregatesFilter<"StudentTable"> | string
    password?: StringWithAggregatesFilter<"StudentTable"> | string
    PRN?: StringWithAggregatesFilter<"StudentTable"> | string
    branchId?: IntWithAggregatesFilter<"StudentTable"> | number
    universityId?: IntWithAggregatesFilter<"StudentTable"> | number
    yearId?: IntWithAggregatesFilter<"StudentTable"> | number
  }

  export type TeacherTableWhereInput = {
    AND?: TeacherTableWhereInput | TeacherTableWhereInput[]
    OR?: TeacherTableWhereInput[]
    NOT?: TeacherTableWhereInput | TeacherTableWhereInput[]
    id?: IntFilter<"TeacherTable"> | number
    firstname?: StringFilter<"TeacherTable"> | string
    lastname?: StringFilter<"TeacherTable"> | string
    email?: StringFilter<"TeacherTable"> | string
    password?: StringFilter<"TeacherTable"> | string
    branchId?: IntFilter<"TeacherTable"> | number
    universityId?: IntFilter<"TeacherTable"> | number
    branch?: XOR<BranchTableScalarRelationFilter, BranchTableWhereInput>
    university?: XOR<UniversityTableScalarRelationFilter, UniversityTableWhereInput>
    tests?: TestTableListRelationFilter
  }

  export type TeacherTableOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    branch?: BranchTableOrderByWithRelationInput
    university?: UniversityTableOrderByWithRelationInput
    tests?: TestTableOrderByRelationAggregateInput
  }

  export type TeacherTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: TeacherTableWhereInput | TeacherTableWhereInput[]
    OR?: TeacherTableWhereInput[]
    NOT?: TeacherTableWhereInput | TeacherTableWhereInput[]
    firstname?: StringFilter<"TeacherTable"> | string
    lastname?: StringFilter<"TeacherTable"> | string
    password?: StringFilter<"TeacherTable"> | string
    branchId?: IntFilter<"TeacherTable"> | number
    universityId?: IntFilter<"TeacherTable"> | number
    branch?: XOR<BranchTableScalarRelationFilter, BranchTableWhereInput>
    university?: XOR<UniversityTableScalarRelationFilter, UniversityTableWhereInput>
    tests?: TestTableListRelationFilter
  }, "id" | "email">

  export type TeacherTableOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    _count?: TeacherTableCountOrderByAggregateInput
    _avg?: TeacherTableAvgOrderByAggregateInput
    _max?: TeacherTableMaxOrderByAggregateInput
    _min?: TeacherTableMinOrderByAggregateInput
    _sum?: TeacherTableSumOrderByAggregateInput
  }

  export type TeacherTableScalarWhereWithAggregatesInput = {
    AND?: TeacherTableScalarWhereWithAggregatesInput | TeacherTableScalarWhereWithAggregatesInput[]
    OR?: TeacherTableScalarWhereWithAggregatesInput[]
    NOT?: TeacherTableScalarWhereWithAggregatesInput | TeacherTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeacherTable"> | number
    firstname?: StringWithAggregatesFilter<"TeacherTable"> | string
    lastname?: StringWithAggregatesFilter<"TeacherTable"> | string
    email?: StringWithAggregatesFilter<"TeacherTable"> | string
    password?: StringWithAggregatesFilter<"TeacherTable"> | string
    branchId?: IntWithAggregatesFilter<"TeacherTable"> | number
    universityId?: IntWithAggregatesFilter<"TeacherTable"> | number
  }

  export type TestTableWhereInput = {
    AND?: TestTableWhereInput | TestTableWhereInput[]
    OR?: TestTableWhereInput[]
    NOT?: TestTableWhereInput | TestTableWhereInput[]
    id?: IntFilter<"TestTable"> | number
    title?: StringFilter<"TestTable"> | string
    teacherID?: IntFilter<"TestTable"> | number
    branchId?: IntFilter<"TestTable"> | number
    subject?: StringFilter<"TestTable"> | string
    yearId?: IntFilter<"TestTable"> | number
    totalmarks?: IntFilter<"TestTable"> | number
    duration?: IntFilter<"TestTable"> | number
    scheduledDate?: DateTimeFilter<"TestTable"> | Date | string
    teacher?: XOR<TeacherTableScalarRelationFilter, TeacherTableWhereInput>
    branch?: XOR<BranchTableScalarRelationFilter, BranchTableWhereInput>
    year?: XOR<YearTableScalarRelationFilter, YearTableWhereInput>
    questions?: QuestionsTableListRelationFilter
    results?: ResultTableListRelationFilter
  }

  export type TestTableOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    subject?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
    scheduledDate?: SortOrder
    teacher?: TeacherTableOrderByWithRelationInput
    branch?: BranchTableOrderByWithRelationInput
    year?: YearTableOrderByWithRelationInput
    questions?: QuestionsTableOrderByRelationAggregateInput
    results?: ResultTableOrderByRelationAggregateInput
  }

  export type TestTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestTableWhereInput | TestTableWhereInput[]
    OR?: TestTableWhereInput[]
    NOT?: TestTableWhereInput | TestTableWhereInput[]
    title?: StringFilter<"TestTable"> | string
    teacherID?: IntFilter<"TestTable"> | number
    branchId?: IntFilter<"TestTable"> | number
    subject?: StringFilter<"TestTable"> | string
    yearId?: IntFilter<"TestTable"> | number
    totalmarks?: IntFilter<"TestTable"> | number
    duration?: IntFilter<"TestTable"> | number
    scheduledDate?: DateTimeFilter<"TestTable"> | Date | string
    teacher?: XOR<TeacherTableScalarRelationFilter, TeacherTableWhereInput>
    branch?: XOR<BranchTableScalarRelationFilter, BranchTableWhereInput>
    year?: XOR<YearTableScalarRelationFilter, YearTableWhereInput>
    questions?: QuestionsTableListRelationFilter
    results?: ResultTableListRelationFilter
  }, "id">

  export type TestTableOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    subject?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
    scheduledDate?: SortOrder
    _count?: TestTableCountOrderByAggregateInput
    _avg?: TestTableAvgOrderByAggregateInput
    _max?: TestTableMaxOrderByAggregateInput
    _min?: TestTableMinOrderByAggregateInput
    _sum?: TestTableSumOrderByAggregateInput
  }

  export type TestTableScalarWhereWithAggregatesInput = {
    AND?: TestTableScalarWhereWithAggregatesInput | TestTableScalarWhereWithAggregatesInput[]
    OR?: TestTableScalarWhereWithAggregatesInput[]
    NOT?: TestTableScalarWhereWithAggregatesInput | TestTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestTable"> | number
    title?: StringWithAggregatesFilter<"TestTable"> | string
    teacherID?: IntWithAggregatesFilter<"TestTable"> | number
    branchId?: IntWithAggregatesFilter<"TestTable"> | number
    subject?: StringWithAggregatesFilter<"TestTable"> | string
    yearId?: IntWithAggregatesFilter<"TestTable"> | number
    totalmarks?: IntWithAggregatesFilter<"TestTable"> | number
    duration?: IntWithAggregatesFilter<"TestTable"> | number
    scheduledDate?: DateTimeWithAggregatesFilter<"TestTable"> | Date | string
  }

  export type QuestionsTableWhereInput = {
    AND?: QuestionsTableWhereInput | QuestionsTableWhereInput[]
    OR?: QuestionsTableWhereInput[]
    NOT?: QuestionsTableWhereInput | QuestionsTableWhereInput[]
    id?: IntFilter<"QuestionsTable"> | number
    queText?: StringFilter<"QuestionsTable"> | string
    optionA?: StringFilter<"QuestionsTable"> | string
    optionB?: StringFilter<"QuestionsTable"> | string
    optionC?: StringFilter<"QuestionsTable"> | string
    optionD?: StringFilter<"QuestionsTable"> | string
    correctOption?: StringFilter<"QuestionsTable"> | string
    maxMark?: IntFilter<"QuestionsTable"> | number
    testId?: IntFilter<"QuestionsTable"> | number
    test?: XOR<TestTableScalarRelationFilter, TestTableWhereInput>
  }

  export type QuestionsTableOrderByWithRelationInput = {
    id?: SortOrder
    queText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
    test?: TestTableOrderByWithRelationInput
  }

  export type QuestionsTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestionsTableWhereInput | QuestionsTableWhereInput[]
    OR?: QuestionsTableWhereInput[]
    NOT?: QuestionsTableWhereInput | QuestionsTableWhereInput[]
    queText?: StringFilter<"QuestionsTable"> | string
    optionA?: StringFilter<"QuestionsTable"> | string
    optionB?: StringFilter<"QuestionsTable"> | string
    optionC?: StringFilter<"QuestionsTable"> | string
    optionD?: StringFilter<"QuestionsTable"> | string
    correctOption?: StringFilter<"QuestionsTable"> | string
    maxMark?: IntFilter<"QuestionsTable"> | number
    testId?: IntFilter<"QuestionsTable"> | number
    test?: XOR<TestTableScalarRelationFilter, TestTableWhereInput>
  }, "id">

  export type QuestionsTableOrderByWithAggregationInput = {
    id?: SortOrder
    queText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
    _count?: QuestionsTableCountOrderByAggregateInput
    _avg?: QuestionsTableAvgOrderByAggregateInput
    _max?: QuestionsTableMaxOrderByAggregateInput
    _min?: QuestionsTableMinOrderByAggregateInput
    _sum?: QuestionsTableSumOrderByAggregateInput
  }

  export type QuestionsTableScalarWhereWithAggregatesInput = {
    AND?: QuestionsTableScalarWhereWithAggregatesInput | QuestionsTableScalarWhereWithAggregatesInput[]
    OR?: QuestionsTableScalarWhereWithAggregatesInput[]
    NOT?: QuestionsTableScalarWhereWithAggregatesInput | QuestionsTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuestionsTable"> | number
    queText?: StringWithAggregatesFilter<"QuestionsTable"> | string
    optionA?: StringWithAggregatesFilter<"QuestionsTable"> | string
    optionB?: StringWithAggregatesFilter<"QuestionsTable"> | string
    optionC?: StringWithAggregatesFilter<"QuestionsTable"> | string
    optionD?: StringWithAggregatesFilter<"QuestionsTable"> | string
    correctOption?: StringWithAggregatesFilter<"QuestionsTable"> | string
    maxMark?: IntWithAggregatesFilter<"QuestionsTable"> | number
    testId?: IntWithAggregatesFilter<"QuestionsTable"> | number
  }

  export type ResultTableWhereInput = {
    AND?: ResultTableWhereInput | ResultTableWhereInput[]
    OR?: ResultTableWhereInput[]
    NOT?: ResultTableWhereInput | ResultTableWhereInput[]
    id?: IntFilter<"ResultTable"> | number
    totalmarks?: IntFilter<"ResultTable"> | number
    scoredmarks?: IntFilter<"ResultTable"> | number
    testId?: IntFilter<"ResultTable"> | number
    studentId?: IntFilter<"ResultTable"> | number
    test?: XOR<TestTableScalarRelationFilter, TestTableWhereInput>
    student?: XOR<StudentTableScalarRelationFilter, StudentTableWhereInput>
  }

  export type ResultTableOrderByWithRelationInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    test?: TestTableOrderByWithRelationInput
    student?: StudentTableOrderByWithRelationInput
  }

  export type ResultTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResultTableWhereInput | ResultTableWhereInput[]
    OR?: ResultTableWhereInput[]
    NOT?: ResultTableWhereInput | ResultTableWhereInput[]
    totalmarks?: IntFilter<"ResultTable"> | number
    scoredmarks?: IntFilter<"ResultTable"> | number
    testId?: IntFilter<"ResultTable"> | number
    studentId?: IntFilter<"ResultTable"> | number
    test?: XOR<TestTableScalarRelationFilter, TestTableWhereInput>
    student?: XOR<StudentTableScalarRelationFilter, StudentTableWhereInput>
  }, "id">

  export type ResultTableOrderByWithAggregationInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    _count?: ResultTableCountOrderByAggregateInput
    _avg?: ResultTableAvgOrderByAggregateInput
    _max?: ResultTableMaxOrderByAggregateInput
    _min?: ResultTableMinOrderByAggregateInput
    _sum?: ResultTableSumOrderByAggregateInput
  }

  export type ResultTableScalarWhereWithAggregatesInput = {
    AND?: ResultTableScalarWhereWithAggregatesInput | ResultTableScalarWhereWithAggregatesInput[]
    OR?: ResultTableScalarWhereWithAggregatesInput[]
    NOT?: ResultTableScalarWhereWithAggregatesInput | ResultTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ResultTable"> | number
    totalmarks?: IntWithAggregatesFilter<"ResultTable"> | number
    scoredmarks?: IntWithAggregatesFilter<"ResultTable"> | number
    testId?: IntWithAggregatesFilter<"ResultTable"> | number
    studentId?: IntWithAggregatesFilter<"ResultTable"> | number
  }

  export type UniversityTableCreateInput = {
    name: string
    address: string
    branches?: BranchTableCreateNestedManyWithoutUniversityInput
    students?: StudentTableCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    branches?: BranchTableUncheckedCreateNestedManyWithoutUniversityInput
    students?: StudentTableUncheckedCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUncheckedUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUncheckedUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableCreateManyInput = {
    id?: number
    name: string
    address: string
  }

  export type UniversityTableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type UniversityTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type BranchTableCreateInput = {
    Branchcode: string
    Branchname: string
    university: UniversityTableCreateNestedOneWithoutBranchesInput
    students?: StudentTableCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableCreateNestedManyWithoutBranchInput
    tests?: TestTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutBranchInput
    tests?: TestTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUpdateInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutBranchesNestedInput
    students?: StudentTableUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUpdateManyWithoutBranchNestedInput
    tests?: TestTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutBranchNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableCreateManyInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
  }

  export type BranchTableUpdateManyMutationInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
  }

  export type BranchTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type YearTableCreateInput = {
    name: string
    year: number
    students?: StudentTableCreateNestedManyWithoutYearInput
    tests?: TestTableCreateNestedManyWithoutYearInput
  }

  export type YearTableUncheckedCreateInput = {
    id?: number
    name: string
    year: number
    students?: StudentTableUncheckedCreateNestedManyWithoutYearInput
    tests?: TestTableUncheckedCreateNestedManyWithoutYearInput
  }

  export type YearTableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUpdateManyWithoutYearNestedInput
    tests?: TestTableUpdateManyWithoutYearNestedInput
  }

  export type YearTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutYearNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutYearNestedInput
  }

  export type YearTableCreateManyInput = {
    id?: number
    name: string
    year: number
  }

  export type YearTableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type YearTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type StudentTableCreateInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branch: BranchTableCreateNestedOneWithoutStudentsInput
    university: UniversityTableCreateNestedOneWithoutStudentsInput
    year: YearTableCreateNestedOneWithoutStudentsInput
    results?: ResultTableCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUncheckedCreateInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
    yearId: number
    results?: ResultTableUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUpdateInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutStudentsNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutStudentsNestedInput
    year?: YearTableUpdateOneRequiredWithoutStudentsNestedInput
    results?: ResultTableUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
    results?: ResultTableUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableCreateManyInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
    yearId: number
  }

  export type StudentTableUpdateManyMutationInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherTableCreateInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    branch: BranchTableCreateNestedOneWithoutTeachersInput
    university: UniversityTableCreateNestedOneWithoutTeachersInput
    tests?: TestTableCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableUncheckedCreateInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
    universityId: number
    tests?: TestTableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableUpdateInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutTeachersNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutTeachersNestedInput
    tests?: TestTableUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    tests?: TestTableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableCreateManyInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
    universityId: number
  }

  export type TeacherTableUpdateManyMutationInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type TestTableCreateInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    teacher: TeacherTableCreateNestedOneWithoutTestsInput
    branch: BranchTableCreateNestedOneWithoutTestsInput
    year: YearTableCreateNestedOneWithoutTestsInput
    questions?: QuestionsTableCreateNestedManyWithoutTestInput
    results?: ResultTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    questions?: QuestionsTableUncheckedCreateNestedManyWithoutTestInput
    results?: ResultTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutTestsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutTestsNestedInput
    year?: YearTableUpdateOneRequiredWithoutTestsNestedInput
    questions?: QuestionsTableUpdateManyWithoutTestNestedInput
    results?: ResultTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionsTableUncheckedUpdateManyWithoutTestNestedInput
    results?: ResultTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestTableCreateManyInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
  }

  export type TestTableUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsTableCreateInput = {
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    test: TestTableCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionsTableUncheckedCreateInput = {
    id?: number
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    testId: number
  }

  export type QuestionsTableUpdateInput = {
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
    test?: TestTableUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionsTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionsTableCreateManyInput = {
    id?: number
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
    testId: number
  }

  export type QuestionsTableUpdateManyMutationInput = {
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionsTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableCreateInput = {
    totalmarks: number
    scoredmarks: number
    test: TestTableCreateNestedOneWithoutResultsInput
    student: StudentTableCreateNestedOneWithoutResultsInput
  }

  export type ResultTableUncheckedCreateInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    testId: number
    studentId: number
  }

  export type ResultTableUpdateInput = {
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    test?: TestTableUpdateOneRequiredWithoutResultsNestedInput
    student?: StudentTableUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ResultTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableCreateManyInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    testId: number
    studentId: number
  }

  export type ResultTableUpdateManyMutationInput = {
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BranchTableListRelationFilter = {
    every?: BranchTableWhereInput
    some?: BranchTableWhereInput
    none?: BranchTableWhereInput
  }

  export type StudentTableListRelationFilter = {
    every?: StudentTableWhereInput
    some?: StudentTableWhereInput
    none?: StudentTableWhereInput
  }

  export type TeacherTableListRelationFilter = {
    every?: TeacherTableWhereInput
    some?: TeacherTableWhereInput
    none?: TeacherTableWhereInput
  }

  export type BranchTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UniversityTableCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type UniversityTableAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UniversityTableMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type UniversityTableMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type UniversityTableSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UniversityTableScalarRelationFilter = {
    is?: UniversityTableWhereInput
    isNot?: UniversityTableWhereInput
  }

  export type TestTableListRelationFilter = {
    every?: TestTableWhereInput
    some?: TestTableWhereInput
    none?: TestTableWhereInput
  }

  export type TestTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchTableCountOrderByAggregateInput = {
    id?: SortOrder
    Branchcode?: SortOrder
    Branchname?: SortOrder
    universityId?: SortOrder
  }

  export type BranchTableAvgOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type BranchTableMaxOrderByAggregateInput = {
    id?: SortOrder
    Branchcode?: SortOrder
    Branchname?: SortOrder
    universityId?: SortOrder
  }

  export type BranchTableMinOrderByAggregateInput = {
    id?: SortOrder
    Branchcode?: SortOrder
    Branchname?: SortOrder
    universityId?: SortOrder
  }

  export type BranchTableSumOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type YearTableCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
  }

  export type YearTableAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
  }

  export type YearTableMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
  }

  export type YearTableMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
  }

  export type YearTableSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
  }

  export type BranchTableScalarRelationFilter = {
    is?: BranchTableWhereInput
    isNot?: BranchTableWhereInput
  }

  export type YearTableScalarRelationFilter = {
    is?: YearTableWhereInput
    isNot?: YearTableWhereInput
  }

  export type ResultTableListRelationFilter = {
    every?: ResultTableWhereInput
    some?: ResultTableWhereInput
    none?: ResultTableWhereInput
  }

  export type ResultTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentTableCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    PRN?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
  }

  export type StudentTableAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
  }

  export type StudentTableMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    PRN?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
  }

  export type StudentTableMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    PRN?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
  }

  export type StudentTableSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
    yearId?: SortOrder
  }

  export type TeacherTableCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
  }

  export type TeacherTableAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
  }

  export type TeacherTableMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
  }

  export type TeacherTableMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
  }

  export type TeacherTableSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    universityId?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TeacherTableScalarRelationFilter = {
    is?: TeacherTableWhereInput
    isNot?: TeacherTableWhereInput
  }

  export type QuestionsTableListRelationFilter = {
    every?: QuestionsTableWhereInput
    some?: QuestionsTableWhereInput
    none?: QuestionsTableWhereInput
  }

  export type QuestionsTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestTableCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    subject?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
    scheduledDate?: SortOrder
  }

  export type TestTableAvgOrderByAggregateInput = {
    id?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
  }

  export type TestTableMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    subject?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
    scheduledDate?: SortOrder
  }

  export type TestTableMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    subject?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
    scheduledDate?: SortOrder
  }

  export type TestTableSumOrderByAggregateInput = {
    id?: SortOrder
    teacherID?: SortOrder
    branchId?: SortOrder
    yearId?: SortOrder
    totalmarks?: SortOrder
    duration?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TestTableScalarRelationFilter = {
    is?: TestTableWhereInput
    isNot?: TestTableWhereInput
  }

  export type QuestionsTableCountOrderByAggregateInput = {
    id?: SortOrder
    queText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
  }

  export type QuestionsTableAvgOrderByAggregateInput = {
    id?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
  }

  export type QuestionsTableMaxOrderByAggregateInput = {
    id?: SortOrder
    queText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
  }

  export type QuestionsTableMinOrderByAggregateInput = {
    id?: SortOrder
    queText?: SortOrder
    optionA?: SortOrder
    optionB?: SortOrder
    optionC?: SortOrder
    optionD?: SortOrder
    correctOption?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
  }

  export type QuestionsTableSumOrderByAggregateInput = {
    id?: SortOrder
    maxMark?: SortOrder
    testId?: SortOrder
  }

  export type StudentTableScalarRelationFilter = {
    is?: StudentTableWhereInput
    isNot?: StudentTableWhereInput
  }

  export type ResultTableCountOrderByAggregateInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
  }

  export type ResultTableAvgOrderByAggregateInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
  }

  export type ResultTableMaxOrderByAggregateInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
  }

  export type ResultTableMinOrderByAggregateInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
  }

  export type ResultTableSumOrderByAggregateInput = {
    id?: SortOrder
    totalmarks?: SortOrder
    scoredmarks?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
  }

  export type BranchTableCreateNestedManyWithoutUniversityInput = {
    create?: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput> | BranchTableCreateWithoutUniversityInput[] | BranchTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: BranchTableCreateOrConnectWithoutUniversityInput | BranchTableCreateOrConnectWithoutUniversityInput[]
    createMany?: BranchTableCreateManyUniversityInputEnvelope
    connect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
  }

  export type StudentTableCreateNestedManyWithoutUniversityInput = {
    create?: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput> | StudentTableCreateWithoutUniversityInput[] | StudentTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutUniversityInput | StudentTableCreateOrConnectWithoutUniversityInput[]
    createMany?: StudentTableCreateManyUniversityInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TeacherTableCreateNestedManyWithoutUniversityInput = {
    create?: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput> | TeacherTableCreateWithoutUniversityInput[] | TeacherTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutUniversityInput | TeacherTableCreateOrConnectWithoutUniversityInput[]
    createMany?: TeacherTableCreateManyUniversityInputEnvelope
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
  }

  export type BranchTableUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput> | BranchTableCreateWithoutUniversityInput[] | BranchTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: BranchTableCreateOrConnectWithoutUniversityInput | BranchTableCreateOrConnectWithoutUniversityInput[]
    createMany?: BranchTableCreateManyUniversityInputEnvelope
    connect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
  }

  export type StudentTableUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput> | StudentTableCreateWithoutUniversityInput[] | StudentTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutUniversityInput | StudentTableCreateOrConnectWithoutUniversityInput[]
    createMany?: StudentTableCreateManyUniversityInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TeacherTableUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput> | TeacherTableCreateWithoutUniversityInput[] | TeacherTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutUniversityInput | TeacherTableCreateOrConnectWithoutUniversityInput[]
    createMany?: TeacherTableCreateManyUniversityInputEnvelope
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BranchTableUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput> | BranchTableCreateWithoutUniversityInput[] | BranchTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: BranchTableCreateOrConnectWithoutUniversityInput | BranchTableCreateOrConnectWithoutUniversityInput[]
    upsert?: BranchTableUpsertWithWhereUniqueWithoutUniversityInput | BranchTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: BranchTableCreateManyUniversityInputEnvelope
    set?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    disconnect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    delete?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    connect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    update?: BranchTableUpdateWithWhereUniqueWithoutUniversityInput | BranchTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: BranchTableUpdateManyWithWhereWithoutUniversityInput | BranchTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: BranchTableScalarWhereInput | BranchTableScalarWhereInput[]
  }

  export type StudentTableUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput> | StudentTableCreateWithoutUniversityInput[] | StudentTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutUniversityInput | StudentTableCreateOrConnectWithoutUniversityInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutUniversityInput | StudentTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: StudentTableCreateManyUniversityInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutUniversityInput | StudentTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutUniversityInput | StudentTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TeacherTableUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput> | TeacherTableCreateWithoutUniversityInput[] | TeacherTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutUniversityInput | TeacherTableCreateOrConnectWithoutUniversityInput[]
    upsert?: TeacherTableUpsertWithWhereUniqueWithoutUniversityInput | TeacherTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: TeacherTableCreateManyUniversityInputEnvelope
    set?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    disconnect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    delete?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    update?: TeacherTableUpdateWithWhereUniqueWithoutUniversityInput | TeacherTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: TeacherTableUpdateManyWithWhereWithoutUniversityInput | TeacherTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BranchTableUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput> | BranchTableCreateWithoutUniversityInput[] | BranchTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: BranchTableCreateOrConnectWithoutUniversityInput | BranchTableCreateOrConnectWithoutUniversityInput[]
    upsert?: BranchTableUpsertWithWhereUniqueWithoutUniversityInput | BranchTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: BranchTableCreateManyUniversityInputEnvelope
    set?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    disconnect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    delete?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    connect?: BranchTableWhereUniqueInput | BranchTableWhereUniqueInput[]
    update?: BranchTableUpdateWithWhereUniqueWithoutUniversityInput | BranchTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: BranchTableUpdateManyWithWhereWithoutUniversityInput | BranchTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: BranchTableScalarWhereInput | BranchTableScalarWhereInput[]
  }

  export type StudentTableUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput> | StudentTableCreateWithoutUniversityInput[] | StudentTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutUniversityInput | StudentTableCreateOrConnectWithoutUniversityInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutUniversityInput | StudentTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: StudentTableCreateManyUniversityInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutUniversityInput | StudentTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutUniversityInput | StudentTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TeacherTableUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput> | TeacherTableCreateWithoutUniversityInput[] | TeacherTableUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutUniversityInput | TeacherTableCreateOrConnectWithoutUniversityInput[]
    upsert?: TeacherTableUpsertWithWhereUniqueWithoutUniversityInput | TeacherTableUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: TeacherTableCreateManyUniversityInputEnvelope
    set?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    disconnect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    delete?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    update?: TeacherTableUpdateWithWhereUniqueWithoutUniversityInput | TeacherTableUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: TeacherTableUpdateManyWithWhereWithoutUniversityInput | TeacherTableUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
  }

  export type UniversityTableCreateNestedOneWithoutBranchesInput = {
    create?: XOR<UniversityTableCreateWithoutBranchesInput, UniversityTableUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutBranchesInput
    connect?: UniversityTableWhereUniqueInput
  }

  export type StudentTableCreateNestedManyWithoutBranchInput = {
    create?: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput> | StudentTableCreateWithoutBranchInput[] | StudentTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutBranchInput | StudentTableCreateOrConnectWithoutBranchInput[]
    createMany?: StudentTableCreateManyBranchInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TeacherTableCreateNestedManyWithoutBranchInput = {
    create?: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput> | TeacherTableCreateWithoutBranchInput[] | TeacherTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutBranchInput | TeacherTableCreateOrConnectWithoutBranchInput[]
    createMany?: TeacherTableCreateManyBranchInputEnvelope
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
  }

  export type TestTableCreateNestedManyWithoutBranchInput = {
    create?: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput> | TestTableCreateWithoutBranchInput[] | TestTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutBranchInput | TestTableCreateOrConnectWithoutBranchInput[]
    createMany?: TestTableCreateManyBranchInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type StudentTableUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput> | StudentTableCreateWithoutBranchInput[] | StudentTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutBranchInput | StudentTableCreateOrConnectWithoutBranchInput[]
    createMany?: StudentTableCreateManyBranchInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TeacherTableUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput> | TeacherTableCreateWithoutBranchInput[] | TeacherTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutBranchInput | TeacherTableCreateOrConnectWithoutBranchInput[]
    createMany?: TeacherTableCreateManyBranchInputEnvelope
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
  }

  export type TestTableUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput> | TestTableCreateWithoutBranchInput[] | TestTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutBranchInput | TestTableCreateOrConnectWithoutBranchInput[]
    createMany?: TestTableCreateManyBranchInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type UniversityTableUpdateOneRequiredWithoutBranchesNestedInput = {
    create?: XOR<UniversityTableCreateWithoutBranchesInput, UniversityTableUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutBranchesInput
    upsert?: UniversityTableUpsertWithoutBranchesInput
    connect?: UniversityTableWhereUniqueInput
    update?: XOR<XOR<UniversityTableUpdateToOneWithWhereWithoutBranchesInput, UniversityTableUpdateWithoutBranchesInput>, UniversityTableUncheckedUpdateWithoutBranchesInput>
  }

  export type StudentTableUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput> | StudentTableCreateWithoutBranchInput[] | StudentTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutBranchInput | StudentTableCreateOrConnectWithoutBranchInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutBranchInput | StudentTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StudentTableCreateManyBranchInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutBranchInput | StudentTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutBranchInput | StudentTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TeacherTableUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput> | TeacherTableCreateWithoutBranchInput[] | TeacherTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutBranchInput | TeacherTableCreateOrConnectWithoutBranchInput[]
    upsert?: TeacherTableUpsertWithWhereUniqueWithoutBranchInput | TeacherTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TeacherTableCreateManyBranchInputEnvelope
    set?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    disconnect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    delete?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    update?: TeacherTableUpdateWithWhereUniqueWithoutBranchInput | TeacherTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TeacherTableUpdateManyWithWhereWithoutBranchInput | TeacherTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
  }

  export type TestTableUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput> | TestTableCreateWithoutBranchInput[] | TestTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutBranchInput | TestTableCreateOrConnectWithoutBranchInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutBranchInput | TestTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TestTableCreateManyBranchInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutBranchInput | TestTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutBranchInput | TestTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type StudentTableUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput> | StudentTableCreateWithoutBranchInput[] | StudentTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutBranchInput | StudentTableCreateOrConnectWithoutBranchInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutBranchInput | StudentTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StudentTableCreateManyBranchInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutBranchInput | StudentTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutBranchInput | StudentTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TeacherTableUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput> | TeacherTableCreateWithoutBranchInput[] | TeacherTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TeacherTableCreateOrConnectWithoutBranchInput | TeacherTableCreateOrConnectWithoutBranchInput[]
    upsert?: TeacherTableUpsertWithWhereUniqueWithoutBranchInput | TeacherTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TeacherTableCreateManyBranchInputEnvelope
    set?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    disconnect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    delete?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    connect?: TeacherTableWhereUniqueInput | TeacherTableWhereUniqueInput[]
    update?: TeacherTableUpdateWithWhereUniqueWithoutBranchInput | TeacherTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TeacherTableUpdateManyWithWhereWithoutBranchInput | TeacherTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
  }

  export type TestTableUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput> | TestTableCreateWithoutBranchInput[] | TestTableUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutBranchInput | TestTableCreateOrConnectWithoutBranchInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutBranchInput | TestTableUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TestTableCreateManyBranchInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutBranchInput | TestTableUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutBranchInput | TestTableUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type StudentTableCreateNestedManyWithoutYearInput = {
    create?: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput> | StudentTableCreateWithoutYearInput[] | StudentTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutYearInput | StudentTableCreateOrConnectWithoutYearInput[]
    createMany?: StudentTableCreateManyYearInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TestTableCreateNestedManyWithoutYearInput = {
    create?: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput> | TestTableCreateWithoutYearInput[] | TestTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutYearInput | TestTableCreateOrConnectWithoutYearInput[]
    createMany?: TestTableCreateManyYearInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type StudentTableUncheckedCreateNestedManyWithoutYearInput = {
    create?: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput> | StudentTableCreateWithoutYearInput[] | StudentTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutYearInput | StudentTableCreateOrConnectWithoutYearInput[]
    createMany?: StudentTableCreateManyYearInputEnvelope
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
  }

  export type TestTableUncheckedCreateNestedManyWithoutYearInput = {
    create?: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput> | TestTableCreateWithoutYearInput[] | TestTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutYearInput | TestTableCreateOrConnectWithoutYearInput[]
    createMany?: TestTableCreateManyYearInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type StudentTableUpdateManyWithoutYearNestedInput = {
    create?: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput> | StudentTableCreateWithoutYearInput[] | StudentTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutYearInput | StudentTableCreateOrConnectWithoutYearInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutYearInput | StudentTableUpsertWithWhereUniqueWithoutYearInput[]
    createMany?: StudentTableCreateManyYearInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutYearInput | StudentTableUpdateWithWhereUniqueWithoutYearInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutYearInput | StudentTableUpdateManyWithWhereWithoutYearInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TestTableUpdateManyWithoutYearNestedInput = {
    create?: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput> | TestTableCreateWithoutYearInput[] | TestTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutYearInput | TestTableCreateOrConnectWithoutYearInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutYearInput | TestTableUpsertWithWhereUniqueWithoutYearInput[]
    createMany?: TestTableCreateManyYearInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutYearInput | TestTableUpdateWithWhereUniqueWithoutYearInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutYearInput | TestTableUpdateManyWithWhereWithoutYearInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type StudentTableUncheckedUpdateManyWithoutYearNestedInput = {
    create?: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput> | StudentTableCreateWithoutYearInput[] | StudentTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: StudentTableCreateOrConnectWithoutYearInput | StudentTableCreateOrConnectWithoutYearInput[]
    upsert?: StudentTableUpsertWithWhereUniqueWithoutYearInput | StudentTableUpsertWithWhereUniqueWithoutYearInput[]
    createMany?: StudentTableCreateManyYearInputEnvelope
    set?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    disconnect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    delete?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    connect?: StudentTableWhereUniqueInput | StudentTableWhereUniqueInput[]
    update?: StudentTableUpdateWithWhereUniqueWithoutYearInput | StudentTableUpdateWithWhereUniqueWithoutYearInput[]
    updateMany?: StudentTableUpdateManyWithWhereWithoutYearInput | StudentTableUpdateManyWithWhereWithoutYearInput[]
    deleteMany?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
  }

  export type TestTableUncheckedUpdateManyWithoutYearNestedInput = {
    create?: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput> | TestTableCreateWithoutYearInput[] | TestTableUncheckedCreateWithoutYearInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutYearInput | TestTableCreateOrConnectWithoutYearInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutYearInput | TestTableUpsertWithWhereUniqueWithoutYearInput[]
    createMany?: TestTableCreateManyYearInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutYearInput | TestTableUpdateWithWhereUniqueWithoutYearInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutYearInput | TestTableUpdateManyWithWhereWithoutYearInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type BranchTableCreateNestedOneWithoutStudentsInput = {
    create?: XOR<BranchTableCreateWithoutStudentsInput, BranchTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutStudentsInput
    connect?: BranchTableWhereUniqueInput
  }

  export type UniversityTableCreateNestedOneWithoutStudentsInput = {
    create?: XOR<UniversityTableCreateWithoutStudentsInput, UniversityTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutStudentsInput
    connect?: UniversityTableWhereUniqueInput
  }

  export type YearTableCreateNestedOneWithoutStudentsInput = {
    create?: XOR<YearTableCreateWithoutStudentsInput, YearTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: YearTableCreateOrConnectWithoutStudentsInput
    connect?: YearTableWhereUniqueInput
  }

  export type ResultTableCreateNestedManyWithoutStudentInput = {
    create?: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput> | ResultTableCreateWithoutStudentInput[] | ResultTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutStudentInput | ResultTableCreateOrConnectWithoutStudentInput[]
    createMany?: ResultTableCreateManyStudentInputEnvelope
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
  }

  export type ResultTableUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput> | ResultTableCreateWithoutStudentInput[] | ResultTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutStudentInput | ResultTableCreateOrConnectWithoutStudentInput[]
    createMany?: ResultTableCreateManyStudentInputEnvelope
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
  }

  export type BranchTableUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<BranchTableCreateWithoutStudentsInput, BranchTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutStudentsInput
    upsert?: BranchTableUpsertWithoutStudentsInput
    connect?: BranchTableWhereUniqueInput
    update?: XOR<XOR<BranchTableUpdateToOneWithWhereWithoutStudentsInput, BranchTableUpdateWithoutStudentsInput>, BranchTableUncheckedUpdateWithoutStudentsInput>
  }

  export type UniversityTableUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<UniversityTableCreateWithoutStudentsInput, UniversityTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutStudentsInput
    upsert?: UniversityTableUpsertWithoutStudentsInput
    connect?: UniversityTableWhereUniqueInput
    update?: XOR<XOR<UniversityTableUpdateToOneWithWhereWithoutStudentsInput, UniversityTableUpdateWithoutStudentsInput>, UniversityTableUncheckedUpdateWithoutStudentsInput>
  }

  export type YearTableUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<YearTableCreateWithoutStudentsInput, YearTableUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: YearTableCreateOrConnectWithoutStudentsInput
    upsert?: YearTableUpsertWithoutStudentsInput
    connect?: YearTableWhereUniqueInput
    update?: XOR<XOR<YearTableUpdateToOneWithWhereWithoutStudentsInput, YearTableUpdateWithoutStudentsInput>, YearTableUncheckedUpdateWithoutStudentsInput>
  }

  export type ResultTableUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput> | ResultTableCreateWithoutStudentInput[] | ResultTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutStudentInput | ResultTableCreateOrConnectWithoutStudentInput[]
    upsert?: ResultTableUpsertWithWhereUniqueWithoutStudentInput | ResultTableUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ResultTableCreateManyStudentInputEnvelope
    set?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    disconnect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    delete?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    update?: ResultTableUpdateWithWhereUniqueWithoutStudentInput | ResultTableUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ResultTableUpdateManyWithWhereWithoutStudentInput | ResultTableUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
  }

  export type ResultTableUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput> | ResultTableCreateWithoutStudentInput[] | ResultTableUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutStudentInput | ResultTableCreateOrConnectWithoutStudentInput[]
    upsert?: ResultTableUpsertWithWhereUniqueWithoutStudentInput | ResultTableUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ResultTableCreateManyStudentInputEnvelope
    set?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    disconnect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    delete?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    update?: ResultTableUpdateWithWhereUniqueWithoutStudentInput | ResultTableUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ResultTableUpdateManyWithWhereWithoutStudentInput | ResultTableUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
  }

  export type BranchTableCreateNestedOneWithoutTeachersInput = {
    create?: XOR<BranchTableCreateWithoutTeachersInput, BranchTableUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutTeachersInput
    connect?: BranchTableWhereUniqueInput
  }

  export type UniversityTableCreateNestedOneWithoutTeachersInput = {
    create?: XOR<UniversityTableCreateWithoutTeachersInput, UniversityTableUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutTeachersInput
    connect?: UniversityTableWhereUniqueInput
  }

  export type TestTableCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput> | TestTableCreateWithoutTeacherInput[] | TestTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutTeacherInput | TestTableCreateOrConnectWithoutTeacherInput[]
    createMany?: TestTableCreateManyTeacherInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type TestTableUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput> | TestTableCreateWithoutTeacherInput[] | TestTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutTeacherInput | TestTableCreateOrConnectWithoutTeacherInput[]
    createMany?: TestTableCreateManyTeacherInputEnvelope
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
  }

  export type BranchTableUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<BranchTableCreateWithoutTeachersInput, BranchTableUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutTeachersInput
    upsert?: BranchTableUpsertWithoutTeachersInput
    connect?: BranchTableWhereUniqueInput
    update?: XOR<XOR<BranchTableUpdateToOneWithWhereWithoutTeachersInput, BranchTableUpdateWithoutTeachersInput>, BranchTableUncheckedUpdateWithoutTeachersInput>
  }

  export type UniversityTableUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<UniversityTableCreateWithoutTeachersInput, UniversityTableUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: UniversityTableCreateOrConnectWithoutTeachersInput
    upsert?: UniversityTableUpsertWithoutTeachersInput
    connect?: UniversityTableWhereUniqueInput
    update?: XOR<XOR<UniversityTableUpdateToOneWithWhereWithoutTeachersInput, UniversityTableUpdateWithoutTeachersInput>, UniversityTableUncheckedUpdateWithoutTeachersInput>
  }

  export type TestTableUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput> | TestTableCreateWithoutTeacherInput[] | TestTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutTeacherInput | TestTableCreateOrConnectWithoutTeacherInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutTeacherInput | TestTableUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TestTableCreateManyTeacherInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutTeacherInput | TestTableUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutTeacherInput | TestTableUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type TestTableUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput> | TestTableCreateWithoutTeacherInput[] | TestTableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTableCreateOrConnectWithoutTeacherInput | TestTableCreateOrConnectWithoutTeacherInput[]
    upsert?: TestTableUpsertWithWhereUniqueWithoutTeacherInput | TestTableUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TestTableCreateManyTeacherInputEnvelope
    set?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    disconnect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    delete?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    connect?: TestTableWhereUniqueInput | TestTableWhereUniqueInput[]
    update?: TestTableUpdateWithWhereUniqueWithoutTeacherInput | TestTableUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TestTableUpdateManyWithWhereWithoutTeacherInput | TestTableUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
  }

  export type TeacherTableCreateNestedOneWithoutTestsInput = {
    create?: XOR<TeacherTableCreateWithoutTestsInput, TeacherTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: TeacherTableCreateOrConnectWithoutTestsInput
    connect?: TeacherTableWhereUniqueInput
  }

  export type BranchTableCreateNestedOneWithoutTestsInput = {
    create?: XOR<BranchTableCreateWithoutTestsInput, BranchTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutTestsInput
    connect?: BranchTableWhereUniqueInput
  }

  export type YearTableCreateNestedOneWithoutTestsInput = {
    create?: XOR<YearTableCreateWithoutTestsInput, YearTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: YearTableCreateOrConnectWithoutTestsInput
    connect?: YearTableWhereUniqueInput
  }

  export type QuestionsTableCreateNestedManyWithoutTestInput = {
    create?: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput> | QuestionsTableCreateWithoutTestInput[] | QuestionsTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: QuestionsTableCreateOrConnectWithoutTestInput | QuestionsTableCreateOrConnectWithoutTestInput[]
    createMany?: QuestionsTableCreateManyTestInputEnvelope
    connect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
  }

  export type ResultTableCreateNestedManyWithoutTestInput = {
    create?: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput> | ResultTableCreateWithoutTestInput[] | ResultTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutTestInput | ResultTableCreateOrConnectWithoutTestInput[]
    createMany?: ResultTableCreateManyTestInputEnvelope
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
  }

  export type QuestionsTableUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput> | QuestionsTableCreateWithoutTestInput[] | QuestionsTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: QuestionsTableCreateOrConnectWithoutTestInput | QuestionsTableCreateOrConnectWithoutTestInput[]
    createMany?: QuestionsTableCreateManyTestInputEnvelope
    connect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
  }

  export type ResultTableUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput> | ResultTableCreateWithoutTestInput[] | ResultTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutTestInput | ResultTableCreateOrConnectWithoutTestInput[]
    createMany?: ResultTableCreateManyTestInputEnvelope
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TeacherTableUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<TeacherTableCreateWithoutTestsInput, TeacherTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: TeacherTableCreateOrConnectWithoutTestsInput
    upsert?: TeacherTableUpsertWithoutTestsInput
    connect?: TeacherTableWhereUniqueInput
    update?: XOR<XOR<TeacherTableUpdateToOneWithWhereWithoutTestsInput, TeacherTableUpdateWithoutTestsInput>, TeacherTableUncheckedUpdateWithoutTestsInput>
  }

  export type BranchTableUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<BranchTableCreateWithoutTestsInput, BranchTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: BranchTableCreateOrConnectWithoutTestsInput
    upsert?: BranchTableUpsertWithoutTestsInput
    connect?: BranchTableWhereUniqueInput
    update?: XOR<XOR<BranchTableUpdateToOneWithWhereWithoutTestsInput, BranchTableUpdateWithoutTestsInput>, BranchTableUncheckedUpdateWithoutTestsInput>
  }

  export type YearTableUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<YearTableCreateWithoutTestsInput, YearTableUncheckedCreateWithoutTestsInput>
    connectOrCreate?: YearTableCreateOrConnectWithoutTestsInput
    upsert?: YearTableUpsertWithoutTestsInput
    connect?: YearTableWhereUniqueInput
    update?: XOR<XOR<YearTableUpdateToOneWithWhereWithoutTestsInput, YearTableUpdateWithoutTestsInput>, YearTableUncheckedUpdateWithoutTestsInput>
  }

  export type QuestionsTableUpdateManyWithoutTestNestedInput = {
    create?: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput> | QuestionsTableCreateWithoutTestInput[] | QuestionsTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: QuestionsTableCreateOrConnectWithoutTestInput | QuestionsTableCreateOrConnectWithoutTestInput[]
    upsert?: QuestionsTableUpsertWithWhereUniqueWithoutTestInput | QuestionsTableUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: QuestionsTableCreateManyTestInputEnvelope
    set?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    disconnect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    delete?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    connect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    update?: QuestionsTableUpdateWithWhereUniqueWithoutTestInput | QuestionsTableUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: QuestionsTableUpdateManyWithWhereWithoutTestInput | QuestionsTableUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: QuestionsTableScalarWhereInput | QuestionsTableScalarWhereInput[]
  }

  export type ResultTableUpdateManyWithoutTestNestedInput = {
    create?: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput> | ResultTableCreateWithoutTestInput[] | ResultTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutTestInput | ResultTableCreateOrConnectWithoutTestInput[]
    upsert?: ResultTableUpsertWithWhereUniqueWithoutTestInput | ResultTableUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: ResultTableCreateManyTestInputEnvelope
    set?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    disconnect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    delete?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    update?: ResultTableUpdateWithWhereUniqueWithoutTestInput | ResultTableUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: ResultTableUpdateManyWithWhereWithoutTestInput | ResultTableUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
  }

  export type QuestionsTableUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput> | QuestionsTableCreateWithoutTestInput[] | QuestionsTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: QuestionsTableCreateOrConnectWithoutTestInput | QuestionsTableCreateOrConnectWithoutTestInput[]
    upsert?: QuestionsTableUpsertWithWhereUniqueWithoutTestInput | QuestionsTableUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: QuestionsTableCreateManyTestInputEnvelope
    set?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    disconnect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    delete?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    connect?: QuestionsTableWhereUniqueInput | QuestionsTableWhereUniqueInput[]
    update?: QuestionsTableUpdateWithWhereUniqueWithoutTestInput | QuestionsTableUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: QuestionsTableUpdateManyWithWhereWithoutTestInput | QuestionsTableUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: QuestionsTableScalarWhereInput | QuestionsTableScalarWhereInput[]
  }

  export type ResultTableUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput> | ResultTableCreateWithoutTestInput[] | ResultTableUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultTableCreateOrConnectWithoutTestInput | ResultTableCreateOrConnectWithoutTestInput[]
    upsert?: ResultTableUpsertWithWhereUniqueWithoutTestInput | ResultTableUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: ResultTableCreateManyTestInputEnvelope
    set?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    disconnect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    delete?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    connect?: ResultTableWhereUniqueInput | ResultTableWhereUniqueInput[]
    update?: ResultTableUpdateWithWhereUniqueWithoutTestInput | ResultTableUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: ResultTableUpdateManyWithWhereWithoutTestInput | ResultTableUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
  }

  export type TestTableCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<TestTableCreateWithoutQuestionsInput, TestTableUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: TestTableCreateOrConnectWithoutQuestionsInput
    connect?: TestTableWhereUniqueInput
  }

  export type TestTableUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<TestTableCreateWithoutQuestionsInput, TestTableUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: TestTableCreateOrConnectWithoutQuestionsInput
    upsert?: TestTableUpsertWithoutQuestionsInput
    connect?: TestTableWhereUniqueInput
    update?: XOR<XOR<TestTableUpdateToOneWithWhereWithoutQuestionsInput, TestTableUpdateWithoutQuestionsInput>, TestTableUncheckedUpdateWithoutQuestionsInput>
  }

  export type TestTableCreateNestedOneWithoutResultsInput = {
    create?: XOR<TestTableCreateWithoutResultsInput, TestTableUncheckedCreateWithoutResultsInput>
    connectOrCreate?: TestTableCreateOrConnectWithoutResultsInput
    connect?: TestTableWhereUniqueInput
  }

  export type StudentTableCreateNestedOneWithoutResultsInput = {
    create?: XOR<StudentTableCreateWithoutResultsInput, StudentTableUncheckedCreateWithoutResultsInput>
    connectOrCreate?: StudentTableCreateOrConnectWithoutResultsInput
    connect?: StudentTableWhereUniqueInput
  }

  export type TestTableUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<TestTableCreateWithoutResultsInput, TestTableUncheckedCreateWithoutResultsInput>
    connectOrCreate?: TestTableCreateOrConnectWithoutResultsInput
    upsert?: TestTableUpsertWithoutResultsInput
    connect?: TestTableWhereUniqueInput
    update?: XOR<XOR<TestTableUpdateToOneWithWhereWithoutResultsInput, TestTableUpdateWithoutResultsInput>, TestTableUncheckedUpdateWithoutResultsInput>
  }

  export type StudentTableUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<StudentTableCreateWithoutResultsInput, StudentTableUncheckedCreateWithoutResultsInput>
    connectOrCreate?: StudentTableCreateOrConnectWithoutResultsInput
    upsert?: StudentTableUpsertWithoutResultsInput
    connect?: StudentTableWhereUniqueInput
    update?: XOR<XOR<StudentTableUpdateToOneWithWhereWithoutResultsInput, StudentTableUpdateWithoutResultsInput>, StudentTableUncheckedUpdateWithoutResultsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BranchTableCreateWithoutUniversityInput = {
    Branchcode: string
    Branchname: string
    students?: StudentTableCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableCreateNestedManyWithoutBranchInput
    tests?: TestTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateWithoutUniversityInput = {
    id?: number
    Branchcode: string
    Branchname: string
    students?: StudentTableUncheckedCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutBranchInput
    tests?: TestTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableCreateOrConnectWithoutUniversityInput = {
    where: BranchTableWhereUniqueInput
    create: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput>
  }

  export type BranchTableCreateManyUniversityInputEnvelope = {
    data: BranchTableCreateManyUniversityInput | BranchTableCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type StudentTableCreateWithoutUniversityInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branch: BranchTableCreateNestedOneWithoutStudentsInput
    year: YearTableCreateNestedOneWithoutStudentsInput
    results?: ResultTableCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUncheckedCreateWithoutUniversityInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    yearId: number
    results?: ResultTableUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentTableCreateOrConnectWithoutUniversityInput = {
    where: StudentTableWhereUniqueInput
    create: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput>
  }

  export type StudentTableCreateManyUniversityInputEnvelope = {
    data: StudentTableCreateManyUniversityInput | StudentTableCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type TeacherTableCreateWithoutUniversityInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    branch: BranchTableCreateNestedOneWithoutTeachersInput
    tests?: TestTableCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableUncheckedCreateWithoutUniversityInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
    tests?: TestTableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableCreateOrConnectWithoutUniversityInput = {
    where: TeacherTableWhereUniqueInput
    create: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput>
  }

  export type TeacherTableCreateManyUniversityInputEnvelope = {
    data: TeacherTableCreateManyUniversityInput | TeacherTableCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type BranchTableUpsertWithWhereUniqueWithoutUniversityInput = {
    where: BranchTableWhereUniqueInput
    update: XOR<BranchTableUpdateWithoutUniversityInput, BranchTableUncheckedUpdateWithoutUniversityInput>
    create: XOR<BranchTableCreateWithoutUniversityInput, BranchTableUncheckedCreateWithoutUniversityInput>
  }

  export type BranchTableUpdateWithWhereUniqueWithoutUniversityInput = {
    where: BranchTableWhereUniqueInput
    data: XOR<BranchTableUpdateWithoutUniversityInput, BranchTableUncheckedUpdateWithoutUniversityInput>
  }

  export type BranchTableUpdateManyWithWhereWithoutUniversityInput = {
    where: BranchTableScalarWhereInput
    data: XOR<BranchTableUpdateManyMutationInput, BranchTableUncheckedUpdateManyWithoutUniversityInput>
  }

  export type BranchTableScalarWhereInput = {
    AND?: BranchTableScalarWhereInput | BranchTableScalarWhereInput[]
    OR?: BranchTableScalarWhereInput[]
    NOT?: BranchTableScalarWhereInput | BranchTableScalarWhereInput[]
    id?: IntFilter<"BranchTable"> | number
    Branchcode?: StringFilter<"BranchTable"> | string
    Branchname?: StringFilter<"BranchTable"> | string
    universityId?: IntFilter<"BranchTable"> | number
  }

  export type StudentTableUpsertWithWhereUniqueWithoutUniversityInput = {
    where: StudentTableWhereUniqueInput
    update: XOR<StudentTableUpdateWithoutUniversityInput, StudentTableUncheckedUpdateWithoutUniversityInput>
    create: XOR<StudentTableCreateWithoutUniversityInput, StudentTableUncheckedCreateWithoutUniversityInput>
  }

  export type StudentTableUpdateWithWhereUniqueWithoutUniversityInput = {
    where: StudentTableWhereUniqueInput
    data: XOR<StudentTableUpdateWithoutUniversityInput, StudentTableUncheckedUpdateWithoutUniversityInput>
  }

  export type StudentTableUpdateManyWithWhereWithoutUniversityInput = {
    where: StudentTableScalarWhereInput
    data: XOR<StudentTableUpdateManyMutationInput, StudentTableUncheckedUpdateManyWithoutUniversityInput>
  }

  export type StudentTableScalarWhereInput = {
    AND?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
    OR?: StudentTableScalarWhereInput[]
    NOT?: StudentTableScalarWhereInput | StudentTableScalarWhereInput[]
    id?: IntFilter<"StudentTable"> | number
    firstname?: StringFilter<"StudentTable"> | string
    lastname?: StringFilter<"StudentTable"> | string
    email?: StringFilter<"StudentTable"> | string
    password?: StringFilter<"StudentTable"> | string
    PRN?: StringFilter<"StudentTable"> | string
    branchId?: IntFilter<"StudentTable"> | number
    universityId?: IntFilter<"StudentTable"> | number
    yearId?: IntFilter<"StudentTable"> | number
  }

  export type TeacherTableUpsertWithWhereUniqueWithoutUniversityInput = {
    where: TeacherTableWhereUniqueInput
    update: XOR<TeacherTableUpdateWithoutUniversityInput, TeacherTableUncheckedUpdateWithoutUniversityInput>
    create: XOR<TeacherTableCreateWithoutUniversityInput, TeacherTableUncheckedCreateWithoutUniversityInput>
  }

  export type TeacherTableUpdateWithWhereUniqueWithoutUniversityInput = {
    where: TeacherTableWhereUniqueInput
    data: XOR<TeacherTableUpdateWithoutUniversityInput, TeacherTableUncheckedUpdateWithoutUniversityInput>
  }

  export type TeacherTableUpdateManyWithWhereWithoutUniversityInput = {
    where: TeacherTableScalarWhereInput
    data: XOR<TeacherTableUpdateManyMutationInput, TeacherTableUncheckedUpdateManyWithoutUniversityInput>
  }

  export type TeacherTableScalarWhereInput = {
    AND?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
    OR?: TeacherTableScalarWhereInput[]
    NOT?: TeacherTableScalarWhereInput | TeacherTableScalarWhereInput[]
    id?: IntFilter<"TeacherTable"> | number
    firstname?: StringFilter<"TeacherTable"> | string
    lastname?: StringFilter<"TeacherTable"> | string
    email?: StringFilter<"TeacherTable"> | string
    password?: StringFilter<"TeacherTable"> | string
    branchId?: IntFilter<"TeacherTable"> | number
    universityId?: IntFilter<"TeacherTable"> | number
  }

  export type UniversityTableCreateWithoutBranchesInput = {
    name: string
    address: string
    students?: StudentTableCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUncheckedCreateWithoutBranchesInput = {
    id?: number
    name: string
    address: string
    students?: StudentTableUncheckedCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableCreateOrConnectWithoutBranchesInput = {
    where: UniversityTableWhereUniqueInput
    create: XOR<UniversityTableCreateWithoutBranchesInput, UniversityTableUncheckedCreateWithoutBranchesInput>
  }

  export type StudentTableCreateWithoutBranchInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    university: UniversityTableCreateNestedOneWithoutStudentsInput
    year: YearTableCreateNestedOneWithoutStudentsInput
    results?: ResultTableCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUncheckedCreateWithoutBranchInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    universityId: number
    yearId: number
    results?: ResultTableUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentTableCreateOrConnectWithoutBranchInput = {
    where: StudentTableWhereUniqueInput
    create: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput>
  }

  export type StudentTableCreateManyBranchInputEnvelope = {
    data: StudentTableCreateManyBranchInput | StudentTableCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type TeacherTableCreateWithoutBranchInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    university: UniversityTableCreateNestedOneWithoutTeachersInput
    tests?: TestTableCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableUncheckedCreateWithoutBranchInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    universityId: number
    tests?: TestTableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherTableCreateOrConnectWithoutBranchInput = {
    where: TeacherTableWhereUniqueInput
    create: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput>
  }

  export type TeacherTableCreateManyBranchInputEnvelope = {
    data: TeacherTableCreateManyBranchInput | TeacherTableCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type TestTableCreateWithoutBranchInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    teacher: TeacherTableCreateNestedOneWithoutTestsInput
    year: YearTableCreateNestedOneWithoutTestsInput
    questions?: QuestionsTableCreateNestedManyWithoutTestInput
    results?: ResultTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateWithoutBranchInput = {
    id?: number
    title: string
    teacherID: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    questions?: QuestionsTableUncheckedCreateNestedManyWithoutTestInput
    results?: ResultTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableCreateOrConnectWithoutBranchInput = {
    where: TestTableWhereUniqueInput
    create: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput>
  }

  export type TestTableCreateManyBranchInputEnvelope = {
    data: TestTableCreateManyBranchInput | TestTableCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UniversityTableUpsertWithoutBranchesInput = {
    update: XOR<UniversityTableUpdateWithoutBranchesInput, UniversityTableUncheckedUpdateWithoutBranchesInput>
    create: XOR<UniversityTableCreateWithoutBranchesInput, UniversityTableUncheckedCreateWithoutBranchesInput>
    where?: UniversityTableWhereInput
  }

  export type UniversityTableUpdateToOneWithWhereWithoutBranchesInput = {
    where?: UniversityTableWhereInput
    data: XOR<UniversityTableUpdateWithoutBranchesInput, UniversityTableUncheckedUpdateWithoutBranchesInput>
  }

  export type UniversityTableUpdateWithoutBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    students?: StudentTableUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableUncheckedUpdateWithoutBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    students?: StudentTableUncheckedUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type StudentTableUpsertWithWhereUniqueWithoutBranchInput = {
    where: StudentTableWhereUniqueInput
    update: XOR<StudentTableUpdateWithoutBranchInput, StudentTableUncheckedUpdateWithoutBranchInput>
    create: XOR<StudentTableCreateWithoutBranchInput, StudentTableUncheckedCreateWithoutBranchInput>
  }

  export type StudentTableUpdateWithWhereUniqueWithoutBranchInput = {
    where: StudentTableWhereUniqueInput
    data: XOR<StudentTableUpdateWithoutBranchInput, StudentTableUncheckedUpdateWithoutBranchInput>
  }

  export type StudentTableUpdateManyWithWhereWithoutBranchInput = {
    where: StudentTableScalarWhereInput
    data: XOR<StudentTableUpdateManyMutationInput, StudentTableUncheckedUpdateManyWithoutBranchInput>
  }

  export type TeacherTableUpsertWithWhereUniqueWithoutBranchInput = {
    where: TeacherTableWhereUniqueInput
    update: XOR<TeacherTableUpdateWithoutBranchInput, TeacherTableUncheckedUpdateWithoutBranchInput>
    create: XOR<TeacherTableCreateWithoutBranchInput, TeacherTableUncheckedCreateWithoutBranchInput>
  }

  export type TeacherTableUpdateWithWhereUniqueWithoutBranchInput = {
    where: TeacherTableWhereUniqueInput
    data: XOR<TeacherTableUpdateWithoutBranchInput, TeacherTableUncheckedUpdateWithoutBranchInput>
  }

  export type TeacherTableUpdateManyWithWhereWithoutBranchInput = {
    where: TeacherTableScalarWhereInput
    data: XOR<TeacherTableUpdateManyMutationInput, TeacherTableUncheckedUpdateManyWithoutBranchInput>
  }

  export type TestTableUpsertWithWhereUniqueWithoutBranchInput = {
    where: TestTableWhereUniqueInput
    update: XOR<TestTableUpdateWithoutBranchInput, TestTableUncheckedUpdateWithoutBranchInput>
    create: XOR<TestTableCreateWithoutBranchInput, TestTableUncheckedCreateWithoutBranchInput>
  }

  export type TestTableUpdateWithWhereUniqueWithoutBranchInput = {
    where: TestTableWhereUniqueInput
    data: XOR<TestTableUpdateWithoutBranchInput, TestTableUncheckedUpdateWithoutBranchInput>
  }

  export type TestTableUpdateManyWithWhereWithoutBranchInput = {
    where: TestTableScalarWhereInput
    data: XOR<TestTableUpdateManyMutationInput, TestTableUncheckedUpdateManyWithoutBranchInput>
  }

  export type TestTableScalarWhereInput = {
    AND?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
    OR?: TestTableScalarWhereInput[]
    NOT?: TestTableScalarWhereInput | TestTableScalarWhereInput[]
    id?: IntFilter<"TestTable"> | number
    title?: StringFilter<"TestTable"> | string
    teacherID?: IntFilter<"TestTable"> | number
    branchId?: IntFilter<"TestTable"> | number
    subject?: StringFilter<"TestTable"> | string
    yearId?: IntFilter<"TestTable"> | number
    totalmarks?: IntFilter<"TestTable"> | number
    duration?: IntFilter<"TestTable"> | number
    scheduledDate?: DateTimeFilter<"TestTable"> | Date | string
  }

  export type StudentTableCreateWithoutYearInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branch: BranchTableCreateNestedOneWithoutStudentsInput
    university: UniversityTableCreateNestedOneWithoutStudentsInput
    results?: ResultTableCreateNestedManyWithoutStudentInput
  }

  export type StudentTableUncheckedCreateWithoutYearInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
    results?: ResultTableUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentTableCreateOrConnectWithoutYearInput = {
    where: StudentTableWhereUniqueInput
    create: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput>
  }

  export type StudentTableCreateManyYearInputEnvelope = {
    data: StudentTableCreateManyYearInput | StudentTableCreateManyYearInput[]
    skipDuplicates?: boolean
  }

  export type TestTableCreateWithoutYearInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    teacher: TeacherTableCreateNestedOneWithoutTestsInput
    branch: BranchTableCreateNestedOneWithoutTestsInput
    questions?: QuestionsTableCreateNestedManyWithoutTestInput
    results?: ResultTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateWithoutYearInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    questions?: QuestionsTableUncheckedCreateNestedManyWithoutTestInput
    results?: ResultTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableCreateOrConnectWithoutYearInput = {
    where: TestTableWhereUniqueInput
    create: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput>
  }

  export type TestTableCreateManyYearInputEnvelope = {
    data: TestTableCreateManyYearInput | TestTableCreateManyYearInput[]
    skipDuplicates?: boolean
  }

  export type StudentTableUpsertWithWhereUniqueWithoutYearInput = {
    where: StudentTableWhereUniqueInput
    update: XOR<StudentTableUpdateWithoutYearInput, StudentTableUncheckedUpdateWithoutYearInput>
    create: XOR<StudentTableCreateWithoutYearInput, StudentTableUncheckedCreateWithoutYearInput>
  }

  export type StudentTableUpdateWithWhereUniqueWithoutYearInput = {
    where: StudentTableWhereUniqueInput
    data: XOR<StudentTableUpdateWithoutYearInput, StudentTableUncheckedUpdateWithoutYearInput>
  }

  export type StudentTableUpdateManyWithWhereWithoutYearInput = {
    where: StudentTableScalarWhereInput
    data: XOR<StudentTableUpdateManyMutationInput, StudentTableUncheckedUpdateManyWithoutYearInput>
  }

  export type TestTableUpsertWithWhereUniqueWithoutYearInput = {
    where: TestTableWhereUniqueInput
    update: XOR<TestTableUpdateWithoutYearInput, TestTableUncheckedUpdateWithoutYearInput>
    create: XOR<TestTableCreateWithoutYearInput, TestTableUncheckedCreateWithoutYearInput>
  }

  export type TestTableUpdateWithWhereUniqueWithoutYearInput = {
    where: TestTableWhereUniqueInput
    data: XOR<TestTableUpdateWithoutYearInput, TestTableUncheckedUpdateWithoutYearInput>
  }

  export type TestTableUpdateManyWithWhereWithoutYearInput = {
    where: TestTableScalarWhereInput
    data: XOR<TestTableUpdateManyMutationInput, TestTableUncheckedUpdateManyWithoutYearInput>
  }

  export type BranchTableCreateWithoutStudentsInput = {
    Branchcode: string
    Branchname: string
    university: UniversityTableCreateNestedOneWithoutBranchesInput
    teachers?: TeacherTableCreateNestedManyWithoutBranchInput
    tests?: TestTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateWithoutStudentsInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutBranchInput
    tests?: TestTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableCreateOrConnectWithoutStudentsInput = {
    where: BranchTableWhereUniqueInput
    create: XOR<BranchTableCreateWithoutStudentsInput, BranchTableUncheckedCreateWithoutStudentsInput>
  }

  export type UniversityTableCreateWithoutStudentsInput = {
    name: string
    address: string
    branches?: BranchTableCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUncheckedCreateWithoutStudentsInput = {
    id?: number
    name: string
    address: string
    branches?: BranchTableUncheckedCreateNestedManyWithoutUniversityInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableCreateOrConnectWithoutStudentsInput = {
    where: UniversityTableWhereUniqueInput
    create: XOR<UniversityTableCreateWithoutStudentsInput, UniversityTableUncheckedCreateWithoutStudentsInput>
  }

  export type YearTableCreateWithoutStudentsInput = {
    name: string
    year: number
    tests?: TestTableCreateNestedManyWithoutYearInput
  }

  export type YearTableUncheckedCreateWithoutStudentsInput = {
    id?: number
    name: string
    year: number
    tests?: TestTableUncheckedCreateNestedManyWithoutYearInput
  }

  export type YearTableCreateOrConnectWithoutStudentsInput = {
    where: YearTableWhereUniqueInput
    create: XOR<YearTableCreateWithoutStudentsInput, YearTableUncheckedCreateWithoutStudentsInput>
  }

  export type ResultTableCreateWithoutStudentInput = {
    totalmarks: number
    scoredmarks: number
    test: TestTableCreateNestedOneWithoutResultsInput
  }

  export type ResultTableUncheckedCreateWithoutStudentInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    testId: number
  }

  export type ResultTableCreateOrConnectWithoutStudentInput = {
    where: ResultTableWhereUniqueInput
    create: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput>
  }

  export type ResultTableCreateManyStudentInputEnvelope = {
    data: ResultTableCreateManyStudentInput | ResultTableCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type BranchTableUpsertWithoutStudentsInput = {
    update: XOR<BranchTableUpdateWithoutStudentsInput, BranchTableUncheckedUpdateWithoutStudentsInput>
    create: XOR<BranchTableCreateWithoutStudentsInput, BranchTableUncheckedCreateWithoutStudentsInput>
    where?: BranchTableWhereInput
  }

  export type BranchTableUpdateToOneWithWhereWithoutStudentsInput = {
    where?: BranchTableWhereInput
    data: XOR<BranchTableUpdateWithoutStudentsInput, BranchTableUncheckedUpdateWithoutStudentsInput>
  }

  export type BranchTableUpdateWithoutStudentsInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutBranchesNestedInput
    teachers?: TeacherTableUpdateManyWithoutBranchNestedInput
    tests?: TestTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    teachers?: TeacherTableUncheckedUpdateManyWithoutBranchNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UniversityTableUpsertWithoutStudentsInput = {
    update: XOR<UniversityTableUpdateWithoutStudentsInput, UniversityTableUncheckedUpdateWithoutStudentsInput>
    create: XOR<UniversityTableCreateWithoutStudentsInput, UniversityTableUncheckedCreateWithoutStudentsInput>
    where?: UniversityTableWhereInput
  }

  export type UniversityTableUpdateToOneWithWhereWithoutStudentsInput = {
    where?: UniversityTableWhereInput
    data: XOR<UniversityTableUpdateWithoutStudentsInput, UniversityTableUncheckedUpdateWithoutStudentsInput>
  }

  export type UniversityTableUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUncheckedUpdateManyWithoutUniversityNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type YearTableUpsertWithoutStudentsInput = {
    update: XOR<YearTableUpdateWithoutStudentsInput, YearTableUncheckedUpdateWithoutStudentsInput>
    create: XOR<YearTableCreateWithoutStudentsInput, YearTableUncheckedCreateWithoutStudentsInput>
    where?: YearTableWhereInput
  }

  export type YearTableUpdateToOneWithWhereWithoutStudentsInput = {
    where?: YearTableWhereInput
    data: XOR<YearTableUpdateWithoutStudentsInput, YearTableUncheckedUpdateWithoutStudentsInput>
  }

  export type YearTableUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    tests?: TestTableUpdateManyWithoutYearNestedInput
  }

  export type YearTableUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    tests?: TestTableUncheckedUpdateManyWithoutYearNestedInput
  }

  export type ResultTableUpsertWithWhereUniqueWithoutStudentInput = {
    where: ResultTableWhereUniqueInput
    update: XOR<ResultTableUpdateWithoutStudentInput, ResultTableUncheckedUpdateWithoutStudentInput>
    create: XOR<ResultTableCreateWithoutStudentInput, ResultTableUncheckedCreateWithoutStudentInput>
  }

  export type ResultTableUpdateWithWhereUniqueWithoutStudentInput = {
    where: ResultTableWhereUniqueInput
    data: XOR<ResultTableUpdateWithoutStudentInput, ResultTableUncheckedUpdateWithoutStudentInput>
  }

  export type ResultTableUpdateManyWithWhereWithoutStudentInput = {
    where: ResultTableScalarWhereInput
    data: XOR<ResultTableUpdateManyMutationInput, ResultTableUncheckedUpdateManyWithoutStudentInput>
  }

  export type ResultTableScalarWhereInput = {
    AND?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
    OR?: ResultTableScalarWhereInput[]
    NOT?: ResultTableScalarWhereInput | ResultTableScalarWhereInput[]
    id?: IntFilter<"ResultTable"> | number
    totalmarks?: IntFilter<"ResultTable"> | number
    scoredmarks?: IntFilter<"ResultTable"> | number
    testId?: IntFilter<"ResultTable"> | number
    studentId?: IntFilter<"ResultTable"> | number
  }

  export type BranchTableCreateWithoutTeachersInput = {
    Branchcode: string
    Branchname: string
    university: UniversityTableCreateNestedOneWithoutBranchesInput
    students?: StudentTableCreateNestedManyWithoutBranchInput
    tests?: TestTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateWithoutTeachersInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutBranchInput
    tests?: TestTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableCreateOrConnectWithoutTeachersInput = {
    where: BranchTableWhereUniqueInput
    create: XOR<BranchTableCreateWithoutTeachersInput, BranchTableUncheckedCreateWithoutTeachersInput>
  }

  export type UniversityTableCreateWithoutTeachersInput = {
    name: string
    address: string
    branches?: BranchTableCreateNestedManyWithoutUniversityInput
    students?: StudentTableCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableUncheckedCreateWithoutTeachersInput = {
    id?: number
    name: string
    address: string
    branches?: BranchTableUncheckedCreateNestedManyWithoutUniversityInput
    students?: StudentTableUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityTableCreateOrConnectWithoutTeachersInput = {
    where: UniversityTableWhereUniqueInput
    create: XOR<UniversityTableCreateWithoutTeachersInput, UniversityTableUncheckedCreateWithoutTeachersInput>
  }

  export type TestTableCreateWithoutTeacherInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    branch: BranchTableCreateNestedOneWithoutTestsInput
    year: YearTableCreateNestedOneWithoutTestsInput
    questions?: QuestionsTableCreateNestedManyWithoutTestInput
    results?: ResultTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateWithoutTeacherInput = {
    id?: number
    title: string
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    questions?: QuestionsTableUncheckedCreateNestedManyWithoutTestInput
    results?: ResultTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableCreateOrConnectWithoutTeacherInput = {
    where: TestTableWhereUniqueInput
    create: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput>
  }

  export type TestTableCreateManyTeacherInputEnvelope = {
    data: TestTableCreateManyTeacherInput | TestTableCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type BranchTableUpsertWithoutTeachersInput = {
    update: XOR<BranchTableUpdateWithoutTeachersInput, BranchTableUncheckedUpdateWithoutTeachersInput>
    create: XOR<BranchTableCreateWithoutTeachersInput, BranchTableUncheckedCreateWithoutTeachersInput>
    where?: BranchTableWhereInput
  }

  export type BranchTableUpdateToOneWithWhereWithoutTeachersInput = {
    where?: BranchTableWhereInput
    data: XOR<BranchTableUpdateWithoutTeachersInput, BranchTableUncheckedUpdateWithoutTeachersInput>
  }

  export type BranchTableUpdateWithoutTeachersInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutBranchesNestedInput
    students?: StudentTableUpdateManyWithoutBranchNestedInput
    tests?: TestTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutBranchNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UniversityTableUpsertWithoutTeachersInput = {
    update: XOR<UniversityTableUpdateWithoutTeachersInput, UniversityTableUncheckedUpdateWithoutTeachersInput>
    create: XOR<UniversityTableCreateWithoutTeachersInput, UniversityTableUncheckedCreateWithoutTeachersInput>
    where?: UniversityTableWhereInput
  }

  export type UniversityTableUpdateToOneWithWhereWithoutTeachersInput = {
    where?: UniversityTableWhereInput
    data: XOR<UniversityTableUpdateWithoutTeachersInput, UniversityTableUncheckedUpdateWithoutTeachersInput>
  }

  export type UniversityTableUpdateWithoutTeachersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityTableUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    branches?: BranchTableUncheckedUpdateManyWithoutUniversityNestedInput
    students?: StudentTableUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type TestTableUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TestTableWhereUniqueInput
    update: XOR<TestTableUpdateWithoutTeacherInput, TestTableUncheckedUpdateWithoutTeacherInput>
    create: XOR<TestTableCreateWithoutTeacherInput, TestTableUncheckedCreateWithoutTeacherInput>
  }

  export type TestTableUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TestTableWhereUniqueInput
    data: XOR<TestTableUpdateWithoutTeacherInput, TestTableUncheckedUpdateWithoutTeacherInput>
  }

  export type TestTableUpdateManyWithWhereWithoutTeacherInput = {
    where: TestTableScalarWhereInput
    data: XOR<TestTableUpdateManyMutationInput, TestTableUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherTableCreateWithoutTestsInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    branch: BranchTableCreateNestedOneWithoutTeachersInput
    university: UniversityTableCreateNestedOneWithoutTeachersInput
  }

  export type TeacherTableUncheckedCreateWithoutTestsInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
    universityId: number
  }

  export type TeacherTableCreateOrConnectWithoutTestsInput = {
    where: TeacherTableWhereUniqueInput
    create: XOR<TeacherTableCreateWithoutTestsInput, TeacherTableUncheckedCreateWithoutTestsInput>
  }

  export type BranchTableCreateWithoutTestsInput = {
    Branchcode: string
    Branchname: string
    university: UniversityTableCreateNestedOneWithoutBranchesInput
    students?: StudentTableCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableCreateNestedManyWithoutBranchInput
  }

  export type BranchTableUncheckedCreateWithoutTestsInput = {
    id?: number
    Branchcode: string
    Branchname: string
    universityId: number
    students?: StudentTableUncheckedCreateNestedManyWithoutBranchInput
    teachers?: TeacherTableUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchTableCreateOrConnectWithoutTestsInput = {
    where: BranchTableWhereUniqueInput
    create: XOR<BranchTableCreateWithoutTestsInput, BranchTableUncheckedCreateWithoutTestsInput>
  }

  export type YearTableCreateWithoutTestsInput = {
    name: string
    year: number
    students?: StudentTableCreateNestedManyWithoutYearInput
  }

  export type YearTableUncheckedCreateWithoutTestsInput = {
    id?: number
    name: string
    year: number
    students?: StudentTableUncheckedCreateNestedManyWithoutYearInput
  }

  export type YearTableCreateOrConnectWithoutTestsInput = {
    where: YearTableWhereUniqueInput
    create: XOR<YearTableCreateWithoutTestsInput, YearTableUncheckedCreateWithoutTestsInput>
  }

  export type QuestionsTableCreateWithoutTestInput = {
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
  }

  export type QuestionsTableUncheckedCreateWithoutTestInput = {
    id?: number
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
  }

  export type QuestionsTableCreateOrConnectWithoutTestInput = {
    where: QuestionsTableWhereUniqueInput
    create: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput>
  }

  export type QuestionsTableCreateManyTestInputEnvelope = {
    data: QuestionsTableCreateManyTestInput | QuestionsTableCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type ResultTableCreateWithoutTestInput = {
    totalmarks: number
    scoredmarks: number
    student: StudentTableCreateNestedOneWithoutResultsInput
  }

  export type ResultTableUncheckedCreateWithoutTestInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    studentId: number
  }

  export type ResultTableCreateOrConnectWithoutTestInput = {
    where: ResultTableWhereUniqueInput
    create: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput>
  }

  export type ResultTableCreateManyTestInputEnvelope = {
    data: ResultTableCreateManyTestInput | ResultTableCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type TeacherTableUpsertWithoutTestsInput = {
    update: XOR<TeacherTableUpdateWithoutTestsInput, TeacherTableUncheckedUpdateWithoutTestsInput>
    create: XOR<TeacherTableCreateWithoutTestsInput, TeacherTableUncheckedCreateWithoutTestsInput>
    where?: TeacherTableWhereInput
  }

  export type TeacherTableUpdateToOneWithWhereWithoutTestsInput = {
    where?: TeacherTableWhereInput
    data: XOR<TeacherTableUpdateWithoutTestsInput, TeacherTableUncheckedUpdateWithoutTestsInput>
  }

  export type TeacherTableUpdateWithoutTestsInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutTeachersNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeacherTableUncheckedUpdateWithoutTestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type BranchTableUpsertWithoutTestsInput = {
    update: XOR<BranchTableUpdateWithoutTestsInput, BranchTableUncheckedUpdateWithoutTestsInput>
    create: XOR<BranchTableCreateWithoutTestsInput, BranchTableUncheckedCreateWithoutTestsInput>
    where?: BranchTableWhereInput
  }

  export type BranchTableUpdateToOneWithWhereWithoutTestsInput = {
    where?: BranchTableWhereInput
    data: XOR<BranchTableUpdateWithoutTestsInput, BranchTableUncheckedUpdateWithoutTestsInput>
  }

  export type BranchTableUpdateWithoutTestsInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutBranchesNestedInput
    students?: StudentTableUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateWithoutTestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type YearTableUpsertWithoutTestsInput = {
    update: XOR<YearTableUpdateWithoutTestsInput, YearTableUncheckedUpdateWithoutTestsInput>
    create: XOR<YearTableCreateWithoutTestsInput, YearTableUncheckedCreateWithoutTestsInput>
    where?: YearTableWhereInput
  }

  export type YearTableUpdateToOneWithWhereWithoutTestsInput = {
    where?: YearTableWhereInput
    data: XOR<YearTableUpdateWithoutTestsInput, YearTableUncheckedUpdateWithoutTestsInput>
  }

  export type YearTableUpdateWithoutTestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUpdateManyWithoutYearNestedInput
  }

  export type YearTableUncheckedUpdateWithoutTestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    students?: StudentTableUncheckedUpdateManyWithoutYearNestedInput
  }

  export type QuestionsTableUpsertWithWhereUniqueWithoutTestInput = {
    where: QuestionsTableWhereUniqueInput
    update: XOR<QuestionsTableUpdateWithoutTestInput, QuestionsTableUncheckedUpdateWithoutTestInput>
    create: XOR<QuestionsTableCreateWithoutTestInput, QuestionsTableUncheckedCreateWithoutTestInput>
  }

  export type QuestionsTableUpdateWithWhereUniqueWithoutTestInput = {
    where: QuestionsTableWhereUniqueInput
    data: XOR<QuestionsTableUpdateWithoutTestInput, QuestionsTableUncheckedUpdateWithoutTestInput>
  }

  export type QuestionsTableUpdateManyWithWhereWithoutTestInput = {
    where: QuestionsTableScalarWhereInput
    data: XOR<QuestionsTableUpdateManyMutationInput, QuestionsTableUncheckedUpdateManyWithoutTestInput>
  }

  export type QuestionsTableScalarWhereInput = {
    AND?: QuestionsTableScalarWhereInput | QuestionsTableScalarWhereInput[]
    OR?: QuestionsTableScalarWhereInput[]
    NOT?: QuestionsTableScalarWhereInput | QuestionsTableScalarWhereInput[]
    id?: IntFilter<"QuestionsTable"> | number
    queText?: StringFilter<"QuestionsTable"> | string
    optionA?: StringFilter<"QuestionsTable"> | string
    optionB?: StringFilter<"QuestionsTable"> | string
    optionC?: StringFilter<"QuestionsTable"> | string
    optionD?: StringFilter<"QuestionsTable"> | string
    correctOption?: StringFilter<"QuestionsTable"> | string
    maxMark?: IntFilter<"QuestionsTable"> | number
    testId?: IntFilter<"QuestionsTable"> | number
  }

  export type ResultTableUpsertWithWhereUniqueWithoutTestInput = {
    where: ResultTableWhereUniqueInput
    update: XOR<ResultTableUpdateWithoutTestInput, ResultTableUncheckedUpdateWithoutTestInput>
    create: XOR<ResultTableCreateWithoutTestInput, ResultTableUncheckedCreateWithoutTestInput>
  }

  export type ResultTableUpdateWithWhereUniqueWithoutTestInput = {
    where: ResultTableWhereUniqueInput
    data: XOR<ResultTableUpdateWithoutTestInput, ResultTableUncheckedUpdateWithoutTestInput>
  }

  export type ResultTableUpdateManyWithWhereWithoutTestInput = {
    where: ResultTableScalarWhereInput
    data: XOR<ResultTableUpdateManyMutationInput, ResultTableUncheckedUpdateManyWithoutTestInput>
  }

  export type TestTableCreateWithoutQuestionsInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    teacher: TeacherTableCreateNestedOneWithoutTestsInput
    branch: BranchTableCreateNestedOneWithoutTestsInput
    year: YearTableCreateNestedOneWithoutTestsInput
    results?: ResultTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateWithoutQuestionsInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    results?: ResultTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableCreateOrConnectWithoutQuestionsInput = {
    where: TestTableWhereUniqueInput
    create: XOR<TestTableCreateWithoutQuestionsInput, TestTableUncheckedCreateWithoutQuestionsInput>
  }

  export type TestTableUpsertWithoutQuestionsInput = {
    update: XOR<TestTableUpdateWithoutQuestionsInput, TestTableUncheckedUpdateWithoutQuestionsInput>
    create: XOR<TestTableCreateWithoutQuestionsInput, TestTableUncheckedCreateWithoutQuestionsInput>
    where?: TestTableWhereInput
  }

  export type TestTableUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: TestTableWhereInput
    data: XOR<TestTableUpdateWithoutQuestionsInput, TestTableUncheckedUpdateWithoutQuestionsInput>
  }

  export type TestTableUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutTestsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutTestsNestedInput
    year?: YearTableUpdateOneRequiredWithoutTestsNestedInput
    results?: ResultTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ResultTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestTableCreateWithoutResultsInput = {
    title: string
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    teacher: TeacherTableCreateNestedOneWithoutTestsInput
    branch: BranchTableCreateNestedOneWithoutTestsInput
    year: YearTableCreateNestedOneWithoutTestsInput
    questions?: QuestionsTableCreateNestedManyWithoutTestInput
  }

  export type TestTableUncheckedCreateWithoutResultsInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
    questions?: QuestionsTableUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestTableCreateOrConnectWithoutResultsInput = {
    where: TestTableWhereUniqueInput
    create: XOR<TestTableCreateWithoutResultsInput, TestTableUncheckedCreateWithoutResultsInput>
  }

  export type StudentTableCreateWithoutResultsInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branch: BranchTableCreateNestedOneWithoutStudentsInput
    university: UniversityTableCreateNestedOneWithoutStudentsInput
    year: YearTableCreateNestedOneWithoutStudentsInput
  }

  export type StudentTableUncheckedCreateWithoutResultsInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
    yearId: number
  }

  export type StudentTableCreateOrConnectWithoutResultsInput = {
    where: StudentTableWhereUniqueInput
    create: XOR<StudentTableCreateWithoutResultsInput, StudentTableUncheckedCreateWithoutResultsInput>
  }

  export type TestTableUpsertWithoutResultsInput = {
    update: XOR<TestTableUpdateWithoutResultsInput, TestTableUncheckedUpdateWithoutResultsInput>
    create: XOR<TestTableCreateWithoutResultsInput, TestTableUncheckedCreateWithoutResultsInput>
    where?: TestTableWhereInput
  }

  export type TestTableUpdateToOneWithWhereWithoutResultsInput = {
    where?: TestTableWhereInput
    data: XOR<TestTableUpdateWithoutResultsInput, TestTableUncheckedUpdateWithoutResultsInput>
  }

  export type TestTableUpdateWithoutResultsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutTestsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutTestsNestedInput
    year?: YearTableUpdateOneRequiredWithoutTestsNestedInput
    questions?: QuestionsTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateWithoutResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionsTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type StudentTableUpsertWithoutResultsInput = {
    update: XOR<StudentTableUpdateWithoutResultsInput, StudentTableUncheckedUpdateWithoutResultsInput>
    create: XOR<StudentTableCreateWithoutResultsInput, StudentTableUncheckedCreateWithoutResultsInput>
    where?: StudentTableWhereInput
  }

  export type StudentTableUpdateToOneWithWhereWithoutResultsInput = {
    where?: StudentTableWhereInput
    data: XOR<StudentTableUpdateWithoutResultsInput, StudentTableUncheckedUpdateWithoutResultsInput>
  }

  export type StudentTableUpdateWithoutResultsInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutStudentsNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutStudentsNestedInput
    year?: YearTableUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentTableUncheckedUpdateWithoutResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type BranchTableCreateManyUniversityInput = {
    id?: number
    Branchcode: string
    Branchname: string
  }

  export type StudentTableCreateManyUniversityInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    yearId: number
  }

  export type TeacherTableCreateManyUniversityInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    branchId: number
  }

  export type BranchTableUpdateWithoutUniversityInput = {
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    students?: StudentTableUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUpdateManyWithoutBranchNestedInput
    tests?: TestTableUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
    students?: StudentTableUncheckedUpdateManyWithoutBranchNestedInput
    teachers?: TeacherTableUncheckedUpdateManyWithoutBranchNestedInput
    tests?: TestTableUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchTableUncheckedUpdateManyWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    Branchcode?: StringFieldUpdateOperationsInput | string
    Branchname?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTableUpdateWithoutUniversityInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutStudentsNestedInput
    year?: YearTableUpdateOneRequiredWithoutStudentsNestedInput
    results?: ResultTableUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
    results?: ResultTableUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateManyWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherTableUpdateWithoutUniversityInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutTeachersNestedInput
    tests?: TestTableUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    tests?: TestTableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateManyWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentTableCreateManyBranchInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    universityId: number
    yearId: number
  }

  export type TeacherTableCreateManyBranchInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    universityId: number
  }

  export type TestTableCreateManyBranchInput = {
    id?: number
    title: string
    teacherID: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
  }

  export type StudentTableUpdateWithoutBranchInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutStudentsNestedInput
    year?: YearTableUpdateOneRequiredWithoutStudentsNestedInput
    results?: ResultTableUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
    results?: ResultTableUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherTableUpdateWithoutBranchInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    university?: UniversityTableUpdateOneRequiredWithoutTeachersNestedInput
    tests?: TestTableUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    tests?: TestTableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherTableUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type TestTableUpdateWithoutBranchInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutTestsNestedInput
    year?: YearTableUpdateOneRequiredWithoutTestsNestedInput
    questions?: QuestionsTableUpdateManyWithoutTestNestedInput
    results?: ResultTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionsTableUncheckedUpdateManyWithoutTestNestedInput
    results?: ResultTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTableCreateManyYearInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    PRN: string
    branchId: number
    universityId: number
  }

  export type TestTableCreateManyYearInput = {
    id?: number
    title: string
    teacherID: number
    branchId: number
    subject: string
    totalmarks: number
    duration: number
    scheduledDate: Date | string
  }

  export type StudentTableUpdateWithoutYearInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branch?: BranchTableUpdateOneRequiredWithoutStudentsNestedInput
    university?: UniversityTableUpdateOneRequiredWithoutStudentsNestedInput
    results?: ResultTableUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateWithoutYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    results?: ResultTableUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentTableUncheckedUpdateManyWithoutYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    PRN?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type TestTableUpdateWithoutYearInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherTableUpdateOneRequiredWithoutTestsNestedInput
    branch?: BranchTableUpdateOneRequiredWithoutTestsNestedInput
    questions?: QuestionsTableUpdateManyWithoutTestNestedInput
    results?: ResultTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateWithoutYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionsTableUncheckedUpdateManyWithoutTestNestedInput
    results?: ResultTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateManyWithoutYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    teacherID?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultTableCreateManyStudentInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    testId: number
  }

  export type ResultTableUpdateWithoutStudentInput = {
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    test?: TestTableUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ResultTableUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type TestTableCreateManyTeacherInput = {
    id?: number
    title: string
    branchId: number
    subject: string
    yearId: number
    totalmarks: number
    duration: number
    scheduledDate: Date | string
  }

  export type TestTableUpdateWithoutTeacherInput = {
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchTableUpdateOneRequiredWithoutTestsNestedInput
    year?: YearTableUpdateOneRequiredWithoutTestsNestedInput
    questions?: QuestionsTableUpdateManyWithoutTestNestedInput
    results?: ResultTableUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionsTableUncheckedUpdateManyWithoutTestNestedInput
    results?: ResultTableUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestTableUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    yearId?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsTableCreateManyTestInput = {
    id?: number
    queText: string
    optionA: string
    optionB: string
    optionC: string
    optionD: string
    correctOption: string
    maxMark: number
  }

  export type ResultTableCreateManyTestInput = {
    id?: number
    totalmarks: number
    scoredmarks: number
    studentId: number
  }

  export type QuestionsTableUpdateWithoutTestInput = {
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionsTableUncheckedUpdateWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionsTableUncheckedUpdateManyWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    queText?: StringFieldUpdateOperationsInput | string
    optionA?: StringFieldUpdateOperationsInput | string
    optionB?: StringFieldUpdateOperationsInput | string
    optionC?: StringFieldUpdateOperationsInput | string
    optionD?: StringFieldUpdateOperationsInput | string
    correctOption?: StringFieldUpdateOperationsInput | string
    maxMark?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableUpdateWithoutTestInput = {
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    student?: StudentTableUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ResultTableUncheckedUpdateWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type ResultTableUncheckedUpdateManyWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalmarks?: IntFieldUpdateOperationsInput | number
    scoredmarks?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}